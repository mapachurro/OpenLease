"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const debug = debug_1.default("decoder:decode:calldata");
const read_1 = __importDefault(require("../read"));
const DecodeUtils = __importStar(require("truffle-decode-utils"));
const value_1 = __importDefault(require("./value"));
const calldata_1 = require("../allocate/calldata");
const lodash_range_1 = __importDefault(require("lodash.range"));
function decodeCalldata(definition, pointer, info, base = 0) {
    return __awaiter(this, void 0, void 0, function* () {
        if (DecodeUtils.Definition.isReference(definition)) {
            let dynamic = calldata_1.calldataSize(definition, info.referenceDeclarations, info.calldataAllocations)[1];
            if (dynamic) {
                return yield decodeCalldataReferenceByAddress(definition, pointer, info, base);
            }
            else {
                return yield decodeCalldataReferenceStatic(definition, pointer, info);
            }
        }
        else {
            debug("pointer %o", pointer);
            return yield value_1.default(definition, pointer, info);
        }
    });
}
exports.default = decodeCalldata;
function decodeCalldataReferenceByAddress(definition, pointer, info, base = 0) {
    return __awaiter(this, void 0, void 0, function* () {
        const { state } = info;
        debug("pointer %o", pointer);
        let rawValue = yield read_1.default(pointer, state);
        let startPosition = DecodeUtils.Conversion.toBN(rawValue).toNumber() + base;
        debug("startPosition %d", startPosition);
        let [size, dynamic] = calldata_1.calldataSize(definition, info.referenceDeclarations, info.calldataAllocations);
        if (!dynamic) { //this will only come up when called from stack.ts
            let staticPointer = {
                calldata: {
                    start: startPosition,
                    length: size
                }
            };
            return yield decodeCalldataReferenceStatic(definition, staticPointer, info);
        }
        let length;
        switch (DecodeUtils.Definition.typeClass(definition)) {
            case "bytes":
            case "string":
                length = DecodeUtils.Conversion.toBN(yield read_1.default({
                    calldata: { start: startPosition, length: DecodeUtils.EVM.WORD_SIZE }
                }, state)).toNumber(); //initial word contains length
                let childPointer = {
                    calldata: { start: startPosition + DecodeUtils.EVM.WORD_SIZE, length }
                };
                return yield value_1.default(definition, childPointer, info);
            case "array":
                if (DecodeUtils.Definition.isDynamicArray(definition)) {
                    length = DecodeUtils.Conversion.toBN(yield read_1.default({
                        calldata: { start: startPosition, length: DecodeUtils.EVM.WORD_SIZE },
                    }, state)).toNumber(); // initial word contains array length
                    startPosition += DecodeUtils.EVM.WORD_SIZE; //increment startPosition to
                    //next word, as first word was used for length
                }
                else {
                    length = DecodeUtils.Definition.staticLength(definition);
                }
                //note: I've written this fairly generically, but it is worth noting that
                //since this array is of dynamic type, we know that if it's static length
                //then size must be EVM.WORD_SIZE
                let baseDefinition = definition.baseType || definition.typeName.baseType;
                //I'm deliberately not using the DecodeUtils function for this, because
                //we should *not* need a faked-up type here!
                // replace erroneous `_storage_` type identifiers with `_calldata_`
                baseDefinition = DecodeUtils.Definition.spliceLocation(baseDefinition, "calldata");
                let baseSize = calldata_1.calldataSize(baseDefinition, info.referenceDeclarations, info.calldataAllocations)[0];
                return yield Promise.all(lodash_range_1.default(length).map((index) => decodeCalldata(baseDefinition, { calldata: {
                        start: startPosition + index * baseSize,
                        length: baseSize
                    } }, info, startPosition) //pointer base is always start of list, never the length
                ));
            case "struct":
                return yield decodeCalldataStructByPosition(definition, startPosition, info);
            default:
                // debug("Unknown calldata reference type: %s", DecodeUtils.typeIdentifier(definition));
                return undefined;
        }
    });
}
exports.decodeCalldataReferenceByAddress = decodeCalldataReferenceByAddress;
function decodeCalldataReferenceStatic(definition, pointer, info) {
    return __awaiter(this, void 0, void 0, function* () {
        const { state } = info;
        debug("static");
        debug("pointer %o", pointer);
        switch (DecodeUtils.Definition.typeClass(definition)) {
            case "array":
                //we're in the static case, so we know the array must be statically sized
                const length = DecodeUtils.Definition.staticLength(definition);
                let size = calldata_1.calldataSize(definition, info.referenceDeclarations, info.calldataAllocations)[0];
                let baseDefinition = definition.baseType || definition.typeName.baseType;
                //I'm deliberately not using the DecodeUtils function for this, because
                //we should *not* need a faked-up type here!
                // replace erroneous `_storage_` type identifiers with `_calldata_`
                baseDefinition = DecodeUtils.Definition.spliceLocation(baseDefinition, "calldata");
                let baseSize = calldata_1.calldataSize(baseDefinition, info.referenceDeclarations, info.calldataAllocations)[0];
                return yield Promise.all(lodash_range_1.default(length).map((index) => decodeCalldata(baseDefinition, { calldata: {
                        start: pointer.calldata.start + index * baseSize,
                        length: baseSize
                    } }, info) //static case so don't need base
                ));
            case "struct":
                return yield decodeCalldataStructByPosition(definition, pointer.calldata.start, info);
            default:
                // debug("Unknown calldata reference type: %s", DecodeUtils.typeIdentifier(definition));
                return undefined;
        }
    });
}
exports.decodeCalldataReferenceStatic = decodeCalldataReferenceStatic;
//note that this function takes the start position as a *number*; it does not take a calldata pointer
function decodeCalldataStructByPosition(definition, startPosition, info) {
    return __awaiter(this, void 0, void 0, function* () {
        const { state, referenceDeclarations, calldataAllocations } = info;
        const referencedDeclaration = definition.typeName
            ? definition.typeName.referencedDeclaration
            : definition.referencedDeclaration;
        const structAllocation = calldataAllocations[referencedDeclaration];
        if (structAllocation == null) {
            return undefined; //this should never happen
        }
        const decodeAllocation = (memberAllocation) => __awaiter(this, void 0, void 0, function* () {
            const memberPointer = memberAllocation.pointer;
            const childPointer = {
                calldata: {
                    start: startPosition + memberPointer.calldata.start,
                    length: memberPointer.calldata.length
                }
            };
            let memberDefinition = memberAllocation.definition;
            // replace erroneous `_storage` type identifiers with `_calldata`
            memberDefinition = DecodeUtils.Definition.spliceLocation(memberDefinition, "calldata");
            //there also used to be code here to add on the "_ptr" ending when absent, but we
            //presently ignore that ending, so we'll skip that
            let decoded = yield decodeCalldata(memberDefinition, childPointer, info, startPosition);
            //note that if we are in the static case, then the last parameter is irrelevant,
            //but we pass it anyway for simplicity
            return {
                [memberDefinition.name]: decoded
            };
        });
        const decodings = Object.values(structAllocation.members).map(decodeAllocation);
        return Object.assign({}, ...yield Promise.all(decodings));
    });
}
//# sourceMappingURL=calldata.js.map