"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const debug = debug_1.default("decoder:decode:stack");
const DecodeUtils = __importStar(require("truffle-decode-utils"));
const read_1 = __importDefault(require("../read"));
const value_1 = __importDefault(require("./value"));
const memory_1 = require("./memory");
const storage_1 = require("./storage");
const calldata_1 = require("./calldata");
function decodeStack(definition, pointer, info, web3, contractAddress) {
    return __awaiter(this, void 0, void 0, function* () {
        const rawValue = yield read_1.default(pointer, info.state, web3, contractAddress);
        const literalPointer = { literal: rawValue };
        return yield decodeLiteral(definition, literalPointer, info, web3, contractAddress);
    });
}
exports.decodeStack = decodeStack;
function decodeLiteral(definition, pointer, info, web3, contractAddress) {
    return __awaiter(this, void 0, void 0, function* () {
        debug("definition %O", definition);
        debug("pointer %o", pointer);
        //first: do we have a memory pointer? if so we can just dispatch to
        //decodeMemoryReference, which knows how to decode the pointer already
        if (DecodeUtils.Definition.isReference(definition)
            && DecodeUtils.Definition.referenceType(definition) === "memory") {
            return yield memory_1.decodeMemoryReferenceByAddress(definition, pointer, info);
        }
        //next: do we have a storage pointer (which may be a mapping)? if so, we can
        //we dispatch to decodeStorageByAddress, a new function that will decode the
        //pointer and then dispatch to decodeStorageReference
        if ((DecodeUtils.Definition.isReference(definition)
            && DecodeUtils.Definition.referenceType(definition) === "storage")
            || DecodeUtils.Definition.isMapping(definition)) {
            return yield storage_1.decodeStorageReferenceByAddress(definition, pointer, info, web3, contractAddress);
        }
        //next: do we have a calldata pointer?
        if (DecodeUtils.Definition.isReference(definition)
            && DecodeUtils.Definition.referenceType(definition) === "calldata") {
            //if it's a string or bytes, we will interpret the pointer ourself and skip
            //straight to decodeValue.  this is to allow us to correctly handle the
            //case of msg.data used as a mapping key.
            if (DecodeUtils.Definition.typeClass(definition) === "string" ||
                DecodeUtils.Definition.typeClass(definition) === "bytes") {
                let start = DecodeUtils.Conversion.toBN(pointer.literal.slice(0, DecodeUtils.EVM.WORD_SIZE)).toNumber();
                let length = DecodeUtils.Conversion.toBN(pointer.literal.slice(DecodeUtils.EVM.WORD_SIZE)).toNumber();
                let newPointer = { calldata: { start, length } };
                return yield value_1.default(definition, newPointer, info);
            }
            //otherwise, is it a dynamic array?
            if (DecodeUtils.Definition.isDynamicArray(definition)) {
                //in this case, we're actually going to *throw away* the length info,
                //because it makes the logic simpler -- we'll get the length info back
                //from calldata
                let locationOnly = pointer.literal.slice(0, DecodeUtils.EVM.WORD_SIZE);
                //HACK -- in order to read the correct location, we need to add an offset
                //of -32 (since, again, we're throwing away the length info), so we pass
                //that in as the "base" value
                return yield calldata_1.decodeCalldataReferenceByAddress(definition, { literal: locationOnly }, info, -DecodeUtils.EVM.WORD_SIZE);
            }
            else {
                //multivalue case -- this case is straightforward
                //pass in 0 as the base since this is an absolute pointer
                return yield calldata_1.decodeCalldataReferenceByAddress(definition, pointer, info, 0);
            }
        }
        //next: do we have an external function?  these work differently on the stack
        //than elsewhere, so we can't just pass it on to decodeValue.  However, we
        //don't yet support this case, so let's just move on
        //finally, if none of the above hold, we can just dispatch to decodeValue.
        //note we don't need web3 and contract address at this point
        return yield value_1.default(definition, pointer, info);
    });
}
exports.decodeLiteral = decodeLiteral;
//# sourceMappingURL=stack.js.map