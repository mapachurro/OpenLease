"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const debug = debug_1.default("decoder:decode:memory");
const read_1 = __importDefault(require("../read"));
const DecodeUtils = __importStar(require("truffle-decode-utils"));
const value_1 = __importDefault(require("./value"));
const lodash_range_1 = __importDefault(require("lodash.range"));
function decodeMemory(definition, pointer, info) {
    return __awaiter(this, void 0, void 0, function* () {
        if (DecodeUtils.Definition.isReference(definition)) {
            return yield decodeMemoryReferenceByAddress(definition, pointer, info);
        }
        else {
            return yield value_1.default(definition, pointer, info);
        }
    });
}
exports.default = decodeMemory;
function decodeMemoryReferenceByAddress(definition, pointer, info) {
    return __awaiter(this, void 0, void 0, function* () {
        const { state } = info;
        // debug("pointer %o", pointer);
        let rawValue = yield read_1.default(pointer, state);
        let startPosition = DecodeUtils.Conversion.toBN(rawValue).toNumber();
        let length;
        switch (DecodeUtils.Definition.typeClass(definition)) {
            case "bytes":
            case "string":
                length = DecodeUtils.Conversion.toBN(yield read_1.default({
                    memory: { start: startPosition, length: DecodeUtils.EVM.WORD_SIZE }
                }, state)).toNumber(); //initial word contains length
                let childPointer = {
                    memory: { start: startPosition + DecodeUtils.EVM.WORD_SIZE, length }
                };
                return yield value_1.default(definition, childPointer, info);
            case "array":
                if (DecodeUtils.Definition.isDynamicArray(definition)) {
                    length = DecodeUtils.Conversion.toBN(yield read_1.default({
                        memory: { start: startPosition, length: DecodeUtils.EVM.WORD_SIZE },
                    }, state)).toNumber(); // initial word contains array length
                    startPosition += DecodeUtils.EVM.WORD_SIZE; //increment startPosition to
                    //next word, as first word was used for length
                }
                else {
                    length = DecodeUtils.Definition.staticLength(definition);
                }
                let baseDefinition = definition.baseType || definition.typeName.baseType;
                //I'm deliberately not using the DecodeUtils function for this, because
                //we should *not* need a faked-up type here!
                // replace erroneous `_storage_` type identifiers with `_memory_`
                baseDefinition = DecodeUtils.Definition.spliceLocation(baseDefinition, "memory");
                return yield Promise.all(lodash_range_1.default(length).map((index) => decodeMemory(baseDefinition, { memory: {
                        start: startPosition + index * DecodeUtils.EVM.WORD_SIZE,
                        length: DecodeUtils.EVM.WORD_SIZE
                    } }, info)));
            case "struct":
                const { referenceDeclarations, memoryAllocations } = info;
                const referencedDeclaration = definition.typeName
                    ? definition.typeName.referencedDeclaration
                    : definition.referencedDeclaration;
                const structAllocation = memoryAllocations[referencedDeclaration];
                debug("structAllocation %O", structAllocation);
                const decodeAllocation = (memberAllocation) => __awaiter(this, void 0, void 0, function* () {
                    const memberPointer = memberAllocation.pointer;
                    const childPointer = {
                        memory: {
                            start: startPosition + memberPointer.memory.start,
                            length: memberPointer.memory.length //always equals WORD_SIZE
                        }
                    };
                    let memberDefinition = memberAllocation.definition;
                    // replace erroneous `_storage` type identifiers with `_memory`
                    memberDefinition = DecodeUtils.Definition.spliceLocation(memberDefinition, "memory");
                    //there also used to be code here to add on the "_ptr" ending when absent, but we
                    //presently ignore that ending, so we'll skip that
                    let decoded = yield decodeMemory(memberDefinition, childPointer, info);
                    return {
                        [memberDefinition.name]: decoded
                    };
                });
                const decodings = Object.values(structAllocation.members).map(decodeAllocation);
                return Object.assign({}, ...yield Promise.all(decodings));
            default:
                // debug("Unknown memory reference type: %s", DecodeUtils.typeIdentifier(definition));
                return undefined;
        }
    });
}
exports.decodeMemoryReferenceByAddress = decodeMemoryReferenceByAddress;
//# sourceMappingURL=memory.js.map