"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const debug = debug_1.default("decoder:interface:contract-decoder");
const async_eventemitter_1 = __importDefault(require("async-eventemitter"));
const web3_1 = __importDefault(require("web3"));
const bn_js_1 = __importDefault(require("bn.js"));
const general = __importStar(require("../allocate/general"));
const storage = __importStar(require("../allocate/storage"));
const pointer_1 = require("../types/pointer");
const storage_1 = require("../types/storage");
const decode_1 = __importDefault(require("../decode"));
const truffle_decode_utils_1 = require("truffle-decode-utils");
const abi_decoder_1 = __importDefault(require("abi-decoder"));
const lodash_isequal_1 = __importDefault(require("lodash.isequal")); //util.isDeepStrictEqual doesn't exist in Node 8
;
;
;
;
;
;
;
//note: may return undefined
function getContractNode(contract) {
    return (contract.ast || { nodes: [] }).nodes.find((contractNode) => contractNode.nodeType === "ContractDefinition"
        && (contractNode.name === contract.contractName
            || contractNode.name === contract.contract_name));
}
class TruffleContractDecoder extends async_eventemitter_1.default {
    constructor(contract, relevantContracts, provider, address) {
        super();
        this.contracts = {};
        this.contractNodes = {};
        this.mappingKeys = [];
        this.web3 = new web3_1.default(provider);
        this.contract = contract;
        this.relevantContracts = relevantContracts;
        this.contractNetwork = Object.keys(this.contract.networks)[0];
        this.contractAddress = address !== undefined
            ? address
            : this.contract.networks[this.contractNetwork].address;
        this.contractNode = getContractNode(this.contract);
        this.contracts[this.contractNode.id] = this.contract;
        this.contractNodes[this.contractNode.id] = this.contractNode;
        abi_decoder_1.default.addABI(this.contract.abi);
        this.relevantContracts.forEach((relevantContract) => {
            let node = getContractNode(relevantContract);
            if (node !== undefined) {
                this.contracts[node.id] = relevantContract;
                this.contractNodes[node.id] = node;
                abi_decoder_1.default.addABI(relevantContract.abi);
            }
        });
    }
    init() {
        debug("init called");
        this.referenceDeclarations = general.getReferenceDeclarations(Object.values(this.contractNodes));
        this.eventDefinitions = general.getEventDefinitions(Object.values(this.contractNodes));
        this.eventDefinitionIdsByName = {};
        for (let id in this.eventDefinitions) {
            this.eventDefinitionIdsByName[this.eventDefinitions[id].name] = parseInt(id);
            //this parseInt shouldn't be necessary, but TypeScript refuses to believe
            //that id must be a number even though the definition of AstReferences
            //says so
        }
        debug("done with event definitions");
        this.storageAllocations = storage.getStorageAllocations(this.referenceDeclarations, { [this.contractNode.id]: this.contractNode });
        debug("done with allocation");
        this.stateVariableReferences = this.storageAllocations[this.contractNode.id].members;
        debug("stateVariableReferences %O", this.stateVariableReferences);
    }
    state(block = "latest") {
        return __awaiter(this, void 0, void 0, function* () {
            let result = {
                name: this.contract.contractName,
                balance: new bn_js_1.default(yield this.web3.eth.getBalance(this.contractAddress)),
                variables: {}
            };
            debug("state called");
            for (const variable of Object.values(this.stateVariableReferences)) {
                const info = {
                    state: {
                        stack: [],
                        storage: {},
                        memory: new Uint8Array(0)
                    },
                    mappingKeys: this.mappingKeys,
                    referenceDeclarations: this.referenceDeclarations,
                    storageAllocations: this.storageAllocations,
                };
                debug("about to decode %s", variable.definition.name);
                const val = yield decode_1.default(variable.definition, variable.pointer, info, this.web3, this.contractAddress);
                debug("decoded");
                result.variables[variable.definition.name] = {
                    name: variable.definition.name,
                    type: truffle_decode_utils_1.Definition.typeClass(variable.definition),
                    value: val
                };
                debug("var %O", result.variables[variable.definition.name]);
            }
            return result;
        });
    }
    variable(nameOrId, block = "latest") {
        return __awaiter(this, void 0, void 0, function* () {
            const info = {
                state: {
                    stack: [],
                    storage: {},
                    memory: new Uint8Array(0)
                },
                mappingKeys: this.mappingKeys,
                referenceDeclarations: this.referenceDeclarations,
                storageAllocations: this.storageAllocations,
            };
            let variable;
            if (typeof nameOrId === "number") {
                variable = this.stateVariableReferences[nameOrId];
            }
            else { //search by name
                variable = Object.values(this.stateVariableReferences)
                    .find(({ definition }) => definition.name === nameOrId); //there should be exactly one
            }
            if (variable === undefined) { //if user put in a bad name
                return undefined;
            }
            debug("about to decode %o", nameOrId);
            const value = yield decode_1.default(variable.definition, variable.pointer, info, this.web3, this.contractAddress);
            debug("decoded");
            return {
                name: variable.definition.name,
                type: truffle_decode_utils_1.Definition.typeClass(variable.definition),
                value
            };
        });
    }
    //EXAMPLE: to watch a.b.c[d][e], use watchMappingKey("a", "b", "c", d, e)
    //(this will watch all ancestors too, or at least ones given by mapping keys)
    //feel free to mix arrays, mappings, and structs here!
    //see the comment on constructSlot for more detail on what forms are accepted
    watchMappingKey(variable, ...indices) {
        let slot = this.constructSlot(variable, ...indices)[0];
        //add mapping key and all ancestors
        while (slot !== undefined &&
            this.mappingKeys.every(existingSlot => !lodash_isequal_1.default(existingSlot, slot)
            //we put the newness requirement in the while condition rather than a
            //separate if because if we hit one ancestor that's not new, the futher
            //ones won't be either
            )) {
            if (slot.key !== undefined) { //only add mapping keys
                this.mappingKeys = [...this.mappingKeys, slot];
            }
            slot = slot.path;
        }
    }
    //input is similar to watchMappingKey; will unwatch all descendants too
    unwatchMappingKey(variable, ...indices) {
        let slot = this.constructSlot(variable, ...indices)[0];
        if (slot === undefined) {
            return; //not strictly necessary, but may as well
        }
        //remove mapping key and all descendants
        this.mappingKeys = this.mappingKeys.filter(existingSlot => {
            while (existingSlot !== undefined) {
                if (lodash_isequal_1.default(existingSlot, slot)) {
                    return false; //if it matches, remove it
                }
                existingSlot = existingSlot.path;
            }
            return true; //if we didn't match, keep the key
        });
    }
    //NOTE: if you decide to add a way to remove a mapping key *without* removing
    //all descendants, you'll need to alter watchMappingKey to use an if rather
    //than a while
    decodeTransaction(transaction) {
        const decodedData = abi_decoder_1.default.decodeMethod(transaction.input);
        return decodedData;
    }
    decodeLog(log) {
        const decodedLogs = this.decodeLogs([log]);
        return decodedLogs[0];
    }
    decodeLogs(logs) {
        const decodedLogs = abi_decoder_1.default.decodeLogs(logs);
        return decodedLogs;
    }
    decodeEvent(event) {
        let contractEvent = {
            logIndex: event.logIndex,
            name: event.event,
            blockHash: event.blockHash,
            blockNumber: event.blockNumber,
            transactionHash: event.transactionHash,
            transactionIndex: event.transactionIndex,
            variables: {}
        };
        const eventDefinition = this.eventDefinitions[this.eventDefinitionIdsByName[contractEvent.name]];
        if (typeof eventDefinition.parameters !== "undefined" && typeof eventDefinition.parameters.parameters !== "undefined") {
            const argumentDefinitions = eventDefinition.parameters.parameters;
            for (let i = 0; i < argumentDefinitions.length; i++) {
                const definition = argumentDefinitions[i];
                if (definition.nodeType === "VariableDeclaration") {
                    contractEvent.variables[definition.name] = {
                        name: definition.name,
                        type: truffle_decode_utils_1.Definition.typeClass(definition),
                        value: event.returnValues[definition.name] // TODO: this should be a decoded value, it currently is a string always
                    };
                }
            }
        }
        return contractEvent;
    }
    events(name = null, block = "latest") {
        return __awaiter(this, void 0, void 0, function* () {
            const web3Contract = new this.web3.eth.Contract(this.contract.abi, this.contractAddress);
            const events = yield web3Contract.getPastEvents(name, {
                fromBlock: block,
                toBlock: block
            });
            let contractEvents = [];
            for (let i = 0; i < events.length; i++) {
                contractEvents.push(this.decodeEvent(events[i]));
            }
            return contractEvents;
        });
    }
    onEvent(name, callback) {
        //this.web3.eth.subscribe(name);
    }
    removeEventListener(name) {
    }
    //in addition to returning the slot we want, it also returns a definition
    //used in the recursive call
    //HOW TO USE:
    //variable may be either a variable id (number) or name (string)
    //struct members may be given either by id (number) or name (string)
    //array indices and numeric mapping keys may be BN, number, or numeric string
    //string mapping keys should be given as strings. duh.
    //bytes mapping keys should be given as hex strings beginning with "0x"
    //address mapping keys are like bytes; checksum case is not required
    //boolean mapping keys may be given either as booleans, or as string "true" or "false"
    constructSlot(variable, ...indices) {
        //base case: we need to locate the variable and its definition
        if (indices.length === 0) {
            let allocation;
            if (typeof variable === "number") {
                allocation = this.stateVariableReferences[variable];
            }
            else {
                allocation = Object.values(this.stateVariableReferences)
                    .find(({ definition }) => definition.name === variable);
            }
            let definition = allocation.definition;
            let pointer = allocation.pointer;
            if (!pointer_1.isStoragePointer(pointer)) { //if it's a constant
                return [undefined, undefined];
            }
            return [pointer.storage.from.slot, definition];
        }
        //main case
        let parentIndices = indices.slice(0, -1); //remove last index
        let [parentSlot, parentDefinition] = this.constructSlot(variable, ...parentIndices);
        if (parentSlot === undefined) {
            return [undefined, undefined];
        }
        let rawIndex = indices[indices.length - 1];
        let index;
        let slot;
        let definition;
        switch (truffle_decode_utils_1.Definition.typeClass(parentDefinition)) {
            case "array":
                if (rawIndex instanceof bn_js_1.default) {
                    index = rawIndex.clone();
                }
                else {
                    index = new bn_js_1.default(rawIndex);
                }
                definition = parentDefinition.baseType || parentDefinition.typeName.baseType;
                let size = storage.storageSize(definition, this.referenceDeclarations, this.storageAllocations);
                if (!storage_1.isWordsLength(size)) {
                    return [undefined, undefined];
                }
                slot = {
                    path: parentSlot,
                    offset: index.muln(size.words),
                    hashPath: truffle_decode_utils_1.Definition.isDynamicArray(parentDefinition)
                };
                break;
            case "mapping":
                let keyDefinition = parentDefinition.keyType || parentDefinition.typeName.keyType;
                switch (truffle_decode_utils_1.Definition.typeClass(keyDefinition)) {
                    case "string":
                    case "bytes":
                        index = rawIndex;
                        break;
                    case "address":
                        index = web3_1.default.utils.toChecksumAddress(rawIndex);
                        break;
                    case "int":
                    case "uint":
                        if (rawIndex instanceof bn_js_1.default) {
                            index = rawIndex.clone();
                        }
                        else {
                            index = new bn_js_1.default(rawIndex);
                        }
                        break;
                    case "bool":
                        if (typeof rawIndex === "string") {
                            index = rawIndex !== "false";
                        }
                        else {
                            index = rawIndex;
                        }
                        break;
                    default: //there is no other case, except fixed and ufixed, but
                        return [undefined, undefined];
                }
                definition = parentDefinition.valueType || parentDefinition.typeName.valueType;
                slot = {
                    path: parentSlot,
                    key: index,
                    keyEncoding: truffle_decode_utils_1.Definition.keyEncoding(keyDefinition),
                    offset: new bn_js_1.default(0)
                };
                break;
            case "struct":
                let parentId = truffle_decode_utils_1.Definition.typeId(parentDefinition);
                let allocation;
                if (typeof rawIndex === "number") {
                    index = rawIndex;
                    allocation = this.storageAllocations[parentId].members[index];
                    definition = allocation.definition;
                }
                else {
                    allocation = Object.values(this.storageAllocations[parentId].members)
                        .find(({ definition }) => definition.name === rawIndex); //there should be exactly one
                    definition = allocation.definition;
                    index = definition.id; //not really necessary, but may as well
                }
                slot = {
                    path: parentSlot,
                    //need type coercion here -- we know structs don't contain constants but the compiler doesn't
                    offset: allocation.pointer.storage.from.slot.offset.clone()
                };
                break;
            default:
                return [undefined, undefined];
        }
        return [slot, definition];
    }
}
exports.default = TruffleContractDecoder;
//# sourceMappingURL=contract-decoder.js.map