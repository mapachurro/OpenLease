"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const debug = debug_1.default("decoder:read:storage");
const DecodeUtils = __importStar(require("truffle-decode-utils"));
const bn_js_1 = __importDefault(require("bn.js"));
/**
 * convert a slot to a word corresponding to actual storage address
 *
 * if `slot` is an array, return hash of array values.
 * if `slot` array is nested, recurse on sub-arrays
 *
 * @param slot - number or possibly-nested array of numbers
 */
function slotAddress(slot) {
    if (slot.key !== undefined && slot.path !== undefined) {
        // mapping reference
        let key = slot.key;
        let keyEncoding = slot.keyEncoding;
        if (keyEncoding === undefined) { //HACK: booleans must be handled manually
            key = key ? new bn_js_1.default(1) : new bn_js_1.default(0);
            keyEncoding = "uint";
        }
        return DecodeUtils.EVM.keccak256({ type: keyEncoding, value: key }, slotAddress(slot.path)).add(slot.offset);
    }
    else if (slot.path !== undefined) {
        const pathAddress = slotAddress(slot.path);
        const path = slot.hashPath ? DecodeUtils.EVM.keccak256(pathAddress) : pathAddress;
        return path.add(slot.offset);
    }
    else {
        return slot.offset;
    }
}
exports.slotAddress = slotAddress;
function slotAddressPrintout(slot) {
    if (slot.key !== undefined && slot.path !== undefined) {
        // mapping reference
        let keyEncoding = slot.keyEncoding ? slot.keyEncoding : "uint"; //HACK for booleans
        return "keccak(" + slot.key + " as " + keyEncoding + ", " + slotAddressPrintout(slot.path) + ") + " + slot.offset.toString();
    }
    else if (slot.path !== undefined) {
        const pathAddressPrintout = slotAddressPrintout(slot.path);
        return slot.hashPath
            ? "keccak(" + pathAddressPrintout + ")" + slot.offset.toString()
            : pathAddressPrintout + slot.offset.toString();
    }
    else {
        return slot.offset.toString();
    }
}
exports.slotAddressPrintout = slotAddressPrintout;
/**
 * read slot from storage
 *
 * @param slot - see slotAddress() code to understand how these work
 * @param offset - for array, offset from the keccak determined location
 */
function read(storage, slot, web3, contractAddress) {
    return __awaiter(this, void 0, void 0, function* () {
        debug("Slot printout: %s", slotAddressPrintout(slot));
        const address = slotAddress(slot);
        // debug("reading slot: %o", DecodeUtils.toHexString(address));
        const hexAddress = DecodeUtils.Conversion.toHexString(address, DecodeUtils.EVM.WORD_SIZE);
        let word = storage[hexAddress];
        if (word === undefined && web3 && contractAddress) {
            // fallback
            word = DecodeUtils.Conversion.toBytes(yield web3.eth.getStorageAt(contractAddress, address), DecodeUtils.EVM.WORD_SIZE);
        }
        //if not found, it's 0
        //NOTE: really this shouldn't be a fallback like this but rather inside the above cases;
        //however that would require a reorganization, it'll wait for fullState/contextSelector
        if (word === undefined) {
            word = new Uint8Array(DecodeUtils.EVM.WORD_SIZE);
            word.fill(0);
        }
        // debug("word %o", word);
        return word;
    });
}
exports.read = read;
/**
 * read all bytes in some range.
 *
 * parameters `from` and `to` are objects with the following properties:
 *
 *   slot - see the slotAddress() code to understand how these work
 *
 *     ref: https://solidity.readthedocs.io/en/v0.4.23/miscellaneous.html#layout-of-state-variables-in-storage
 *     (search "concatenation")
 *
 *  index - (default: 0) byte index in word
 *
 * @param from - location (see ^)
 * @param to - location (see ^). inclusive.
 * @param length - instead of `to`, number of bytes after `from`
 */
function readRange(storage, range, web3, contractAddress) {
    return __awaiter(this, void 0, void 0, function* () {
        // debug("readRange %o", range);
        let { from, to, length } = range;
        if (typeof length === "undefined" && !to || length && to) {
            throw new Error("must specify exactly one `to`|`length`");
        }
        from = {
            slot: from.slot,
            index: from.index || 0
        };
        if (typeof length !== "undefined") {
            to = {
                slot: {
                    path: from.slot.path || undefined,
                    offset: from.slot.offset.addn(Math.floor((from.index + length - 1) / DecodeUtils.EVM.WORD_SIZE))
                },
                index: (from.index + length - 1) % DecodeUtils.EVM.WORD_SIZE
            };
        }
        else {
            to = {
                slot: to.slot,
                index: to.index
            };
        }
        // debug("normalized readRange %o", {from,to});
        let totalWords = to.slot.offset.sub(from.slot.offset).addn(1);
        if (totalWords.bitLength() > 53) {
            throw new Error("must specify range that is less than 53 bits");
        }
        totalWords = totalWords.toNumber();
        // debug("totalWords %o", totalWords);
        let data = new Uint8Array(totalWords * DecodeUtils.EVM.WORD_SIZE);
        for (let i = 0; i < totalWords; i++) {
            let offset = from.slot.offset.addn(i);
            const word = yield read(storage, Object.assign({}, from.slot, { offset }), web3, contractAddress);
            if (typeof word !== "undefined") {
                data.set(word, i * DecodeUtils.EVM.WORD_SIZE);
            }
        }
        // debug("words %o", data);
        data = data.slice(from.index, (totalWords - 1) * DecodeUtils.EVM.WORD_SIZE + to.index + 1);
        // debug("data: %o", data);
        return data;
    });
}
exports.readRange = readRange;
//# sourceMappingURL=storage.js.map