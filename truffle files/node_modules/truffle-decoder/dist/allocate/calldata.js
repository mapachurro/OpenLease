"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const debug = debug_1.default("decoder:allocate:calldata");
const DecodeUtils = __importStar(require("truffle-decode-utils"));
function getCalldataAllocations(referenceDeclarations) {
    let allocations = {};
    for (const node of Object.values(referenceDeclarations)) {
        if (node.nodeType === "StructDefinition") {
            allocations = allocateStruct(node, referenceDeclarations, allocations);
        }
    }
    return allocations;
}
exports.getCalldataAllocations = getCalldataAllocations;
//note: we will still allocate circular structs, even though they're not allowed in calldata, because it's
//not worth the effort to detect them.  However on mappings or internal functions, we'll vomit (allocate null)
function allocateStruct(definition, referenceDeclarations, existingAllocations) {
    let start = 0;
    let dynamic = false;
    //don't allocate things that have already been allocated
    if (definition.id in existingAllocations) {
        return existingAllocations;
    }
    let allocations = Object.assign({}, existingAllocations); //otherwise, we'll be adding to this, so we better clone
    let memberAllocations = {};
    for (const member of definition.members) {
        let length;
        let dynamicMember;
        [length, dynamicMember, allocations] = calldataSizeAndAllocate(member, referenceDeclarations, allocations);
        //vomit on illegal types in calldata -- note the short-circuit!
        if (length === undefined) {
            allocations[definition.id] = null;
            return allocations;
        }
        let pointer = {
            calldata: {
                start,
                length
            }
        };
        memberAllocations[member.id] = {
            definition: member,
            pointer
        };
        start += length;
        dynamic = dynamic || dynamicMember;
    }
    allocations[definition.id] = {
        definition,
        members: memberAllocations,
        length: dynamic ? DecodeUtils.EVM.WORD_SIZE : start,
        dynamic
    };
    return allocations;
}
//NOTE: This wrapper function is for use by the decoder ONLY, after allocation is done.
//The allocator should (and does) instead use a direct call to storageSizeAndAllocate,
//not to the wrapper, because it may need the allocations returned.
//the first return value is the length (in bytes); the second is whether the type is dynamic
function calldataSize(definition, referenceDeclarations, allocations) {
    let [size, dynamic] = calldataSizeAndAllocate(definition, referenceDeclarations, allocations); //throw away allocations
    return [size, dynamic];
}
exports.calldataSize = calldataSize;
//first return value is the actual size.
//second return value is whether the type is dynamic
//both will be undefined if type is a mapping or internal function
//third return value is resulting allocations, INCLUDING the ones passed in
function calldataSizeAndAllocate(definition, referenceDeclarations, existingAllocations) {
    switch (DecodeUtils.Definition.typeClass(definition)) {
        case "bool":
        case "address":
        case "contract":
        case "int":
        case "uint":
        case "fixed":
        case "ufixed":
        case "enum":
            return [DecodeUtils.EVM.WORD_SIZE, false, existingAllocations];
        case "string":
            return [DecodeUtils.EVM.WORD_SIZE, true, existingAllocations];
        case "bytes":
            return [DecodeUtils.EVM.WORD_SIZE, DecodeUtils.Definition.specifiedSize(definition) == null,
                existingAllocations];
        case "mapping":
            return [undefined, undefined, existingAllocations];
        case "function":
            switch (DecodeUtils.Definition.visibility(definition)) {
                case "external":
                    return [DecodeUtils.EVM.WORD_SIZE, false, existingAllocations];
                case "internal":
                    return [undefined, undefined, existingAllocations];
            }
        case "array": {
            if (DecodeUtils.Definition.isDynamicArray(definition)) {
                return [DecodeUtils.EVM.WORD_SIZE, true, existingAllocations];
            }
            else {
                //static array case
                const length = DecodeUtils.Definition.staticLength(definition);
                const baseDefinition = definition.baseType || definition.typeName.baseType;
                const [baseSize, dynamic, allocations] = calldataSizeAndAllocate(baseDefinition, referenceDeclarations, existingAllocations);
                return [length * baseSize, dynamic, allocations];
            }
        }
        case "struct": {
            const referenceId = DecodeUtils.Definition.typeId(definition);
            let allocations = existingAllocations;
            let allocation = allocations[referenceId];
            if (allocation === undefined) {
                //if we don't find an allocation, we'll have to do the allocation ourselves
                const referenceDeclaration = referenceDeclarations[referenceId];
                allocations = allocateStruct(referenceDeclaration, referenceDeclarations, existingAllocations);
                allocation = allocations[referenceId];
            }
            //having found our allocation, if it's not null, we can just look up its size and dynamicity
            if (allocation !== null) {
                return [allocation.length, allocation.dynamic, allocations];
            }
            //if it is null, this type doesn't go in calldata
            else {
                return [undefined, undefined, allocations];
            }
        }
    }
}
//# sourceMappingURL=calldata.js.map