"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const contract_decoder_1 = require("../interface/contract-decoder");
const lodash_merge_1 = __importDefault(require("lodash.merge"));
const lodash_clonedeep_1 = __importDefault(require("lodash.clonedeep"));
const DecodeUtils = __importStar(require("truffle-decode-utils"));
const bn_js_1 = __importDefault(require("bn.js"));
;
function getDeclarationsForTypes(contracts, types) {
    let result = {};
    for (let i = 0; i < contracts.length; i++) {
        const contract = contracts[i];
        const contractNode = contract_decoder_1.getContractNode(contract);
        if (contractNode) {
            for (let k = 0; k < contractNode.nodes.length; k++) {
                const node = contractNode.nodes[k];
                if (types.indexOf(node.nodeType) >= 0) {
                    result[node.id] = node;
                }
            }
        }
    }
    return result;
}
function getReferenceDeclarations(contracts) {
    let result = {};
    const types = [
        "EnumDefinition",
        "StructDefinition"
    ];
    const referenceDeclarations = getDeclarationsForTypes(contracts, types);
    Object.entries(referenceDeclarations).forEach((entry) => {
        const id = parseInt(entry[0]);
        const definition = entry[1];
        result[id] = {
            definition: definition,
            isChildVariable: false
        };
        switch (definition.nodeType) {
            case "EnumDefinition": {
                // do nothing, doesn't need a pointer
                break;
            }
            case "StructDefinition": {
                const stateInfo = allocateStruct(definition, referenceDeclarations, {
                    offset: new bn_js_1.default(0)
                });
                result[id].members = stateInfo.variables;
            }
        }
    });
    return [referenceDeclarations, result];
}
exports.getReferenceDeclarations = getReferenceDeclarations;
function getEventDefinitions(contracts) {
    const types = [
        "EventDefinition"
    ];
    return getDeclarationsForTypes(contracts, types);
}
exports.getEventDefinitions = getEventDefinitions;
function allocateStruct(structDefinition, referenceDeclarations, slot, isChildVariable = false) {
    let structSlotAllocation = {
        offset: new bn_js_1.default(0),
        index: DecodeUtils.EVM.WORD_SIZE - 1
    };
    let structContractState = {
        variables: {},
        slot: structSlotAllocation
    };
    if (structDefinition) {
        for (let l = 0; l < structDefinition.members.length; l++) {
            const memberNode = structDefinition.members[l];
            allocateDefinition(memberNode, structContractState, referenceDeclarations, slot, true);
        }
    }
    return structContractState;
}
function allocateDefinition(node, state, referenceDeclarations, path, isChildVariable = false) {
    let slot = {
        offset: state.slot.offset.clone()
    };
    if (typeof path !== "undefined") {
        slot.path = lodash_clonedeep_1.default(path);
    }
    const nodeTypeClass = DecodeUtils.Definition.typeClass(node);
    if (DecodeUtils.Definition.requireStartOfSlot(node) && state.slot.index < DecodeUtils.EVM.WORD_SIZE - 1) {
        // structs, mappings, and arrays need to start on their own slot
        state.slot.index = DecodeUtils.EVM.WORD_SIZE - 1;
        state.slot.offset = state.slot.offset.addn(1);
        slot.offset = slot.offset.addn(1);
    }
    if (nodeTypeClass != "struct") {
        let referenceDeclaration = undefined;
        if (nodeTypeClass === "enum") {
            const referenceId = node.referencedDeclaration ||
                (node.typeName ? node.typeName.referencedDeclaration : undefined);
            referenceDeclaration = referenceDeclarations[referenceId];
        }
        const storageSize = DecodeUtils.Definition.storageSize(node, referenceDeclaration);
        let range = DecodeUtils.Allocation.allocateValue(slot, state.slot.index, storageSize);
        if (nodeTypeClass === "array" && !DecodeUtils.Definition.isDynamicArray(node)) {
            const length = parseInt(node.typeName.length.value);
            const baseDefinition = DecodeUtils.Definition.baseDefinition(node);
            if (DecodeUtils.Definition.typeClass(baseDefinition) === "struct") {
                const referenceId = baseDefinition.referencedDeclaration ||
                    (baseDefinition.typeName ? baseDefinition.typeName.referencedDeclaration : undefined);
                const structDefinition = referenceDeclarations[referenceId];
                const structContractState = allocateStruct(structDefinition, referenceDeclarations, {
                    path: slot,
                    offset: new bn_js_1.default(0)
                }, true);
                range.next.slot.offset = range.next.slot.offset.add(structContractState.slot.offset);
                if (structContractState.slot.index === DecodeUtils.EVM.WORD_SIZE - 1) {
                    range.next.slot.offset = range.next.slot.offset.subn(1);
                }
            }
            else {
                const baseDefinitionStorageSize = DecodeUtils.Definition.storageSize(baseDefinition);
                const totalAdditionalSlotsUsed = Math.ceil(length * baseDefinitionStorageSize / DecodeUtils.EVM.WORD_SIZE) - 1;
                range.next.slot.offset = range.next.slot.offset.addn(totalAdditionalSlotsUsed);
            }
        }
        state.variables[node.id] = {
            isChildVariable,
            definition: node,
            pointer: {
                storage: lodash_clonedeep_1.default(range)
            }
        };
        state.slot.offset = range.next.slot.offset.clone();
        state.slot.index = range.next.index;
    }
    else {
        const referenceId = node.referencedDeclaration || (node.typeName && node.typeName.referencedDeclaration);
        const structDefinition = referenceDeclarations[referenceId]; // ast node of StructDefinition
        const structContractState = allocateStruct(structDefinition, referenceDeclarations, slot);
        state.variables[node.id] = {
            isChildVariable,
            definition: node,
            pointer: {
                storage: {
                    from: {
                        slot: slot,
                        index: 0
                    },
                    to: {
                        slot: slot,
                        index: DecodeUtils.EVM.WORD_SIZE - 1
                    }
                }
            }
        };
        state.slot.offset = state.slot.offset.add(structContractState.slot.offset);
        state.slot.index = DecodeUtils.EVM.WORD_SIZE - 1;
        if (structContractState.slot.index < DecodeUtils.EVM.WORD_SIZE - 1) {
            state.slot.offset = state.slot.offset.addn(1);
        }
    }
}
exports.allocateDefinition = allocateDefinition;
function getStateVariables(contract, initialSlotInfo, referenceDeclarations) {
    let state = {
        variables: {},
        slot: {
            offset: initialSlotInfo.offset,
            index: initialSlotInfo.index
        }
    };
    // process for state variables
    const contractNode = contract_decoder_1.getContractNode(contract);
    for (let k = 0; k < contractNode.nodes.length; k++) {
        const node = contractNode.nodes[k];
        if (node.nodeType === "VariableDeclaration" && node.stateVariable === true) {
            allocateDefinition(node, state, referenceDeclarations);
        }
    }
    return state;
}
function getContractStateVariables(contract, contracts, referenceDeclarations) {
    let result = {};
    if (typeof contract.ast === "undefined") {
        return result;
    }
    const contractNode = contract_decoder_1.getContractNode(contract);
    if (contractNode) {
        // process inheritance
        let slotAllocation = {
            offset: new bn_js_1.default(0),
            index: DecodeUtils.EVM.WORD_SIZE - 1
        };
        for (let i = contractNode.linearizedBaseContracts.length - 1; i >= 0; i--) {
            const state = getStateVariables(contracts[contractNode.linearizedBaseContracts[i]], slotAllocation, referenceDeclarations);
            slotAllocation.offset = state.slot.offset;
            slotAllocation.index = state.slot.index;
            lodash_merge_1.default(result, state.variables);
        }
    }
    return result;
}
exports.getContractStateVariables = getContractStateVariables;
//# sourceMappingURL=references.js.map