(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("Debugger", [], factory);
	else if(typeof exports === 'object')
		exports["Debugger"] = factory();
	else
		root["Debugger"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 35);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("debug");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__(2);

var _extends3 = _interopRequireDefault(_extends2);

exports.isDeliberatelySkippedNodeType = isDeliberatelySkippedNodeType;
exports.isSkippedNodeType = isSkippedNodeType;
exports.prefixName = prefixName;
exports.extractPrimarySource = extractPrimarySource;
exports.keccak256 = keccak256;
exports.stableKeccak256 = stableKeccak256;
exports.makeAssignment = makeAssignment;
exports.isCallMnemonic = isCallMnemonic;
exports.isShortCallMnemonic = isShortCallMnemonic;
exports.isDelegateCallMnemonicBroad = isDelegateCallMnemonicBroad;
exports.isDelegateCallMnemonicStrict = isDelegateCallMnemonicStrict;
exports.isStaticCallMnemonic = isStaticCallMnemonic;
exports.isCreateMnemonic = isCreateMnemonic;
exports.isNormalHaltingMnemonic = isNormalHaltingMnemonic;

var _truffleDecodeUtils = __webpack_require__(4);

var utils = _interopRequireWildcard(_truffleDecodeUtils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const stringify = __webpack_require__(44);

/** AST node types that are skipped by stepNext() to filter out some noise */
function isDeliberatelySkippedNodeType(node) {
  const skippedTypes = ["ContractDefinition", "VariableDeclaration"];
  return skippedTypes.includes(node.nodeType);
}

//HACK
//these aren't the only types of skipped nodes, but determining all skipped
//nodes would be too difficult
function isSkippedNodeType(node) {
  const otherSkippedTypes = ["VariableDeclarationStatement", "Mapping"];
  return isDeliberatelySkippedNodeType(node) || otherSkippedTypes.includes(node.nodeType) || node.nodeType.includes("TypeName") || //HACK
  //skip string literals too -- we'll handle that manually
  node.typeDescriptions !== undefined && //seems this sometimes happens?
  utils.Definition.typeClass(node) === "stringliteral";
}

function prefixName(prefix, fn) {
  Object.defineProperty(fn, "name", {
    value: `${prefix}.${fn.name}`,
    configurable: true
  });

  return fn;
}

/*
 * extract the primary source from a source map
 * (i.e., the source for the first instruction, found
 * between the second and third colons)
 * (this is something of a HACK)
 */
function extractPrimarySource(sourceMap) {
  return parseInt(sourceMap.match(/^[^:]+:[^:]+:([^:]+):/)[1]);
}

/**
 * @return 0x-prefix string of keccak256 hash
 */
function keccak256(...args) {
  return utils.Conversion.toHexString(utils.EVM.keccak256(...args));
}

/**
 * Given an object, return a stable hash by first running it through a stable
 * stringify operation before hashing
 */
function stableKeccak256(obj) {
  return keccak256({ type: "string", value: stringify(obj) });
}

/*
 * used by data; takes an id object and a ref (pointer) and returns a full
 * corresponding assignment object
 */
function makeAssignment(idObj, ref) {
  let id = stableKeccak256(idObj);
  return (0, _extends3.default)({}, idObj, { id, ref });
}

/*
 * Given a mmemonic, determine whether it's the mnemonic of a calling
 * instruction (does NOT include creation instructions)
 */
function isCallMnemonic(op) {
  const calls = ["CALL", "DELEGATECALL", "STATICCALL", "CALLCODE"];
  return calls.includes(op);
}

/*
 * returns true for mnemonics for calls that take only 6 args instead of 7
 */
function isShortCallMnemonic(op) {
  const shortCalls = ["DELEGATECALL", "STATICCALL"];
  return shortCalls.includes(op);
}

/*
 * returns true for mnemonics for calls that delegate storage
 */
function isDelegateCallMnemonicBroad(op) {
  const delegateCalls = ["DELEGATECALL", "CALLCODE"];
  return delegateCalls.includes(op);
}

/*
 * returns true for mnemonics for calls that delegate everything
 */
function isDelegateCallMnemonicStrict(op) {
  const delegateCalls = ["DELEGATECALL"];
  return delegateCalls.includes(op);
}

/*
 * returns true for mnemonics for static calls
 */
function isStaticCallMnemonic(op) {
  const delegateCalls = ["STATICCALL"];
  return delegateCalls.includes(op);
}

/*
 * Given a mmemonic, determine whether it's the mnemonic of a creation
 * instruction
 */
function isCreateMnemonic(op) {
  const creates = ["CREATE", "CREATE2"];
  return creates.includes(op);
}

/*
 * Given a mmemonic, determine whether it's the mnemonic of a normal
 * halting instruction
 */
function isNormalHaltingMnemonic(op) {
  const halts = ["STOP", "RETURN", "SELFDESTRUCT", "SUICIDE"];
  //the mnemonic SUICIDE is no longer used, but just in case, I'm including it
  return halts.includes(op);
}

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/helpers/extends");

/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = require("reselect-tree");

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = require("truffle-decode-utils");

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = require("redux-saga/effects");

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/object/assign");

/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = require("redux");

/***/ }),
/* 8 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/object/entries");

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__(2);

var _extends3 = _interopRequireDefault(_extends2);

var _values = __webpack_require__(11);

var _values2 = _interopRequireDefault(_values);

var _assign = __webpack_require__(6);

var _assign2 = _interopRequireDefault(_assign);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(3);

var _bn = __webpack_require__(17);

var _bn2 = _interopRequireDefault(_bn);

var _selectors = __webpack_require__(12);

var _selectors2 = _interopRequireDefault(_selectors);

var _truffleDecodeUtils = __webpack_require__(4);

var DecodeUtils = _interopRequireWildcard(_truffleDecodeUtils);

var _helpers = __webpack_require__(1);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:evm:selectors"); // eslint-disable-line no-unused-vars

function matchContext({ binary, isConstructor }, givenBinary) {
  let lengthDifference = givenBinary.length - binary.length;
  //first: if it's not a constructor, they'd better be equal in length.
  //if it is a constructor, the given binary must be at least as long,
  //and the difference must be a multiple of 64
  if (!isConstructor && lengthDifference !== 0 || lengthDifference < 0 || lengthDifference % (2 * DecodeUtils.EVM.WORD_SIZE) !== 0) {
    return false;
  }
  for (let i = 0; i < binary.length; i++) {
    //note: using strings like arrays is kind of dangerous in general in JS,
    //but everything here is ASCII so it's fine
    //note that we need to compare case-insensitive, since Solidity will
    //put addresses in checksum case in the compiled source
    //(we don't actually need that second toLowerCase(), but whatever)
    if (binary[i] !== "." && binary[i].toLowerCase() !== givenBinary[i].toLowerCase()) {
      return false;
    }
  }
  return true;
}

/**
 * create EVM-level selectors for a given trace step selector
 * may specify additional selectors to include
 */
function createStepSelectors(step, state = null) {
  let base = {
    /**
     * .trace
     *
     * trace step info related to operation
     */
    trace: (0, _reselectTree.createLeaf)([step], ({ gasCost, op, pc }) => ({ gasCost, op, pc })),

    /**
     * .programCounter
     */
    programCounter: (0, _reselectTree.createLeaf)(["./trace"], step => step.pc),

    /**
     * .isJump
     */
    isJump: (0, _reselectTree.createLeaf)(["./trace"], step => step.op != "JUMPDEST" && step.op.indexOf("JUMP") == 0),

    /**
     * .isCall
     *
     * whether the opcode will switch to another calling context
     */
    isCall: (0, _reselectTree.createLeaf)(["./trace"], step => (0, _helpers.isCallMnemonic)(step.op)),

    /**
     * .isShortCall
     *
     * for calls that only take 6 arguments instead of 7
     */
    isShortCall: (0, _reselectTree.createLeaf)(["./trace"], step => (0, _helpers.isShortCallMnemonic)(step.op)),

    /**
     * .isDelegateCallBroad
     *
     * for calls that delegate storage
     */
    isDelegateCallBroad: (0, _reselectTree.createLeaf)(["./trace"], step => (0, _helpers.isDelegateCallMnemonicBroad)(step.op)),

    /**
     * .isDelegateCallStrict
     *
     * for calls that additionally delegate sender and value
     */
    isDelegateCallStrict: (0, _reselectTree.createLeaf)(["./trace"], step => (0, _helpers.isDelegateCallMnemonicStrict)(step.op)),

    /**
     * .isStaticCall
     */
    isStaticCall: (0, _reselectTree.createLeaf)(["./trace"], step => (0, _helpers.isStaticCallMnemonic)(step.op)),

    /**
     * .isCreate
     */
    isCreate: (0, _reselectTree.createLeaf)(["./trace"], step => (0, _helpers.isCreateMnemonic)(step.op)),

    /**
     * .isHalting
     *
     * whether the instruction halts or returns from a calling context
     * (covers only ordinary halds, not exceptional halts)
     */
    isHalting: (0, _reselectTree.createLeaf)(["./trace"], step => (0, _helpers.isNormalHaltingMnemonic)(step.op)),

    /*
     * .isStore
     */
    isStore: (0, _reselectTree.createLeaf)(["./trace"], step => step.op == "SSTORE"),

    /*
     * .isLoad
     */
    isLoad: (0, _reselectTree.createLeaf)(["./trace"], step => step.op == "SLOAD"),

    /*
     * .touchesStorage
     *
     * whether the instruction involves storage
     */
    touchesStorage: (0, _reselectTree.createLeaf)(["./isStore", "isLoad"], (stores, loads) => stores || loads)
  };

  if (state) {
    const isRelative = path => typeof path == "string" && (path.startsWith("./") || path.startsWith("../"));

    if (isRelative(state)) {
      state = `../${state}`;
    }

    (0, _assign2.default)(base, {
      /**
       * .callAddress
       *
       * address transferred to by call operation
       */
      callAddress: (0, _reselectTree.createLeaf)(["./isCall", state], (matches, { stack }) => {
        if (!matches) {
          return null;
        }

        let address = stack[stack.length - 2];
        return DecodeUtils.Conversion.toAddress(address);
      }),

      /**
       * .createBinary
       *
       * binary code to execute via create operation
       */
      createBinary: (0, _reselectTree.createLeaf)(["./isCreate", state], (matches, { stack, memory }) => {
        if (!matches) {
          return null;
        }

        // Get the code that's going to be created from memory.
        // Note we multiply by 2 because these offsets are in bytes.
        const offset = parseInt(stack[stack.length - 2], 16) * 2;
        const length = parseInt(stack[stack.length - 3], 16) * 2;

        return "0x" + memory.join("").substring(offset, offset + length);
      }),

      /**
       * .callData
       *
       * data passed to EVM call
       */
      callData: (0, _reselectTree.createLeaf)(["./isCall", "./isShortCall", state], (matches, short, { stack, memory }) => {
        if (!matches) {
          return null;
        }

        //if it's 6-argument call, the data start and offset will be one spot
        //higher in the stack than they would be for a 7-argument call, so
        //let's introduce an offset to handle this
        let argOffset = short ? 1 : 0;

        // Get the data from memory.
        // Note we multiply by 2 because these offsets are in bytes.
        const offset = parseInt(stack[stack.length - 4 + argOffset], 16) * 2;
        const length = parseInt(stack[stack.length - 5 + argOffset], 16) * 2;

        return "0x" + memory.join("").substring(offset, offset + length);
      }),

      /**
       * .callValue
       *
       * value for the call (not create); returns null for DELEGATECALL
       */
      callValue: (0, _reselectTree.createLeaf)(["./isCall", "./isDelegateCallStrict", "./isStaticCall", state], (calls, delegates, isStatic, { stack }) => {
        if (!calls || delegates) {
          return null;
        }

        if (isStatic) {
          return new _bn2.default(0);
        }

        //otherwise, for CALL and CALLCODE, it's the 3rd argument
        let value = stack[stack.length - 3];
        return DecodeUtils.Conversion.toBN(value);
      }),

      /**
       * .createValue
       *
       * value for the create
       */
      createValue: (0, _reselectTree.createLeaf)(["./isCreate", state], (matches, { stack }) => {
        if (!matches) {
          return null;
        }

        //creates have the value as the first argument
        let value = stack[stack.length - 1];
        return DecodeUtils.Conversion.toBN(value);
      }),

      /**
       * .storageAffected
       *
       * storage slot being stored to or loaded from
       * we do NOT prepend "0x"
       */
      storageAffected: (0, _reselectTree.createLeaf)(["./touchesStorage", state], (matches, { stack }) => {
        if (!matches) {
          return null;
        }

        return stack[stack.length - 1];
      })
    });
  }

  return base;
}

const evm = (0, _reselectTree.createSelectorTree)({
  /**
   * evm.state
   */
  state: state => state.evm,

  /**
   * evm.info
   */
  info: {
    /**
     * evm.info.contexts
     */
    contexts: (0, _reselectTree.createLeaf)(["/state"], state => state.info.contexts.byContext),

    /**
     * evm.info.instances
     */
    instances: (0, _reselectTree.createLeaf)(["/state"], state => state.info.instances.byAddress),

    /**
     * evm.info.binaries
     */
    binaries: {
      /**
       * evm.info.binaries.search
       *
       * returns function (binary) => context (returns the *ID* of the context)
       * (returns null on no match)
       */
      search: (0, _reselectTree.createLeaf)(["/info/contexts"], contexts => binary => {
        debug("binary %s", binary);
        let context = (0, _values2.default)(contexts).find(context => matchContext(context, binary));
        debug("context found: %O", context);
        return context !== undefined ? context.context : null;
      })
    },

    /*
     * evm.info.globals
     */
    globals: {
      /*
       * evm.info.globals.tx
       */
      tx: (0, _reselectTree.createLeaf)(["/state"], state => state.info.globals.tx),
      /*
       * evm.info.globals.block
       */
      block: (0, _reselectTree.createLeaf)(["/state"], state => state.info.globals.block)
    }
  },

  /**
   * evm.current
   */
  current: {
    /**
     * evm.current.callstack
     */
    callstack: state => state.evm.proc.callstack,

    /**
     * evm.current.call
     */
    call: (0, _reselectTree.createLeaf)(["./callstack"], stack => stack.length ? stack[stack.length - 1] : {}),

    /**
     * evm.current.context
     */
    context: (0, _reselectTree.createLeaf)(["./call", "/info/instances", "/info/binaries/search", "/info/contexts"], ({ address, binary }, instances, search, contexts) => {
      let contextId;
      if (address) {
        //if we're in a call to a deployed contract, we *must* have recorded
        //it in the instance table, so we just need to look up the context ID
        //from there; we don't need to do any further searching
        contextId = instances[address].context;
        binary = instances[address].binary;
      } else {
        //otherwise, if we're in a constructor, we'll need to actually do a
        //search
        contextId = search(binary);
      }

      let context = contexts[contextId];

      return (0, _extends3.default)({}, context, {
        binary
      });
    }),

    /**
     * evm.current.state
     *
     * evm state info: as of last operation, before op defined in step
     */
    state: (0, _assign2.default)({}, ...["depth", "error", "gas", "memory", "stack", "storage"].map(param => ({
      [param]: (0, _reselectTree.createLeaf)([_selectors2.default.step], step => step[param])
    }))),

    /**
     * evm.current.step
     */
    step: (0, _extends3.default)({}, createStepSelectors(_selectors2.default.step, "./state"), {

      //the following step selectors only exist for current, not next or any
      //other step

      /*
       * evm.current.step.createdAddress
       *
       * address created by the current create step
       */
      createdAddress: (0, _reselectTree.createLeaf)(["./isCreate", "/nextOfSameDepth/state/stack"], (matches, stack) => {
        if (!matches) {
          return null;
        }
        let address = stack[stack.length - 1];
        return DecodeUtils.Conversion.toAddress(address);
      }),

      /**
       * evm.current.step.callsPrecompileOrExternal
       *
       * are we calling a precompiled contract or an externally-owned account,
       * rather than a contract account that isn't precompiled?
       */
      callsPrecompileOrExternal: (0, _reselectTree.createLeaf)(["./isCall", "/current/state/depth", "/next/state/depth"], (calls, currentDepth, nextDepth) => calls && currentDepth === nextDepth),

      /**
       * evm.current.step.isContextChange
       * groups together calls, creates, halts, and exceptional halts
       */
      isContextChange: (0, _reselectTree.createLeaf)(["/current/state/depth", "/next/state/depth"], (currentDepth, nextDepth) => currentDepth !== nextDepth),

      /**
       * evm.current.step.isExceptionalHalting
       *
       */
      isExceptionalHalting: (0, _reselectTree.createLeaf)(["./isHalting", "/current/state/depth", "/next/state/depth"], (halting, currentDepth, nextDepth) => nextDepth < currentDepth && !halting)
    }),

    /**
     * evm.current.codex (namespace)
     */
    codex: {
      /**
       * evm.current.codex (selector)
       * the whole codex! not that that's very much at the moment
       */
      _: (0, _reselectTree.createLeaf)(["/state"], state => state.proc.codex),

      /**
       * evm.current.codex.storage
       * the current storage, as fetched from the codex... unless we're in a
       * failed creation call, then we just fall back on the state (which will
       * work, since nothing else can interfere with the storage of a failed
       * creation call!)
       */
      storage: (0, _reselectTree.createLeaf)(["./_", "../state/storage", "../call"], (codex, rawStorage, { storageAddress }) => storageAddress === DecodeUtils.EVM.ZERO_ADDRESS ? rawStorage //HACK -- if zero address ignore the codex
      : codex[codex.length - 1].accounts[storageAddress].storage)
    }
  },

  /**
   * evm.next
   */
  next: {
    /**
     * evm.next.state
     *
     * evm state as a result of next step operation
     */
    state: (0, _assign2.default)({}, ...["depth", "error", "gas", "memory", "stack", "storage"].map(param => ({
      [param]: (0, _reselectTree.createLeaf)([_selectors2.default.next], step => step[param])
    }))),

    /*
     * evm.next.step
     */
    step: createStepSelectors(_selectors2.default.next, "./state")
  },

  /**
   * evm.nextOfSameDepth
   */
  nextOfSameDepth: {
    /**
     * evm.nextOfSameDepth.state
     *
     * evm state at the next step of same depth
     */
    state: (0, _assign2.default)({}, ...["depth", "error", "gas", "memory", "stack", "storage"].map(param => ({
      [param]: (0, _reselectTree.createLeaf)([_selectors2.default.nextOfSameDepth], step => step[param])
    })))
  }
});

exports.default = evm;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _entries = __webpack_require__(8);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(6);

var _assign2 = _interopRequireDefault(_assign);

var _extends2 = __webpack_require__(2);

var _extends3 = _interopRequireDefault(_extends2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(3);

var _truffleSolidityUtils = __webpack_require__(48);

var _truffleSolidityUtils2 = _interopRequireDefault(_truffleSolidityUtils);

var _truffleCodeUtils = __webpack_require__(49);

var _truffleCodeUtils2 = _interopRequireDefault(_truffleCodeUtils);

var _map = __webpack_require__(27);

var _jsonPointer = __webpack_require__(20);

var _jsonPointer2 = _interopRequireDefault(_jsonPointer);

var _selectors = __webpack_require__(9);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(12);

var _selectors4 = _interopRequireDefault(_selectors3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:solidity:selectors");

function getSourceRange(instruction = {}) {
  return {
    start: instruction.start || 0,
    length: instruction.length || 0,
    lines: instruction.range || {
      start: {
        line: 0,
        column: 0
      },
      end: {
        line: 0,
        column: 0
      }
    }
  };
}

//function to create selectors that need both a current and next version
function createMultistepSelectors(stepSelector) {
  return {
    /**
     * .instruction
     */
    instruction: (0, _reselectTree.createLeaf)(["/current/instructionAtProgramCounter", stepSelector.programCounter],
    //HACK: we use solidity.current.instructionAtProgramCounter
    //even if we're looking at solidity.next.
    //This is harmless... so long as the current instruction isn't a context
    //change.  So, don't use solidity.next when it is.

    (map, pc) => map[pc] || {}),

    /**
     * .source
     */
    source: (0, _reselectTree.createLeaf)(["/info/sources", "./instruction"], (sources, { file: id }) => sources[id] || {}),

    /**
     * .sourceRange
     */
    sourceRange: (0, _reselectTree.createLeaf)(["./instruction"], getSourceRange),

    /**
     * .pointer
     */
    pointer: (0, _reselectTree.createLeaf)(["./source", "./sourceRange"], ({ ast }, range) => (0, _map.findRange)(ast, range.start, range.length)),

    /**
     * .node
     */
    node: (0, _reselectTree.createLeaf)(["./source", "./pointer"], ({ ast }, pointer) => pointer ? _jsonPointer2.default.get(ast, pointer) : _jsonPointer2.default.get(ast, ""))
  };
}

let solidity = (0, _reselectTree.createSelectorTree)({
  /**
   * solidity.state
   */
  state: state => state.solidity,

  /**
   * solidity.info
   */
  info: {
    /**
     * solidity.info.sources
     */
    sources: (0, _reselectTree.createLeaf)(["/state"], state => state.info.sources.byId)
  },

  /**
   * solidity.current
   */
  current: (0, _extends3.default)({
    /**
     * solidity.current.sourceMap
     */
    sourceMap: (0, _reselectTree.createLeaf)([_selectors2.default.current.context], ({ sourceMap }) => sourceMap),

    /**
     * solidity.current.functionDepthStack
     */
    functionDepthStack: state => state.solidity.proc.functionDepthStack,

    /**
     * solidity.current.functionDepth
     */
    functionDepth: (0, _reselectTree.createLeaf)(["./functionDepthStack"], stack => stack[stack.length - 1]),

    /**
     * solidity.current.instructions
     */
    instructions: (0, _reselectTree.createLeaf)(["/info/sources", _selectors2.default.current.context, "./sourceMap"], (sources, { binary }, sourceMap) => {
      if (!binary) {
        return [];
      }

      let numInstructions;
      if (sourceMap) {
        numInstructions = sourceMap.split(";").length;
      } else {
        //HACK
        numInstructions = (binary.length - 2) / 2;
        //this is actually an overestimate, but that's OK
      }

      //because we might be dealing with a constructor with arguments, we do
      //*not* remove metadata manually
      let instructions = _truffleCodeUtils2.default.parseCode(binary, numInstructions);

      if (!sourceMap) {
        // HACK
        // Let's create a source map to use since none exists. This source
        // map maps just as many ranges as there are instructions (or
        // possibly more), and marks them all as being Solidity-internal and
        // not jumps.
        sourceMap = binary !== "0x" ? "0:0:-1:-".concat(";".repeat(instructions.length - 1)) : "";
      }

      var lineAndColumnMappings = (0, _assign2.default)({}, ...(0, _entries2.default)(sources).map(([id, { source }]) => ({
        [id]: _truffleSolidityUtils2.default.getCharacterOffsetToLineAndColumnMapping(source || "")
      })));
      var humanReadableSourceMap = _truffleSolidityUtils2.default.getHumanReadableSourceMap(sourceMap);

      let primaryFile = humanReadableSourceMap[0].file;
      debug("primaryFile %o", primaryFile);

      return instructions.map((instruction, index) => {
        // lookup source map by index and add `index` property to
        // instruction
        //

        const sourceMap = humanReadableSourceMap[index] || {};

        return {
          instruction: (0, _extends3.default)({}, instruction, { index }),
          sourceMap
        };
      }).map(({ instruction, sourceMap }) => {
        // add source map information to instruction, or defaults
        //

        const {
          jump,
          start = 0,
          length = 0,
          file = primaryFile
        } = sourceMap;
        const lineAndColumnMapping = lineAndColumnMappings[file] || {};
        const range = {
          start: lineAndColumnMapping[start] || {
            line: null,
            column: null
          },
          end: lineAndColumnMapping[start + length] || {
            line: null,
            column: null
          }
        };

        if (range.start.line === null) {
          debug("sourceMap %o", sourceMap);
        }

        return (0, _extends3.default)({}, instruction, {

          jump,
          start,
          length,
          file,
          range
        });
      });
    }),

    /**
     * solidity.current.instructionAtProgramCounter
     */
    instructionAtProgramCounter: (0, _reselectTree.createLeaf)(["./instructions"], instructions => {
      let map = {};
      instructions.forEach(function (instruction) {
        map[instruction.pc] = instruction;
      });
      //note: this will have gaps in it.  That's OK!  Those gaps are the data
      //portions of push instructions, which it is illegal to jump into.  We
      //don't need to assign instructions to illegal PC values.
      return map;
    })

  }, createMultistepSelectors(_selectors2.default.current.step), {

    /**
     * solidity.current.isSourceRangeFinal
     */
    isSourceRangeFinal: (0, _reselectTree.createLeaf)(["./instructionAtProgramCounter", _selectors2.default.current.step.programCounter, _selectors2.default.next.step.programCounter], (map, current, next) => {
      if (!map[next]) {
        return true;
      }

      current = map[current];
      next = map[next];

      return current.start != next.start || current.length != next.length || current.file != next.file;
    }),

    /**
     * solidity.current.isMultiline
     */
    isMultiline: (0, _reselectTree.createLeaf)(["./sourceRange"], ({ lines }) => lines.start.line != lines.end.line),

    /**
     * solidity.current.willJump
     */
    willJump: (0, _reselectTree.createLeaf)([_selectors2.default.current.step.isJump], isJump => isJump),

    /**
     * solidity.current.jumpDirection
     */
    jumpDirection: (0, _reselectTree.createLeaf)(["./instruction"], (i = {}) => i.jump || "-"),

    /**
     * solidity.current.willCall
     */
    willCall: (0, _reselectTree.createLeaf)([_selectors2.default.current.step.isCall], x => x),

    /**
     * solidity.current.willCreate
     */
    willCreate: (0, _reselectTree.createLeaf)([_selectors2.default.current.step.isCreate], x => x),

    /**
     * solidity.current.callsPrecompileOrExternal
     */
    callsPrecompileOrExternal: (0, _reselectTree.createLeaf)([_selectors2.default.current.step.callsPrecompileOrExternal], x => x),

    /**
     * solidity.current.willReturn
     */
    willReturn: (0, _reselectTree.createLeaf)([_selectors2.default.current.step.isHalting], isHalting => isHalting),

    /**
     * solidity.current.willFail
     */
    willFail: (0, _reselectTree.createLeaf)([_selectors2.default.current.step.isExceptionalHalting], x => x),

    /*
     * solidity.current.nextMapped
     * returns the next trace step after this one which is sourcemapped
     * HACK: this assumes we're not about to change context! don't use this if
     * we are!
     * ALSO, this may return undefined, so be prepared for that
     */
    nextMapped: (0, _reselectTree.createLeaf)(["./instructionAtProgramCounter", _selectors4.default.steps, _selectors4.default.index], (map, steps, index) => steps.slice(index + 1).find(({ pc }) => map[pc] && map[pc].file !== -1))
  }),

  /**
   * solidity.next
   * HACK WARNING: do not use these selectors when the current instruction is a
   * context change! (evm call or evm return)
   */
  next: createMultistepSelectors(_selectors2.default.next.step)
});

exports.default = solidity;

/***/ }),
/* 11 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/object/values");

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _reselectTree = __webpack_require__(3);

const PAST_END_OF_TRACE = {
  depth: -1, //this is the part that matters!
  //the rest of this is just to look like a trace step
  error: "",
  gas: 0,
  memory: [],
  stack: [],
  storage: {},
  gasCost: 0,
  op: "STOP",
  pc: -1 //this is not at all valid but that's fine
};

let trace = (0, _reselectTree.createSelectorTree)({
  /**
   * trace.index
   *
   * current step index
   */
  index: state => state.trace.proc.index,

  /**
   * trace.finished
   *
   * is the trace finished?
   */
  finished: state => state.trace.proc.finished,

  /**
   * trace.steps
   *
   * all trace steps
   */
  steps: state => state.trace.info.steps,

  /**
   * trace.stepsRemaining
   *
   * number of steps remaining in trace
   */
  stepsRemaining: (0, _reselectTree.createLeaf)(["./steps", "./index"], (steps, index) => steps.length - index),

  /**
   * trace.step
   *
   * current trace step
   */
  step: (0, _reselectTree.createLeaf)(["./steps", "./index"], (steps, index) => steps[index]),

  /**
   * trace.next
   *
   * next trace step
   * HACK: if at the end,
   * we will return a spoofed "past end" step
   */
  next: (0, _reselectTree.createLeaf)(["./steps", "./index"], (steps, index) => index < steps.length - 1 ? steps[index + 1] : PAST_END_OF_TRACE),

  /*
   * trace.nextOfSameDepth
   * next trace step that's at the same depth as this one
   * NOTE: if there is none, will return undefined
   * (should not be used in such cases)
   */
  nextOfSameDepth: (0, _reselectTree.createLeaf)(["./steps", "./index"], (steps, index) => {
    let depth = steps[index].depth;
    return steps.slice(index + 1).find(step => step.depth === depth);
  })
});

exports.default = trace;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.saveSteps = saveSteps;
exports.receiveAddresses = receiveAddresses;
exports.next = next;
exports.tick = tick;
exports.tock = tock;
exports.endTrace = endTrace;
exports.reset = reset;
exports.subtock = subtock;
const SAVE_STEPS = exports.SAVE_STEPS = "SAVE_STEPS";
function saveSteps(steps) {
  return {
    type: SAVE_STEPS,
    steps
  };
}

const RECEIVE_ADDRESSES = exports.RECEIVE_ADDRESSES = "RECEIVE_ADDRESSES";
function receiveAddresses(addresses) {
  return {
    type: RECEIVE_ADDRESSES,
    addresses
  };
}

const NEXT = exports.NEXT = "NEXT";
function next() {
  return { type: NEXT };
}

const TICK = exports.TICK = "TICK";
function tick() {
  return { type: TICK };
}

const TOCK = exports.TOCK = "TOCK";
function tock() {
  return { type: TOCK };
}

const END_OF_TRACE = exports.END_OF_TRACE = "EOT";
function endTrace() {
  return { type: END_OF_TRACE };
}

const RESET = exports.RESET = "TRACE_RESET";
function reset() {
  return { type: RESET };
}

const BACKTICK = exports.BACKTICK = "BACKTICK";
function subtock() {
  return { type: BACKTICK };
}

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _set = __webpack_require__(25);

var _set2 = _interopRequireDefault(_set);

exports.advance = advance;
exports.signalTickSagaCompletion = signalTickSagaCompletion;
exports.processTrace = processTrace;
exports.reset = reset;
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(5);

var _helpers = __webpack_require__(1);

var _truffleDecodeUtils = __webpack_require__(4);

var DecodeUtils = _interopRequireWildcard(_truffleDecodeUtils);

var _actions = __webpack_require__(13);

var actions = _interopRequireWildcard(_actions);

var _selectors = __webpack_require__(12);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:trace:sagas");

function* waitForTrace() {
  let { steps } = yield (0, _effects.take)(actions.SAVE_STEPS);

  let addresses = [...new _set2.default(steps.map(({ op, stack, depth }, index) => {
    if ((0, _helpers.isCallMnemonic)(op)) {
      //if it's a call, just fetch the address off the stack
      return DecodeUtils.Conversion.toAddress(stack[stack.length - 2]);
    } else if ((0, _helpers.isCreateMnemonic)(op)) {
      //if it's a create, look ahead to when it returns and get the
      //address off the stack
      let returnStack = steps.slice(index + 1).find(step => step.depth === depth).stack;
      return DecodeUtils.Conversion.toAddress(returnStack[returnStack.length - 1]);
    } else {
      //if it's not a call or create, there's no address to get
      return undefined;
    }
  })
  //filter out zero addresses from failed creates (as well as undefineds)
  .filter(address => address !== undefined && address !== DecodeUtils.EVM.ZERO_ADDRESS))];

  yield (0, _effects.put)(actions.receiveAddresses(addresses));
}

function* advance() {
  yield (0, _effects.put)(actions.next());

  debug("TOCK to take");
  yield (0, _effects.take)([actions.TOCK, actions.END_OF_TRACE]);
  debug("TOCK taken");
}

const SUBMODULE_COUNT = 3; //data, evm, solidity

function* next() {
  let remaining = yield (0, _effects.select)(_selectors2.default.stepsRemaining);
  debug("remaining: %o", remaining);
  let steps = yield (0, _effects.select)(_selectors2.default.steps);
  debug("total steps: %o", steps.length);
  let waitingForSubmodules = 0;

  if (remaining > 0) {
    debug("putting TICK");
    // updates state for current step
    waitingForSubmodules = SUBMODULE_COUNT;
    yield (0, _effects.put)(actions.tick());
    debug("put TICK");

    //wait for all subtocks before continuing
    while (waitingForSubmodules > 0) {
      yield (0, _effects.take)(actions.BACKTICK);
      debug("got BACKTICK");
      waitingForSubmodules--;
    }

    remaining--; // local update, just for convenience
  }

  if (remaining) {
    debug("putting TOCK");
    // updates step to next step in trace
    yield (0, _effects.put)(actions.tock());
    debug("put TOCK");
  } else {
    debug("putting END_OF_TRACE");
    yield (0, _effects.put)(actions.endTrace());
    debug("put END_OF_TRACE");
  }
}

function* signalTickSagaCompletion() {
  yield (0, _effects.put)(actions.subtock());
}

function* processTrace(trace) {
  yield (0, _effects.put)(actions.saveSteps(trace));

  let { addresses } = yield (0, _effects.take)(actions.RECEIVE_ADDRESSES);
  debug("received addresses");

  return addresses;
}

function* reset() {
  yield (0, _effects.put)(actions.reset());
}

function* saga() {
  // wait for trace to be defined
  yield* waitForTrace();

  yield (0, _effects.takeEvery)(actions.NEXT, next);
}

exports.default = (0, _helpers.prefixName)("trace", saga);

/***/ }),
/* 15 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/helpers/asyncToGenerator");

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.start = start;
exports.ready = ready;
exports.error = error;
exports.recordContracts = recordContracts;
exports.saveTransaction = saveTransaction;
exports.saveReceipt = saveReceipt;
exports.saveBlock = saveBlock;
const START = exports.START = "SESSION_START";
function start(txHash, provider) {
  return {
    type: START,
    txHash,
    provider
  };
}

const READY = exports.READY = "SESSION_READY";
function ready() {
  return {
    type: READY
  };
}

const ERROR = exports.ERROR = "SESSION_ERROR";
function error(error) {
  return {
    type: ERROR,
    error
  };
}

const RECORD_CONTRACTS = exports.RECORD_CONTRACTS = "RECORD_CONTRACTS";
function recordContracts(contexts, sources) {
  return {
    type: RECORD_CONTRACTS,
    contexts,
    sources
  };
}

const SAVE_TRANSACTION = exports.SAVE_TRANSACTION = "SAVE_TRANSACTION";
function saveTransaction(transaction) {
  return {
    type: SAVE_TRANSACTION,
    transaction
  };
}

const SAVE_RECEIPT = exports.SAVE_RECEIPT = "SAVE_RECEIPT";
function saveReceipt(receipt) {
  return {
    type: SAVE_RECEIPT,
    receipt
  };
}

const SAVE_BLOCK = exports.SAVE_BLOCK = "SAVE_BLOCK";
function saveBlock(block) {
  return {
    type: SAVE_BLOCK,
    block
  };
}

/***/ }),
/* 17 */
/***/ (function(module, exports) {

module.exports = require("bn.js");

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.advance = advance;
exports.stepNext = stepNext;
exports.stepOver = stepOver;
exports.stepInto = stepInto;
exports.stepOut = stepOut;
exports.reset = reset;
exports.interrupt = interrupt;
exports.continueUntilBreakpoint = continueUntilBreakpoint;
exports.addBreakpoint = addBreakpoint;
exports.removeBreakpoint = removeBreakpoint;
exports.removeAllBreakpoints = removeAllBreakpoints;
exports.doneStepping = doneStepping;
const ADVANCE = exports.ADVANCE = "ADVANCE";
function advance(count) {
  return { type: ADVANCE, count };
}

const STEP_NEXT = exports.STEP_NEXT = "STEP_NEXT";
function stepNext() {
  return { type: STEP_NEXT };
}

const STEP_OVER = exports.STEP_OVER = "STEP_OVER";
function stepOver() {
  return { type: STEP_OVER };
}

const STEP_INTO = exports.STEP_INTO = "STEP_INTO";
function stepInto() {
  return { type: STEP_INTO };
}

const STEP_OUT = exports.STEP_OUT = "STEP_OUT";
function stepOut() {
  return { type: STEP_OUT };
}

const RESET = exports.RESET = "RESET";
function reset() {
  return { type: RESET };
}

const INTERRUPT = exports.INTERRUPT = "INTERRUPT";
function interrupt() {
  return { type: INTERRUPT };
}

const CONTINUE = exports.CONTINUE = "CONTINUE";
function continueUntilBreakpoint(breakpoints) {
  //"continue" is not a legal name
  return {
    type: CONTINUE,
    breakpoints
  };
}

const ADD_BREAKPOINT = exports.ADD_BREAKPOINT = "ADD_BREAKPOINT";
function addBreakpoint(breakpoint) {
  return {
    type: ADD_BREAKPOINT,
    breakpoint
  };
}

const REMOVE_BREAKPOINT = exports.REMOVE_BREAKPOINT = "REMOVE_BREAKPOINT";
function removeBreakpoint(breakpoint) {
  return {
    type: REMOVE_BREAKPOINT,
    breakpoint
  };
}

const REMOVE_ALL_BREAKPOINTS = exports.REMOVE_ALL_BREAKPOINTS = "REMOVE_ALL_BREAKPOINTS";
function removeAllBreakpoints() {
  return {
    type: REMOVE_ALL_BREAKPOINTS
  };
}

const DONE_STEPPING = exports.DONE_STEPPING = "DONE_STEPPING";
function doneStepping() {
  return {
    type: DONE_STEPPING
  };
}

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = __webpack_require__(26);

var _promise2 = _interopRequireDefault(_promise);

var _asyncToGenerator2 = __webpack_require__(15);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _values = __webpack_require__(11);

var _values2 = _interopRequireDefault(_values);

var _extends2 = __webpack_require__(2);

var _extends3 = _interopRequireDefault(_extends2);

var _entries = __webpack_require__(8);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(6);

var _assign2 = _interopRequireDefault(_assign);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(3);

var _jsonPointer = __webpack_require__(20);

var _jsonPointer2 = _interopRequireDefault(_jsonPointer);

var _helpers = __webpack_require__(1);

var _selectors = __webpack_require__(9);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(10);

var _selectors4 = _interopRequireDefault(_selectors3);

var _truffleDecodeUtils = __webpack_require__(4);

var DecodeUtils = _interopRequireWildcard(_truffleDecodeUtils);

var _truffleDecoder = __webpack_require__(22);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:data:selectors");

/**
 * @private
 */
const identity = x => x;

function findAncestorOfType(node, types, scopes) {
  //note: I'm not including any protection against null in this function.
  //You are advised to include "SourceUnit" as a fallback type.
  while (node && !types.includes(node.nodeType)) {
    node = scopes[scopes[node.id].parentId].definition;
  }
  return node;
}

//given a modifier invocation (or inheritance specifier) node,
//get the node for the actual modifier (or constructor)
function modifierForInvocation(invocation, scopes) {
  let rawId; //raw referencedDeclaration ID extracted from the AST.
  //if it's a modifier this is what we want, but if it's base
  //constructor, we'll get the contract instead, and need to find its
  //constructor.
  switch (invocation.nodeType) {
    case "ModifierInvocation":
      rawId = invocation.modifierName.referencedDeclaration;
      break;
    case "InheritanceSpecifier":
      rawId = invocation.baseName.referencedDeclaration;
      break;
    default:
      debug("bad invocation node");
  }
  let rawNode = scopes[rawId].definition;
  switch (rawNode.nodeType) {
    case "ModifierDefinition":
      return rawNode;
    case "ContractDefinition":
      return rawNode.nodes.find(node => node.nodeType === "FunctionDefinition" && node.kind === "constructor");
    default:
      //we should never hit this case
      return undefined;
  }
}

const data = (0, _reselectTree.createSelectorTree)({
  state: state => state.data,

  /**
   * data.views
   */
  views: {
    /*
     * data.views.atLastInstructionForSourceRange
     */
    atLastInstructionForSourceRange: (0, _reselectTree.createLeaf)([_selectors4.default.current.isSourceRangeFinal], final => final),

    /**
     * data.views.scopes (namespace)
     */
    scopes: {
      /**
       * data.views.scopes.inlined (namespace)
       */
      inlined: {
        /**
         * data.views.scopes.inlined (selector)
         * see data.info.scopes for how this differs from the raw version
         */
        _: (0, _reselectTree.createLeaf)(["/info/scopes", "./raw"], (scopes, inlined) => (0, _assign2.default)({}, ...(0, _entries2.default)(inlined).map(([id, info]) => {
          let newInfo = (0, _extends3.default)({}, info);
          newInfo.variables = scopes[id].variables;
          return { [id]: newInfo };
        }))),

        /**
         * data.views.scopes.inlined.raw
         */
        raw: (0, _reselectTree.createLeaf)(["/info/scopes/raw", _selectors4.default.info.sources], (scopes, sources) => (0, _assign2.default)({}, ...(0, _entries2.default)(scopes).map(([id, entry]) => ({
          [id]: (0, _extends3.default)({}, entry, {

            definition: _jsonPointer2.default.get(sources[entry.sourceId].ast, entry.pointer)
          })
        }))))
      }
    },

    /**
     * data.views.decoder
     *
     * selector returns (ast node definition, data reference) => Promise<value>
     */
    decoder: (0, _reselectTree.createLeaf)(["/views/referenceDeclarations", "/current/state", "/views/mappingKeys", "/info/allocations"], (referenceDeclarations, state, mappingKeys, allocations) => (definition, ref) => (0, _truffleDecoder.forEvmState)(definition, ref, {
      referenceDeclarations,
      state,
      mappingKeys,
      storageAllocations: allocations.storage,
      memoryAllocations: allocations.memory,
      calldataAllocations: allocations.calldata
    })),

    /*
     * data.views.userDefinedTypes
     */
    userDefinedTypes: {
      /*
       * data.views.userDefinedTypes.contractDefinitions
       * restrict to contracts only, and get their definitions
       */
      contractDefinitions: (0, _reselectTree.createLeaf)(["/info/userDefinedTypes", "/views/scopes/inlined"], (typeIds, scopes) => typeIds.map(id => scopes[id].definition).filter(node => node.nodeType === "ContractDefinition"))
    },

    /*
     * data.views.referenceDeclarations
     */
    referenceDeclarations: (0, _reselectTree.createLeaf)(["./scopes/inlined", "/info/userDefinedTypes"], (scopes, userDefinedTypes) => (0, _assign2.default)({}, ...userDefinedTypes.map(id => ({ [id]: scopes[id].definition })))),

    /**
     * data.views.mappingKeys
     */
    mappingKeys: (0, _reselectTree.createLeaf)(["/proc/mappedPaths", "/current/address"], (mappedPaths, address) => [].concat(...(0, _values2.default)((mappedPaths.byAddress[address] || { byType: {} }).byType).map(({ bySlotAddress }) => (0, _values2.default)(bySlotAddress))).filter(slot => slot.key !== undefined))
  },

  /**
   * data.info
   */
  info: {
    /**
     * data.info.scopes (namespace)
     */
    scopes: {
      /**
       * data.info.scopes (selector)
       * the raw version is below; this version accounts for inheritance
       * NOTE: doesn't this selector really belong in data.views?  Yes.
       * But, since it's replacing the old data.info.scopes (which is now
       * data.info.scopes.raw), I didn't want to move it.
       */
      _: (0, _reselectTree.createLeaf)(["./raw", "/views/scopes/inlined/raw"], (scopes, inlined) => (0, _assign2.default)({}, ...(0, _entries2.default)(scopes).map(([id, scope]) => {
        let definition = inlined[id].definition;
        if (definition.nodeType !== "ContractDefinition") {
          return { [id]: scope };
        }
        //if we've reached this point, we should be dealing with a
        //contract, and specifically a contract -- not an interface or
        //library (those don't get "variables" entries in their scopes)
        debug("contract id %d", id);
        let newScope = (0, _extends3.default)({}, scope);
        //note that Solidity gives us the linearization in order from most
        //derived to most base, but we want most base to most derived;
        //annoyingly, reverse() is in-place, so we clone with slice() first
        let linearizedBaseContractsFromBase = definition.linearizedBaseContracts.slice().reverse();
        //now, we put it all together
        newScope.variables = [].concat(...linearizedBaseContractsFromBase.map(contractId => scopes[contractId].variables || []
        //we need the || [] because contracts with no state variables
        //have variables undefined rather than empty like you'd expect
        )).filter(variable => {
          //...except, HACK, let's filter out those constants we don't know
          //how to read.  they'll just clutter things up.
          debug("variable %O", variable);
          let definition = inlined[variable.id].definition;
          return !definition.constant || DecodeUtils.Definition.isSimpleConstant(definition.value);
        });

        return { [id]: newScope };
      }))),

      /*
       * data.info.scopes.raw
       */
      raw: (0, _reselectTree.createLeaf)(["/state"], state => state.info.scopes.byId)
    },

    /*
     * data.info.allocations
     */
    allocations: {
      /*
       * data.info.allocations.storage
       */
      storage: (0, _reselectTree.createLeaf)(["/state"], state => state.info.allocations.storage),

      /*
       * data.info.allocations.memory
       */
      memory: (0, _reselectTree.createLeaf)(["/state"], state => state.info.allocations.memory),

      /*
       * data.info.allocations.calldata
       */
      calldata: (0, _reselectTree.createLeaf)(["/state"], state => state.info.allocations.calldata)
    },

    /**
     * data.info.userDefinedTypes
     */
    userDefinedTypes: (0, _reselectTree.createLeaf)(["/state"], state => state.info.userDefinedTypes)
  },

  /**
   * data.proc
   */
  proc: {
    /**
     * data.proc.assignments
     */
    assignments: (0, _reselectTree.createLeaf)(["/state"], state => state.proc.assignments
    //note: this no longer fetches just the byId, but rather the whole
    //assignments object
    ),

    /*
     * data.proc.mappedPaths
     */
    mappedPaths: (0, _reselectTree.createLeaf)(["/state"], state => state.proc.mappedPaths),

    /**
     * data.proc.decodingKeys
     *
     * number of keys that are still decoding
     */
    decodingKeys: (0, _reselectTree.createLeaf)(["./mappedPaths"], mappedPaths => mappedPaths.decodingStarted)
  },

  /**
   * data.current
   */
  current: {
    /**
     * data.current.state
     */
    state: {
      /**
       * data.current.state.stack
       */
      stack: (0, _reselectTree.createLeaf)([_selectors2.default.current.state.stack], words => (words || []).map(word => DecodeUtils.Conversion.toBytes(word))),

      /**
       * data.current.state.memory
       */
      memory: (0, _reselectTree.createLeaf)([_selectors2.default.current.state.memory], words => DecodeUtils.Conversion.toBytes(words.join(""))),

      /**
       * data.current.state.calldata
       */
      calldata: (0, _reselectTree.createLeaf)([_selectors2.default.current.call], ({ data }) => DecodeUtils.Conversion.toBytes(data)),

      /**
       * data.current.state.storage
       */
      storage: (0, _reselectTree.createLeaf)([_selectors2.default.current.codex.storage], mapping => (0, _assign2.default)({}, ...(0, _entries2.default)(mapping).map(([address, word]) => ({
        [`0x${address}`]: DecodeUtils.Conversion.toBytes(word)
      })))),

      /*
       * data.current.state.specials
       * I've named these after the solidity variables they correspond to,
       * which are *mostly* the same as the corresponding EVM opcodes
       * (FWIW: this = ADDRESS, sender = CALLER, value = CALLVALUE)
       */
      specials: (0, _reselectTree.createLeaf)(["/current/address", _selectors2.default.current.call, _selectors2.default.info.globals], (address, { sender, value }, { tx, block }) => (0, _extends3.default)({
        this: DecodeUtils.Conversion.toBytes(address),

        sender: DecodeUtils.Conversion.toBytes(sender),

        value: DecodeUtils.Conversion.toBytes(value)

      }, (0, _assign2.default)({}, ...(0, _entries2.default)(tx).map(([variable, value]) => ({
        [variable]: DecodeUtils.Conversion.toBytes(value)
      }))), (0, _assign2.default)({}, ...(0, _entries2.default)(block).map(([variable, value]) => ({
        [variable]: DecodeUtils.Conversion.toBytes(value)
      })))))
    },

    /**
     * data.current.node
     */
    node: (0, _reselectTree.createLeaf)([_selectors4.default.current.node], identity),

    /**
     * data.current.scope
     * old alias for data.current.node (deprecated)
     */
    scope: (0, _reselectTree.createLeaf)(["./node"], identity),

    /**
     * data.current.functionDepth
     */

    functionDepth: (0, _reselectTree.createLeaf)([_selectors4.default.current.functionDepth], identity),

    /**
     * data.current.address
     * NOTE: this is the STORAGE address for the current call, not the CODE
     * address
     */

    address: (0, _reselectTree.createLeaf)([_selectors2.default.current.call], call => call.storageAddress),

    /*
     * data.current.aboutToModify
     * HACK
     * This selector is used to catch those times when we go straight from a
     * modifier invocation into the modifier itself, skipping over the
     * definition node (this includes base constructor calls).  So it should
     * return true when:
     * 1. we're on the node corresponding to an argument to a modifier
     * invocation or base constructor call, or, if said argument is a type
     * conversion, its argument (or nested argument)
     * 2. the next node is not a FunctionDefinition, ModifierDefinition, or
     * in the same modifier / base constructor invocation
     */
    aboutToModify: (0, _reselectTree.createLeaf)(["./node", "./modifierInvocation", "./modifierArgumentIndex", "/next/node", "/next/modifierInvocation", _selectors2.default.current.step.isContextChange], (node, invocation, index, next, nextInvocation, isContextChange) => {
      //ensure: current instruction is not a context change (because if it is
      //we cannot rely on the data.next selectors, but also if it is we know
      //we're not about to call a modifier or base constructor!)
      //we also want to return false if we can't find things for whatever
      //reason
      if (isContextChange || !node || !next || !invocation || !nextInvocation) {
        return false;
      }

      //ensure: current position is in a ModifierInvocation or
      //InheritanceSpecifier (recall that SourceUnit was included as
      //fallback)
      if (invocation.nodeType === "SourceUnit") {
        return false;
      }

      //ensure: next node is not a function definition or modifier definition
      if (next.nodeType === "FunctionDefinition" || next.nodeType === "ModifierDefinition") {
        return false;
      }

      //ensure: next node is not in the same invocation
      if (nextInvocation.nodeType !== "SourceUnit" && nextInvocation.id === invocation.id) {
        return false;
      }

      //now: are we on the node corresponding to an argument, or, if
      //it's a type conversion, its nested argument?
      if (index === undefined) {
        return false;
      }
      let argument = invocation.arguments[index];
      while (argument.kind === "typeConversion") {
        if (node.id === argument.id) {
          return true;
        }
        argument = argument.arguments[0];
      }
      return node.id === argument.id;
    }),

    /*
     * data.current.modifierInvocation
     */
    modifierInvocation: (0, _reselectTree.createLeaf)(["./node", "/views/scopes/inlined"], (node, scopes) => {
      const types = ["ModifierInvocation", "InheritanceSpecifier", "SourceUnit"];
      //again, SourceUnit included as fallback
      return findAncestorOfType(node, types, scopes);
    }),

    /**
     * data.current.modifierArgumentIndex
     * gets the index of the current modifier argument that you're in
     * (undefined when not in a modifier argument)
     */
    modifierArgumentIndex: (0, _reselectTree.createLeaf)(["/info/scopes", "./node", "./modifierInvocation"], (scopes, node, invocation) => {
      if (invocation.nodeType === "SourceUnit") {
        return undefined;
      }

      let pointer = scopes[node.id].pointer;
      let invocationPointer = scopes[invocation.id].pointer;

      //slice the invocation pointer off the beginning
      let difference = pointer.replace(invocationPointer, "");
      debug("difference %s", difference);
      let rawIndex = difference.match(/^\/arguments\/(\d+)/);
      //note that that \d+ is greedy
      debug("rawIndex %o", rawIndex);
      if (rawIndex === null) {
        return undefined;
      }
      return parseInt(rawIndex[1]);
    }),

    /*
     * data.current.modifierBeingInvoked
     * gets the node corresponding to the modifier or base constructor
     * being invoked
     */
    modifierBeingInvoked: (0, _reselectTree.createLeaf)(["./modifierInvocation", "/views/scopes/inlined"], (invocation, scopes) => {
      if (!invocation || invocation.nodeType === "SourceUnit") {
        return undefined;
      }

      return modifierForInvocation(invocation, scopes);
    }),

    /**
     * data.current.identifiers (namespace)
     */
    identifiers: {
      /**
       * data.current.identifiers (selector)
       *
       * returns identifers and corresponding definition node ID or builtin name
       * (object entries look like [name]: {astId: id} or like [name]: {builtin: name}
       */
      _: (0, _reselectTree.createLeaf)(["/views/scopes/inlined", "/current/node"], (scopes, scope) => {
        let variables = {};
        if (scope !== undefined) {
          let cur = scope.id;

          do {
            variables = (0, _assign2.default)(variables, ...(scopes[cur].variables || []).filter(v => v.name !== "") //exclude anonymous output params
            .filter(v => variables[v.name] == undefined).map(v => ({ [v.name]: { astId: v.id } })));

            cur = scopes[cur].parentId;
          } while (cur != null);
        }

        let builtins = {
          msg: { builtin: "msg" },
          tx: { builtin: "tx" },
          block: { builtin: "block" },
          this: { builtin: "this" },
          now: { builtin: "now" }
        };

        return (0, _extends3.default)({}, variables, builtins);
      }),

      /**
       * data.current.identifiers.definitions (namespace)
       */
      definitions: {
        /* data.current.identifiers.definitions (selector)
         * definitions for current variables, by identifier
         */
        _: (0, _reselectTree.createLeaf)(["/views/scopes/inlined", "../_", "./this"], (scopes, identifiers, thisDefinition) => {
          let variables = (0, _assign2.default)({}, ...(0, _entries2.default)(identifiers).map(([identifier, { astId }]) => {
            if (astId !== undefined) {
              //will be undefined for builtins
              let { definition } = scopes[astId];
              return { [identifier]: definition };
            } else {
              return {}; //skip over builtins; we'll handle those separately
            }
          }));
          let builtins = {
            msg: DecodeUtils.Definition.MSG_DEFINITION,
            tx: DecodeUtils.Definition.TX_DEFINITION,
            block: DecodeUtils.Definition.BLOCK_DEFINITION,
            this: thisDefinition,
            now: DecodeUtils.Definition.spoofUintDefinition("now")
          };
          return (0, _extends3.default)({}, variables, builtins);
        }),

        /*
         * data.current.identifiers.definitions.this
         *
         * returns a spoofed definition for the this variable
         */
        this: (0, _reselectTree.createLeaf)([_selectors2.default.current.context], ({ contractName, contractId }) => DecodeUtils.Definition.spoofThisDefinition(contractName, contractId))
      },

      /**
       * data.current.identifiers.refs
       *
       * current variables' value refs
       */
      refs: (0, _reselectTree.createLeaf)(["/proc/assignments", "./_", "/current/functionDepth", //for pruning things too deep on stack
      "/current/address" //for contract variables
      ], (assignments, identifiers, currentDepth, address) => (0, _assign2.default)({}, ...(0, _entries2.default)(identifiers).map(([identifier, { astId, builtin }]) => {
        let id;

        //is this an ordinary variable or a builtin?
        if (astId !== undefined) {
          //if not a builtin, first check if it's a contract var
          let matchIds = (assignments.byAstId[astId] || []).filter(idHash => assignments.byId[idHash].address === address);
          if (matchIds.length > 0) {
            id = matchIds[0]; //there should only be one!
          }

          //if not contract, it's local, so find the innermost
          //(but not beyond current depth)
          if (id === undefined) {
            let matchFrames = (assignments.byAstId[astId] || []).map(id => assignments.byId[id].stackframe).filter(stackframe => stackframe !== undefined);

            if (matchFrames.length > 0) {
              //this check isn't *really*
              //necessary, but may as well prevent stupid stuff
              let maxMatch = Math.min(currentDepth, Math.max(...matchFrames));
              id = (0, _helpers.stableKeccak256)({ astId, stackframe: maxMatch });
            }
          }
        } else {
          //otherwise, it's a builtin
          //NOTE: for now we assume there is only one assignment per
          //builtin, but this will change in the future
          id = assignments.byBuiltin[builtin][0];
        }

        //if we still didn't find it, oh well

        let { ref } = assignments.byId[id] || {};
        if (!ref) {
          return undefined;
        }

        return {
          [identifier]: ref
        };
      }))),

      /**
       * data.current.identifiers.decoded
       *
       * Returns an object with values as Promises
       */
      decoded: (0, _reselectTree.createLeaf)(["/views/decoder", "./definitions", "./refs"], (() => {
        var _ref = (0, _asyncToGenerator3.default)(function* (decode, definitions, refs) {
          debug("setting up keyedPromises");
          const keyedPromises = (0, _entries2.default)(refs).map((() => {
            var _ref2 = (0, _asyncToGenerator3.default)(function* ([identifier, ref]) {
              return {
                [identifier]: yield decode(definitions[identifier], ref)
              };
            });

            return function (_x4) {
              return _ref2.apply(this, arguments);
            };
          })());
          debug("set up keyedPromises");
          const keyedResults = yield _promise2.default.all(keyedPromises);
          debug("got keyedResults");
          return DecodeUtils.Conversion.cleanContainers((0, _assign2.default)({}, ...keyedResults));
        });

        return function (_x, _x2, _x3) {
          return _ref.apply(this, arguments);
        };
      })())
    }
  },

  /**
   * data.next
   */
  next: {
    /**
     * data.next.state
     * Yes, I'm just repeating the code for data.current.state.stack here;
     * not worth the trouble to factor out
     */
    state: {
      /**
       * data.next.state.stack
       */
      stack: (0, _reselectTree.createLeaf)([_selectors2.default.next.state.stack], words => (words || []).map(word => DecodeUtils.Conversion.toBytes(word)))
    },

    //HACK WARNING
    //the following selectors depend on solidity.next
    //do not use them when the current instruction is a context change!

    /**
     * data.next.node
     */
    node: (0, _reselectTree.createLeaf)([_selectors4.default.next.node], identity),

    /**
     * data.next.modifierInvocation
     * Note: yes, I'm just repeating the code from data.current here but with
     * invalid added
     */
    modifierInvocation: (0, _reselectTree.createLeaf)(["./node", "/views/scopes/inlined", _selectors2.default.current.step.isContextChange], (node, scopes, invalid) => {
      //don't attempt this at a context change!
      //(also don't attempt this if we can't find the node for whatever
      //reason)
      if (invalid || !node) {
        return undefined;
      }
      const types = ["ModifierInvocation", "InheritanceSpecifier", "SourceUnit"];
      //again, SourceUnit included as fallback
      return findAncestorOfType(node, types, scopes);
    }),

    /*
     * data.next.modifierBeingInvoked
     */
    modifierBeingInvoked: (0, _reselectTree.createLeaf)(["./modifierInvocation", "/views/scopes/inlined", _selectors2.default.current.step.isContextChange], (invocation, scopes, invalid) => {
      if (invalid || !invocation || invocation.nodeType === "SourceUnit") {
        return undefined;
      }

      return modifierForInvocation(invocation, scopes);
    })
    //END HACK WARNING
  },

  /**
   * data.nextMapped
   */
  nextMapped: {
    /**
     * data.nextMapped.state
     * Yes, I'm just repeating the code for data.current.state.stack here;
     * not worth the trouble to factor out
     * HACK: this assumes we're not about to change context! don't use this if we
     * are!
     */
    state: {
      /**
       * data.nextMapped.state.stack
       */
      stack: (0, _reselectTree.createLeaf)([_selectors4.default.current.nextMapped], step => ((step || {}).stack || []).map(word => DecodeUtils.Conversion.toBytes(word)))
    }
  }
});

exports.default = data;

/***/ }),
/* 20 */
/***/ (function(module, exports) {

module.exports = require("json-pointer");

/***/ }),
/* 21 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/object/keys");

/***/ }),
/* 22 */
/***/ (function(module, exports) {

module.exports = require("truffle-decoder");

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__(2);

var _extends3 = _interopRequireDefault(_extends2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(3);

var _selectors = __webpack_require__(9);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(10);

var _selectors4 = _interopRequireDefault(_selectors3);

var _selectors5 = __webpack_require__(12);

var _selectors6 = _interopRequireDefault(_selectors5);

var _map = __webpack_require__(27);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:controller:selectors"); //eslint-disable-line no-unused-vars

/**
 * @private
 */
const identity = x => x;

/**
 * controller
 */
const controller = (0, _reselectTree.createSelectorTree)({
  /**
   * controller.state
   */
  state: state => state.controller,
  /**
   * controller.current
   */
  current: {
    /**
     * controller.current.functionDepth
     */
    functionDepth: (0, _reselectTree.createLeaf)([_selectors4.default.current.functionDepth], identity),

    /**
     * controller.current.executionContext
     */
    executionContext: (0, _reselectTree.createLeaf)([_selectors2.default.current.call], identity),

    /**
     * controller.current.willJump
     */
    willJump: (0, _reselectTree.createLeaf)([_selectors2.default.current.step.isJump], identity),

    /**
     * controller.current.location
     */
    location: {
      /**
       * controller.current.location.sourceRange
       */
      sourceRange: (0, _reselectTree.createLeaf)([_selectors4.default.current.sourceRange], identity),

      /**
       * controller.current.location.source
       */
      source: (0, _reselectTree.createLeaf)([_selectors4.default.current.source], identity),

      /**
       * controller.current.location.node
       */
      node: (0, _reselectTree.createLeaf)([_selectors4.default.current.node], identity),

      /**
       * controller.current.location.isMultiline
       */
      isMultiline: (0, _reselectTree.createLeaf)([_selectors4.default.current.isMultiline], identity)
    },

    /**
     * controller.current.finished
     */
    finished: (0, _reselectTree.createLeaf)([_selectors6.default.finished], identity)
  },

  /**
   * controller.breakpoints (namespace)
   */
  breakpoints: {
    /**
     * controller.breakpoints (selector)
     */
    _: (0, _reselectTree.createLeaf)(["/state"], state => state.breakpoints),

    /**
     * controller.breakpoints.resolver (selector)
     * this selector returns a function that adjusts a given line-based
     * breakpoint (on node-based breakpoints it simply returns the input) by
     * repeatedly moving it down a line until it lands on a line where there's
     * actually somewhere to break.  if no such line exists beyond that point, it
     * returns null instead.
     */
    resolver: (0, _reselectTree.createLeaf)([_selectors4.default.info.sources], sources => breakpoint => {
      let adjustedBreakpoint;
      if (breakpoint.node === undefined) {
        let line = breakpoint.line;
        let { source, ast } = sources[breakpoint.sourceId];
        let lineLengths = source.split("\n").map(line => line.length);
        //why does neither JS nor lodash have a scan function like Haskell??
        //guess we'll have to do our scan manually
        let lineStarts = [0];
        for (let length of lineLengths) {
          lineStarts.push(lineStarts[lineStarts.length - 1] + length + 1);
          //+1 for the /n itself
        }
        debug("line: %s", source.slice(lineStarts[line], lineStarts[line] + lineLengths[line]));
        while (line < lineLengths.length && !(0, _map.anyNonSkippedInRange)(ast, lineStarts[line], lineLengths[line])) {
          debug("incrementing");
          line++;
        }
        if (line >= lineLengths.length) {
          adjustedBreakpoint = null;
        } else {
          adjustedBreakpoint = (0, _extends3.default)({}, breakpoint, { line });
        }
      } else {
        debug("node-based breakpoint");
        adjustedBreakpoint = breakpoint;
      }
      return adjustedBreakpoint;
    })
  },

  /**
   * controller.finished
   * deprecated alias for controller.current.finished
   */
  finished: (0, _reselectTree.createLeaf)(["/current/finished"], finished => finished),

  /**
   * controller.isStepping
   */
  isStepping: (0, _reselectTree.createLeaf)(["./state"], state => state.isStepping)
});

exports.default = controller;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__(2);

var _extends3 = _interopRequireDefault(_extends2);

exports.scope = scope;
exports.declare = declare;
exports.defineType = defineType;
exports.reset = reset;
exports.recordAllocations = recordAllocations;
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(5);

var _helpers = __webpack_require__(1);

var _actions = __webpack_require__(13);

var _actions2 = __webpack_require__(28);

var actions = _interopRequireWildcard(_actions2);

var _sagas = __webpack_require__(14);

var trace = _interopRequireWildcard(_sagas);

var _selectors = __webpack_require__(19);

var _selectors2 = _interopRequireDefault(_selectors);

var _lodash = __webpack_require__(54);

var _lodash2 = _interopRequireDefault(_lodash);

var _truffleDecodeUtils = __webpack_require__(4);

var DecodeUtils = _interopRequireWildcard(_truffleDecodeUtils);

var _truffleDecoder = __webpack_require__(22);

var _bn = __webpack_require__(17);

var _bn2 = _interopRequireDefault(_bn);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:data:sagas");

function* scope(nodeId, pointer, parentId, sourceId) {
  yield (0, _effects.put)(actions.scope(nodeId, pointer, parentId, sourceId));
}

function* declare(node) {
  yield (0, _effects.put)(actions.declare(node));
}

function* defineType(node) {
  yield (0, _effects.put)(actions.defineType(node));
}

function* tickSaga() {
  debug("got TICK");

  yield* variablesAndMappingsSaga();
  yield* trace.signalTickSagaCompletion();
}

function* variablesAndMappingsSaga() {
  let node = yield (0, _effects.select)(_selectors2.default.current.node);
  let decode = yield (0, _effects.select)(_selectors2.default.views.decoder);
  let scopes = yield (0, _effects.select)(_selectors2.default.views.scopes.inlined);
  let referenceDeclarations = yield (0, _effects.select)(_selectors2.default.views.referenceDeclarations);
  let allocations = yield (0, _effects.select)(_selectors2.default.info.allocations.storage);
  let currentAssignments = yield (0, _effects.select)(_selectors2.default.proc.assignments);
  let mappedPaths = yield (0, _effects.select)(_selectors2.default.proc.mappedPaths);
  let currentDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
  let address = yield (0, _effects.select)(_selectors2.default.current.address);
  //storage address, not code address

  let stack = yield (0, _effects.select)(_selectors2.default.next.state.stack); //note the use of next!
  //in this saga we are interested in the *results* of the current instruction
  //note that the decoder is still based on data.current.state; that's fine
  //though.  There's already a delay between when we record things off the
  //stack and when we decode them, after all.  Basically, nothing serious
  //should happen after an index node but before the index access node that
  //would cause storage, memory, or calldata to change, meaning that even if
  //the literal we recorded was a pointer, it will still be valid at the time
  //we use it.  (The other literals we make use of, for the base expressions,
  //are not decoded, so no potential mismatch there would be relevant anyway.)

  let alternateStack = yield (0, _effects.select)(_selectors2.default.nextMapped.state.stack);
  //HACK: unfortunately, in some cases, data.next.state.stack gets the wrong
  //results due to unmapped instructions intervening.  So, we get the stack at
  //the next *mapped* stack instead.  This is something of a hack and won't
  //work if we're about to change context, but it should work in the cases that
  //need it.

  if (!stack) {
    return;
  }

  let top = stack.length - 1;
  var assignment, assignments, preambleAssignments, baseExpression, slot, path;

  if (!node) {
    return;
  }

  // stack is only ready for interpretation after the last step of each
  // source range
  //
  // the data module always looks at the result of a particular opcode
  // (i.e., the following trace step's stack/memory/storage), so this
  // asserts that the _current_ operation is the final one before
  // proceeding
  if (!(yield (0, _effects.select)(_selectors2.default.views.atLastInstructionForSourceRange))) {
    return;
  }

  //HACK: modifier preamble
  //modifier definitions are typically skipped (this includes constructor
  //definitions when called as a base constructor); as such I've added this
  //"modifier preamble" to catch them
  if (yield (0, _effects.select)(_selectors2.default.current.aboutToModify)) {
    let modifier = yield (0, _effects.select)(_selectors2.default.current.modifierBeingInvoked);
    //may be either a modifier or base constructor
    let currentIndex = yield (0, _effects.select)(_selectors2.default.current.modifierArgumentIndex);
    debug("currentIndex %d", currentIndex);
    let parameters = modifier.parameters.parameters;
    //now: look at the parameters *after* the current index.  we'll need to
    //adjust for those.
    let parametersLeft = parameters.slice(currentIndex + 1);
    let adjustment = (0, _lodash2.default)(parametersLeft.map(DecodeUtils.Definition.stackSize));
    debug("adjustment %d", adjustment);
    preambleAssignments = assignParameters(parameters, top + adjustment, currentDepth);
  } else {
    preambleAssignments = {};
  }

  switch (node.nodeType) {
    case "FunctionDefinition":
    case "ModifierDefinition":
      //NOTE: this will *not* catch most modifier definitions!
      //the rest hopefully will be caught by the modifier preamble
      //(in fact they won't all be, but...)

      //HACK: filter out some garbage
      //this filters out the case where we're really in an invocation of a
      //modifier or base constructor, but have temporarily hit the definition
      //node for some reason.  However this obviously can have a false positive
      //in the case where a function has the same modifier twice.
      let nextModifier = yield (0, _effects.select)(_selectors2.default.next.modifierBeingInvoked);
      if (nextModifier && nextModifier.id === node.id) {
        break;
      }

      let parameters = node.parameters.parameters;
      //note that we do *not* include return parameters, since those are
      //handled by the VariableDeclaration case (no, I don't know why it
      //works out that way)

      //we can skip preambleAssignments here, that isn't used in this case
      assignments = assignParameters(parameters, top, currentDepth);

      debug("Function definition case");
      debug("assignments %O", assignments);

      yield (0, _effects.put)(actions.assign(assignments));
      break;

    case "ContractDefinition":
      let allocation = allocations[node.id];

      debug("Contract definition case");
      debug("allocations %O", allocations);
      debug("allocation %O", allocation);
      assignments = {};
      for (let id in allocation.members) {
        id = Number(id); //not sure why we're getting them as strings, but...
        let idObj = { astId: id, address };
        let fullId = (0, _helpers.stableKeccak256)(idObj);
        //we don't use makeAssignment here as we had to compute the ID anyway
        assignment = (0, _extends3.default)({}, idObj, {
          id: fullId,
          ref: (0, _extends3.default)({}, (currentAssignments.byId[fullId] || {}).ref || {}, allocation.members[id].pointer)
        });
        assignments[fullId] = assignment;
      }
      debug("assignments %O", assignments);

      //this case doesn't need preambleAssignments either
      yield (0, _effects.put)(actions.assign(assignments));
      break;

    case "VariableDeclaration":
      let varId = node.id;
      debug("Variable declaration case");
      debug("currentDepth %d varId %d", currentDepth, varId);

      //NOTE: We're going to make the assignment conditional here; here's why.
      //There's a bug where calling the autogenerated accessor for a public
      //contract variable causes the debugger to see two additional
      //declarations for that variable... which this code reads as local
      //variable declarations.  Rather than prevent this at the source, we're
      //just going to check for it here, by not adding a local variable if said
      //variable is already a contract variable.

      if (currentAssignments.byAstId[varId] !== undefined && currentAssignments.byAstId[varId].some(id => currentAssignments.byId[id].address !== undefined)) {
        break;
      }

      //otherwise, go ahead and make the assignment
      assignment = (0, _helpers.makeAssignment)({ astId: varId, stackframe: currentDepth }, {
        stack: {
          from: top - DecodeUtils.Definition.stackSize(node) + 1,
          to: top
        }
      });
      assignments = { [assignment.id]: assignment };
      //this case doesn't need preambleAssignments either
      yield (0, _effects.put)(actions.assign(assignments));
      break;

    case "IndexAccess":
      // to track `mapping` types known indices
      // (and also *some* known indices for arrays)

      //HACK: we use the alternate stack in this case

      debug("Index access case");

      //we're going to start by doing the same thing as in the default case
      //(see below) -- getting things ready for an assignment.  Then we're
      //going to forget this for a bit while we handle the rest...
      assignments = (0, _extends3.default)({}, preambleAssignments, literalAssignments(node, alternateStack, currentDepth));

      //we'll need this
      baseExpression = node.baseExpression;

      //but first, a diversion -- is this something that could not *possibly*
      //lead to a mapping?  i.e., either a bytes, or an array of non-reference
      //types, or a non-storage array?
      //if so, we'll just do the assign and quit out early
      //(note: we write it this way because mappings aren't caught by
      //isReference)
      if (DecodeUtils.Definition.typeClass(baseExpression) === "bytes" || DecodeUtils.Definition.typeClass(baseExpression) === "array" && (DecodeUtils.Definition.isReference(node) ? DecodeUtils.Definition.referenceType(baseExpression) !== "storage" : !DecodeUtils.Definition.isMapping(node))) {
        debug("Index case bailed out early");
        debug("typeClass %s", DecodeUtils.Definition.typeClass(baseExpression));
        debug("referenceType %s", DecodeUtils.Definition.referenceType(baseExpression));
        debug("isReference(node) %o", DecodeUtils.Definition.isReference(node));
        yield (0, _effects.put)(actions.assign(assignments));
        break;
      }

      let keyDefinition = DecodeUtils.Definition.keyDefinition(baseExpression, scopes);
      //if we're dealing with an array, this will just hack up a uint definition
      //:)

      //begin subsection: key decoding
      //(I tried factoring this out into its own saga but it didn't work when I
      //did :P )
      yield (0, _effects.put)(actions.mapKeyDecoding(true));

      let indexValue;
      let indexDefinition = node.indexExpression;

      //why the loop? see the end of the block it heads for an explanatory
      //comment
      while (indexValue === undefined) {
        let indexId = indexDefinition.id;
        //indices need to be identified by stackframe
        let indexIdObj = { astId: indexId, stackframe: currentDepth };
        let fullIndexId = (0, _helpers.stableKeccak256)(indexIdObj);

        const indexReference = (currentAssignments.byId[fullIndexId] || {}).ref;

        if (DecodeUtils.Definition.isSimpleConstant(indexDefinition)) {
          //while the main case is the next one, where we look for a prior
          //assignment, we need this case (and need it first) for two reasons:
          //1. some constant expressions (specifically, string and hex literals)
          //aren't sourcemapped to and so won't have a prior assignment
          //2. if the key type is bytesN but the expression is constant, the
          //value will go on the stack *left*-padded instead of right-padded,
          //so looking for a prior assignment will read the wrong value.
          //so instead it's preferable to use the constant directly.
          indexValue = yield (0, _effects.call)(decode, keyDefinition, {
            definition: indexDefinition
          });
        } else if (indexReference) {
          //if a prior assignment is found
          let splicedDefinition;
          //in general, we want to decode using the key definition, not the index
          //definition. however, the key definition may have the wrong location
          //on it.  so, when applicable, we splice the index definition location
          //onto the key definition location.
          if (DecodeUtils.Definition.isReference(indexDefinition)) {
            splicedDefinition = DecodeUtils.Definition.spliceLocation(keyDefinition, DecodeUtils.Definition.referenceType(indexDefinition));
            //we could put code here to add on the "_ptr" ending when absent,
            //but we presently ignore that ending, so we'll skip that
          } else {
            splicedDefinition = keyDefinition;
          }
          indexValue = yield (0, _effects.call)(decode, splicedDefinition, indexReference);
        } else if (indexDefinition.referencedDeclaration && scopes[indexDefinition.referenceDeclaration]) {
          //there's one more reason we might have failed to decode it: it might be a
          //constant state variable.  Unfortunately, we don't know how to decode all
          //those at the moment, but we can handle the ones we do know how to decode.
          //In the future hopefully we will decode all of them
          debug("referencedDeclaration %d", indexDefinition.referencedDeclaration);
          let indexConstantDeclaration = scopes[indexDefinition.referencedDeclaration].definition;
          debug("indexConstantDeclaration %O", indexConstantDeclaration);
          if (indexConstantDeclaration.constant) {
            let indexConstantDefinition = indexConstantDeclaration.value;
            //next line filters out constants we don't know how to handle
            if (DecodeUtils.Definition.isSimpleConstant(indexConstantDefinition)) {
              indexValue = yield (0, _effects.call)(decode, keyDefinition, {
                definition: indexConstantDeclaration.value
              });
            }
          }
        }
        //there's still one more reason we might have failed to decode it:
        //certain (silent) type conversions aren't sourcemapped either.
        //(thankfully, any type conversion that actually *does* something seems
        //to be sourcemapped.)  So if we've failed to decode it, we try again
        //with the argument of the type conversion, if it is one; we leave
        //indexValue undefined so the loop will continue
        //(note that this case is last for a reason; if this were earlier, it
        //would catch *non*-silent type conversions, which we want to just read
        //off the stack)
        else if (indexDefinition.kind === "typeConversion") {
            indexDefinition = indexDefinition.arguments[0];
          }
          //otherwise, we've just totally failed to decode it, so we mark
          //indexValue as null (as distinct from undefined) to indicate this.  In
          //the future, we should be able to decode all mapping keys, but we're
          //not quite there yet, sorry (because we can't yet handle all constant
          //state variables)
          else {
              indexValue = null;
            }
        //now, as mentioned, retry in the typeConversion case
      }

      yield (0, _effects.put)(actions.mapKeyDecoding(false));
      //end subsection: key decoding

      debug("index value %O", indexValue);
      debug("keyDefinition %o", keyDefinition);

      //whew! But we're not done yet -- we need to turn this decoded key into
      //an actual path (assuming we *did* decode it)
      //OK, not an actual path -- we're just going to use a simple offset for
      //the path.  But that's OK, because the mappedPaths reducer will turn
      //it into an actual path.
      if (indexValue !== null) {
        path = fetchBasePath(baseExpression, mappedPaths, currentAssignments, currentDepth);

        let slot = { path };

        //we need to do things differently depending on whether we're dealing
        //with an array or mapping
        switch (DecodeUtils.Definition.typeClass(baseExpression)) {
          case "array":
            slot.hashPath = DecodeUtils.Definition.isDynamicArray(baseExpression);
            slot.offset = indexValue.muln((0, _truffleDecoder.storageSize)(node, referenceDeclarations, allocations).words);
            break;
          case "mapping":
            slot.key = indexValue;
            slot.keyEncoding = DecodeUtils.Definition.keyEncoding(keyDefinition);
            slot.offset = new _bn2.default(0);
            break;
          default:
            debug("unrecognized index access!");
        }
        debug("slot %O", slot);

        //now, map it! (and do the assign as well)
        yield (0, _effects.put)(actions.mapPathAndAssign(address, slot, assignments, DecodeUtils.Definition.typeIdentifier(node), DecodeUtils.Definition.typeIdentifier(baseExpression)));
      } else {
        //if we failed to decode, just do the assign from above
        debug("failed to decode, just assigning");
        yield (0, _effects.put)(actions.assign(assignments));
      }

      break;

    case "MemberAccess":
      //HACK: we use the alternate stack in this case

      //we're going to start by doing the same thing as in the default case
      //(see below) -- getting things ready for an assignment.  Then we're
      //going to forget this for a bit while we handle the rest...
      assignments = (0, _extends3.default)({}, preambleAssignments, literalAssignments(node, alternateStack, currentDepth));

      debug("Member access case");

      //MemberAccess uses expression, not baseExpression
      baseExpression = node.expression;

      //if this isn't a storage struct, or the element isn't of reference type,
      //we'll just do the assignment and quit out (again, note that mappings
      //aren't caught by isReference)
      if (DecodeUtils.Definition.typeClass(baseExpression) !== "struct" || (DecodeUtils.Definition.isReference(node) ? DecodeUtils.Definition.referenceType(baseExpression) !== "storage" : !DecodeUtils.Definition.isMapping(node))) {
        debug("Member case bailed out early");
        yield (0, _effects.put)(actions.assign(assignments));
        break;
      }

      //but if it is a storage struct, we have to map the path as well
      path = fetchBasePath(baseExpression, mappedPaths, currentAssignments, currentDepth);

      slot = { path };

      let structId = DecodeUtils.Definition.typeId(baseExpression);
      let memberAllocation = allocations[structId].members[node.referencedDeclaration];

      slot.offset = memberAllocation.pointer.storage.from.slot.offset.clone();

      debug("slot %o", slot);
      yield (0, _effects.put)(actions.mapPathAndAssign(address, slot, assignments, DecodeUtils.Definition.typeIdentifier(node), DecodeUtils.Definition.typeIdentifier(baseExpression)));

    default:
      if (node.typeDescriptions == undefined) {
        break;
      }

      debug("decoding expression value %O", node.typeDescriptions);
      debug("default case");
      debug("currentDepth %d node.id %d", currentDepth, node.id);

      assignments = (0, _extends3.default)({}, preambleAssignments, literalAssignments(node, stack, currentDepth));
      yield (0, _effects.put)(actions.assign(assignments));
      break;
  }
}

function* reset() {
  yield (0, _effects.put)(actions.reset());
}

function* recordAllocations() {
  const contracts = yield (0, _effects.select)(_selectors2.default.views.userDefinedTypes.contractDefinitions);
  debug("contracts %O", contracts);
  const referenceDeclarations = yield (0, _effects.select)(_selectors2.default.views.referenceDeclarations);
  debug("referenceDeclarations %O", referenceDeclarations);
  const storageAllocations = (0, _truffleDecoder.getStorageAllocations)(referenceDeclarations, contracts);
  debug("storageAllocations %O", storageAllocations);
  const memoryAllocations = (0, _truffleDecoder.getMemoryAllocations)(referenceDeclarations);
  const calldataAllocations = (0, _truffleDecoder.getCalldataAllocations)(referenceDeclarations);
  yield (0, _effects.put)(actions.allocate(storageAllocations, memoryAllocations, calldataAllocations));
}

function literalAssignments(node, stack, currentDepth) {
  let top = stack.length - 1;

  let literal = (0, _truffleDecoder.readStack)(stack, top - DecodeUtils.Definition.stackSize(node) + 1, top);

  let assignment = (0, _helpers.makeAssignment)({ astId: node.id, stackframe: currentDepth }, { literal });

  return { [assignment.id]: assignment };
}

//takes a parameter list as given in the AST
function assignParameters(parameters, top, functionDepth) {
  let reverseParameters = parameters.slice().reverse();
  //reverse is in-place, so we use slice() to clone first
  debug("reverseParameters %o", parameters);

  let currentPosition = top;
  let assignments = {};

  for (let parameter of reverseParameters) {
    let words = DecodeUtils.Definition.stackSize(parameter);
    let pointer = {
      stack: {
        from: currentPosition - words + 1,
        to: currentPosition
      }
    };
    let assignment = (0, _helpers.makeAssignment)({ astId: parameter.id, stackframe: functionDepth }, pointer);
    assignments[assignment.id] = assignment;
    currentPosition -= words;
  }
  return assignments;
}

function fetchBasePath(baseNode, mappedPaths, currentAssignments, currentDepth) {
  let fullId = (0, _helpers.stableKeccak256)({
    astId: baseNode.id,
    stackframe: currentDepth
  });
  //base expression is an expression, and so has a literal assigned to
  //it
  let offset = DecodeUtils.Conversion.toBN(currentAssignments.byId[fullId].ref.literal);
  return { offset };
}

function* saga() {
  yield (0, _effects.takeEvery)(_actions.TICK, tickSaga);
}

exports.default = (0, _helpers.prefixName)("data", saga);

/***/ }),
/* 25 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/set");

/***/ }),
/* 26 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/promise");

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = __webpack_require__(21);

var _keys2 = _interopRequireDefault(_keys);

exports.getRange = getRange;
exports.rangeNodes = rangeNodes;
exports.findOverlappingRange = findOverlappingRange;
exports.findRange = findRange;
exports.anyNonSkippedInRange = anyNonSkippedInRange;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _nodeIntervalTree = __webpack_require__(50);

var _nodeIntervalTree2 = _interopRequireDefault(_nodeIntervalTree);

var _jsonPointer = __webpack_require__(20);

var _jsonPointer2 = _interopRequireDefault(_jsonPointer);

var _helpers = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:ast:map");

/**
 * @private
 */
function getRange(node) {
  // src: "<start>:<length>:<_>"
  // returns [start, end]
  let [start, length] = node.src.split(":").slice(0, 2).map(i => parseInt(i));

  return [start, start + length];
}

/**
 * @private
 */
function rangeNodes(node, pointer = "") {
  if (node instanceof Array) {
    return [].concat(...node.map((sub, i) => rangeNodes(sub, `${pointer}/${i}`)));
  } else if (node instanceof Object) {
    let results = [];

    if (node.src) {
      results.push({ pointer, range: getRange(node) });
    }

    return results.concat(...(0, _keys2.default)(node).map(key => rangeNodes(node[key], `${pointer}/${key}`)));
  } else {
    return [];
  }
}

/**
 * @private
 */
function findOverlappingRange(node, sourceStart, sourceLength) {
  let ranges = rangeNodes(node);
  let tree = new _nodeIntervalTree2.default();

  ranges.forEach(({ range, pointer }) => {
    let [start, end] = range;

    tree.insert(start, end, { range, pointer });
  });

  let sourceEnd = sourceStart + sourceLength;

  return tree.search(sourceStart, sourceEnd);
  //returns everything overlapping the given range
}

/**
 * @private
 */
function findRange(node, sourceStart, sourceLength) {
  // find nodes that fully contain requested range,
  // return longest pointer
  let sourceEnd = sourceStart + sourceLength;
  return findOverlappingRange(node, sourceStart, sourceLength).filter(({ range }) => sourceStart >= range[0] && sourceEnd <= range[1]).map(({ pointer }) => pointer).reduce((a, b) => a.length > b.length ? a : b, "");
}

/**
 * @private
 */
function anyNonSkippedInRange(node, sourceStart, sourceLength) {
  let sourceEnd = sourceStart + sourceLength;
  return findOverlappingRange(node, sourceStart, sourceLength).some(({ range, pointer }) => sourceStart <= range[0] && //we want to go by starting line
  range[0] < sourceEnd && !(0, _helpers.isSkippedNodeType)(_jsonPointer2.default.get(node, pointer))
  //NOTE: this doesn't actually catch everything skipped!  But doing better
  //is hard
  );
}

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.scope = scope;
exports.declare = declare;
exports.assign = assign;
exports.mapPathAndAssign = mapPathAndAssign;
exports.mapKeyDecoding = mapKeyDecoding;
exports.reset = reset;
exports.defineType = defineType;
exports.allocate = allocate;
const SCOPE = exports.SCOPE = "SCOPE";
function scope(id, pointer, parentId, sourceId) {
  return {
    type: SCOPE,
    id,
    pointer,
    parentId,
    sourceId
  };
}

const DECLARE = exports.DECLARE = "DECLARE_VARIABLE";
function declare(node) {
  return {
    type: DECLARE,
    node
  };
}

const ASSIGN = exports.ASSIGN = "ASSIGN";
function assign(assignments) {
  return {
    type: ASSIGN,
    assignments
  };
}

const MAP_PATH_AND_ASSIGN = exports.MAP_PATH_AND_ASSIGN = "MAP_PATH_AND_ASSIGN";
function mapPathAndAssign(address, slot, assignments, typeIdentifier, parentType) {
  return {
    type: MAP_PATH_AND_ASSIGN,
    address,
    slot,
    assignments,
    typeIdentifier,
    parentType
  };
}

const MAP_KEY_DECODING = exports.MAP_KEY_DECODING = "MAP_KEY_DECODING";
function mapKeyDecoding(started) {
  return {
    type: MAP_KEY_DECODING,
    started
  };
}

const RESET = exports.RESET = "DATA_RESET";
function reset() {
  return { type: RESET };
}

const DEFINE_TYPE = exports.DEFINE_TYPE = "DEFINE_TYPE";
function defineType(node) {
  return {
    type: DEFINE_TYPE,
    node
  };
}

const ALLOCATE = exports.ALLOCATE = "ALLOCATE";
function allocate(storage, memory, calldata) {
  return {
    type: ALLOCATE,
    storage,
    memory,
    calldata
  };
}

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(3);

var _selectors = __webpack_require__(10);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:ast:selectors");

/**
 * ast
 */
const ast = (0, _reselectTree.createSelectorTree)({
  /**
   * ast.views
   */
  views: {
    /**
     * ast.views.sources
     */
    sources: (0, _reselectTree.createLeaf)([_selectors2.default.info.sources], sources => sources)
  }
});

exports.default = ast;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addContext = addContext;
exports.normalizeContexts = normalizeContexts;
exports.addInstance = addInstance;
exports.begin = begin;
exports.callstackAndCodexSaga = callstackAndCodexSaga;
exports.reset = reset;
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(5);

var _helpers = __webpack_require__(1);

var _actions = __webpack_require__(13);

var _actions2 = __webpack_require__(31);

var actions = _interopRequireWildcard(_actions2);

var _selectors = __webpack_require__(9);

var _selectors2 = _interopRequireDefault(_selectors);

var _sagas = __webpack_require__(14);

var trace = _interopRequireWildcard(_sagas);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:evm:sagas");

/**
 * Adds EVM bytecode context
 *
 * @return {string} ID (0x-prefixed keccak of binary)
 */
function* addContext(context) {
  const contextHash = (0, _helpers.keccak256)({ type: "string", value: context.binary });
  //NOTE: we take hash as *string*, not as bytes, because the binary may
  //contain link references!

  debug("context %O", context);
  yield (0, _effects.put)(actions.addContext(context));

  return contextHash;
}

function* normalizeContexts() {
  yield (0, _effects.put)(actions.normalizeContexts());
}

/**
 * Adds known deployed instance of binary at address
 *
 * @param {string} binary - may be undefined (e.g. precompiles)
 * @return {string} ID (0x-prefixed keccak of binary)
 */
function* addInstance(address, binary) {
  let search = yield (0, _effects.select)(_selectors2.default.info.binaries.search);
  let context = search(binary);

  // in case binary is unknown, add a context for it
  if (context === null) {
    context = yield* addContext({
      binary,
      isConstructor: false
      //addInstance is only used for adding deployed instances, so it will
      //never be a constructor
    });
  }

  //now, whether we needed a new context or not, add the instance
  yield (0, _effects.put)(actions.addInstance(address, context, binary));

  return context;
}

function* begin({
  address,
  binary,
  data,
  storageAddress,
  sender,
  value,
  gasprice,
  block
}) {
  yield (0, _effects.put)(actions.saveGlobals(sender, gasprice, block));
  if (address) {
    yield (0, _effects.put)(actions.call(address, data, storageAddress, sender, value));
  } else {
    yield (0, _effects.put)(actions.create(binary, storageAddress, sender, value));
  }
}

function* tickSaga() {
  debug("got TICK");

  yield* callstackAndCodexSaga();
  yield* trace.signalTickSagaCompletion();
}

function* callstackAndCodexSaga() {
  if (yield (0, _effects.select)(_selectors2.default.current.step.isExceptionalHalting)) {
    //let's handle this case first so we can be sure everything else is *not*
    //an exceptional halt
    debug("exceptional halt!");

    yield (0, _effects.put)(actions.fail());
  } else if (yield (0, _effects.select)(_selectors2.default.current.step.isCall)) {
    debug("got call");
    // if there is no binary (e.g. in the case of precompiled contracts or
    // externally owned accounts), then there will be no trace steps for the
    // called code, and so we shouldn't tell the debugger that we're entering
    // another execution context
    if (yield (0, _effects.select)(_selectors2.default.current.step.callsPrecompileOrExternal)) {
      return;
    }

    let address = yield (0, _effects.select)(_selectors2.default.current.step.callAddress);
    let data = yield (0, _effects.select)(_selectors2.default.current.step.callData);

    debug("calling address %s", address);

    if (yield (0, _effects.select)(_selectors2.default.current.step.isDelegateCallStrict)) {
      //if delegating, leave storageAddress, sender, and value the same
      let { storageAddress, sender, value } = yield (0, _effects.select)(_selectors2.default.current.call);
      yield (0, _effects.put)(actions.call(address, data, storageAddress, sender, value));
    } else {
      //this branch covers CALL, CALLCODE, and STATICCALL
      let currentCall = yield (0, _effects.select)(_selectors2.default.current.call);
      let storageAddress = (yield (0, _effects.select)(_selectors2.default.current.step.isDelegateCallBroad)) ? currentCall.storageAddress //for CALLCODE
      : address;
      let sender = currentCall.storageAddress; //not the code address!
      let value = yield (0, _effects.select)(_selectors2.default.current.step.callValue); //0 if static
      yield (0, _effects.put)(actions.call(address, data, storageAddress, sender, value));
    }
  } else if (yield (0, _effects.select)(_selectors2.default.current.step.isCreate)) {
    debug("got create");
    let binary = yield (0, _effects.select)(_selectors2.default.current.step.createBinary);
    let createdAddress = yield (0, _effects.select)(_selectors2.default.current.step.createdAddress);
    let value = yield (0, _effects.select)(_selectors2.default.current.step.createValue);
    let sender = (yield (0, _effects.select)(_selectors2.default.current.call)).storageAddress;
    //not the code address!

    yield (0, _effects.put)(actions.create(binary, createdAddress, sender, value));
    //as above, storageAddress handles when calling from a creation call
  } else if (yield (0, _effects.select)(_selectors2.default.current.step.isHalting)) {
    debug("got return");

    yield (0, _effects.put)(actions.returnCall());
  } else if (yield (0, _effects.select)(_selectors2.default.current.step.touchesStorage)) {
    let storageAddress = (yield (0, _effects.select)(_selectors2.default.current.call)).storageAddress;
    let slot = yield (0, _effects.select)(_selectors2.default.current.step.storageAffected);
    //note we get next storage, since we're updating to that
    let storage = yield (0, _effects.select)(_selectors2.default.next.state.storage);
    //normally we'd need a 0 fallback for this next line, but in this case we
    //can be sure the value will be there, since we're touching that storage
    if (yield (0, _effects.select)(_selectors2.default.current.step.isStore)) {
      yield (0, _effects.put)(actions.store(storageAddress, slot, storage[slot]));
    } else {
      //otherwise, it's a load
      yield (0, _effects.put)(actions.load(storageAddress, slot, storage[slot]));
    }
  }
}

function* reset() {
  let initialAddress = (yield (0, _effects.select)(_selectors2.default.current.callstack))[0].storageAddress;
  yield (0, _effects.put)(actions.reset(initialAddress));
}

function* saga() {
  yield (0, _effects.takeEvery)(_actions.TICK, tickSaga);
}

exports.default = (0, _helpers.prefixName)("evm", saga);

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addContext = addContext;
exports.normalizeContexts = normalizeContexts;
exports.addInstance = addInstance;
exports.saveGlobals = saveGlobals;
exports.call = call;
exports.create = create;
exports.returnCall = returnCall;
exports.fail = fail;
exports.store = store;
exports.load = load;
exports.reset = reset;
const ADD_CONTEXT = exports.ADD_CONTEXT = "EVM_ADD_CONTEXT";
function addContext({
  contractName,
  binary,
  sourceMap,
  compiler,
  abi,
  contractId,
  contractKind,
  isConstructor
}) {
  return {
    type: ADD_CONTEXT,
    contractName,
    binary,
    sourceMap,
    compiler,
    abi,
    contractId,
    contractKind,
    isConstructor
  };
}

const NORMALIZE_CONTEXTS = exports.NORMALIZE_CONTEXTS = "EVM_NORMALIZE_CONTEXTS";
function normalizeContexts() {
  return { type: NORMALIZE_CONTEXTS };
}

const ADD_INSTANCE = exports.ADD_INSTANCE = "EVM_ADD_INSTANCE";
function addInstance(address, context, binary) {
  return {
    type: ADD_INSTANCE,
    address,
    context,
    binary
  };
}

const SAVE_GLOBALS = exports.SAVE_GLOBALS = "SAVE_GLOBALS";
function saveGlobals(origin, gasprice, block) {
  return {
    type: SAVE_GLOBALS,
    origin,
    gasprice,
    block
  };
}

const CALL = exports.CALL = "CALL";
function call(address, data, storageAddress, sender, value) {
  return {
    type: CALL,
    address,
    data,
    storageAddress,
    sender,
    value
  };
}

const CREATE = exports.CREATE = "CREATE";
function create(binary, storageAddress, sender, value) {
  return {
    type: CREATE,
    binary,
    storageAddress,
    sender,
    value
  };
}

const RETURN = exports.RETURN = "RETURN";
function returnCall() {
  return {
    type: RETURN
  };
}

const FAIL = exports.FAIL = "FAIL";
function fail() {
  return {
    type: FAIL
  };
}

const STORE = exports.STORE = "STORE";
function store(address, slot, value) {
  return {
    type: STORE,
    address,
    slot,
    value
  };
}

const LOAD = exports.LOAD = "LOAD";
function load(address, slot, value) {
  return {
    type: LOAD,
    address,
    slot,
    value
  };
}

const RESET = exports.RESET = "EVM_RESET";
function reset(storageAddress) {
  return {
    type: RESET,
    storageAddress
  };
}

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addSource = addSource;
exports.reset = reset;
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(5);

var _helpers = __webpack_require__(1);

var _actions = __webpack_require__(33);

var actions = _interopRequireWildcard(_actions);

var _actions2 = __webpack_require__(13);

var _sagas = __webpack_require__(14);

var trace = _interopRequireWildcard(_sagas);

var _selectors = __webpack_require__(10);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:solidity:sagas");

function* addSource(source, sourcePath, ast, compiler) {
  yield (0, _effects.put)(actions.addSource(source, sourcePath, ast, compiler));
}

function* tickSaga() {
  debug("got TICK");

  yield* functionDepthSaga();
  yield* trace.signalTickSagaCompletion();
}

function* functionDepthSaga() {
  if (yield (0, _effects.select)(_selectors2.default.current.willFail)) {
    //we do this case first so we can be sure we're not failing in any of the
    //other cases below!
    yield (0, _effects.put)(actions.externalReturn());
  } else if (yield (0, _effects.select)(_selectors2.default.current.willJump)) {
    let jumpDirection = yield (0, _effects.select)(_selectors2.default.current.jumpDirection);
    yield (0, _effects.put)(actions.jump(jumpDirection));
  } else if (yield (0, _effects.select)(_selectors2.default.current.willCall)) {
    debug("about to call");
    if (yield (0, _effects.select)(_selectors2.default.current.callsPrecompileOrExternal)) {
      //call to precompile or externally-owned account; do nothing
    } else {
      yield (0, _effects.put)(actions.externalCall());
    }
  } else if (yield (0, _effects.select)(_selectors2.default.current.willCreate)) {
    yield (0, _effects.put)(actions.externalCall());
  } else if (yield (0, _effects.select)(_selectors2.default.current.willReturn)) {
    yield (0, _effects.put)(actions.externalReturn());
  }
}

function* reset() {
  yield (0, _effects.put)(actions.reset());
}

function* saga() {
  yield (0, _effects.takeEvery)(_actions2.TICK, tickSaga);
}

exports.default = (0, _helpers.prefixName)("solidity", saga);

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addSource = addSource;
exports.jump = jump;
exports.externalCall = externalCall;
exports.externalReturn = externalReturn;
exports.reset = reset;
const ADD_SOURCE = exports.ADD_SOURCE = "SOLIDITY_ADD_SOURCE";
function addSource(source, sourcePath, ast, compiler) {
  return {
    type: ADD_SOURCE,
    source,
    sourcePath,
    ast,
    compiler
  };
}

const JUMP = exports.JUMP = "JUMP";
function jump(jumpDirection) {
  return {
    type: JUMP,
    jumpDirection
  };
}

const EXTERNAL_CALL = exports.EXTERNAL_CALL = "EXTERNAL_CALL";
function externalCall() {
  return { type: EXTERNAL_CALL };
}

const EXTERNAL_RETURN = exports.EXTERNAL_RETURN = "EXTERNAL_RETURN";
function externalReturn() {
  return { type: EXTERNAL_RETURN };
}

const RESET = exports.RESET = "SOLIDITY_RESET";
function reset() {
  return { type: RESET };
}

/***/ }),
/* 34 */
/***/ (function(module, exports) {

module.exports = require("web3");

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

var Debugger = __webpack_require__(36).default;

module.exports = Debugger;



/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _asyncToGenerator2 = __webpack_require__(15);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _truffleExpect = __webpack_require__(37);

var _truffleExpect2 = _interopRequireDefault(_truffleExpect);

var _session = __webpack_require__(38);

var _session2 = _interopRequireDefault(_session);

var _reselectTree = __webpack_require__(3);

var _selectors = __webpack_require__(19);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(29);

var _selectors4 = _interopRequireDefault(_selectors3);

var _selectors5 = __webpack_require__(12);

var _selectors6 = _interopRequireDefault(_selectors5);

var _selectors7 = __webpack_require__(9);

var _selectors8 = _interopRequireDefault(_selectors7);

var _selectors9 = __webpack_require__(10);

var _selectors10 = _interopRequireDefault(_selectors9);

var _selectors11 = __webpack_require__(68);

var _selectors12 = _interopRequireDefault(_selectors11);

var _selectors13 = __webpack_require__(23);

var _selectors14 = _interopRequireDefault(_selectors13);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger");

/**
 * @example
 * let session = Debugger
 *   .forTx(<txHash>, {
 *     contracts: [<contract obj>, ...],
 *     provider: <provider instance>
 *   })
 *   .connect();
 */
class Debugger {
  /**
   * @param {Session} session - debugger session
   * @private
   */
  constructor(session) {
    /**
     * @private
     */
    this._session = session;
  }

  /**
   * Instantiates a Debugger for a given transaction hash.
   *
   * @param {String} txHash - transaction hash with leading "0x"
   * @param {{contracts: Array<Contract>, files: Array<String>, provider: Web3Provider}} options -
   * @return {Debugger} instance
   */
  static forTx(txHash, options = {}) {
    var _this = this;

    return (0, _asyncToGenerator3.default)(function* () {
      _truffleExpect2.default.options(options, ["contracts", "provider"]);

      let session = new _session2.default(options.contracts, options.files, txHash, options.provider);

      try {
        yield session.ready();
      } catch (e) {
        throw e;
      }

      return new _this(session);
    })();
  }

  /**
   * Connects to the instantiated Debugger.
   *
   * @return {Session} session instance
   */
  connect() {
    return this._session;
  }

  /**
   * Exported selectors
   *
   * See individual selector docs for full listing
   *
   * @example
   * Debugger.selectors.ast.current.tree
   *
   * @example
   * Debugger.selectors.solidity.current.instruction
   *
   * @example
   * Debugger.selectors.trace.steps
   */
  static get selectors() {
    return (0, _reselectTree.createNestedSelector)({
      ast: _selectors4.default,
      data: _selectors2.default,
      trace: _selectors6.default,
      evm: _selectors8.default,
      solidity: _selectors10.default,
      session: _selectors12.default,
      controller: _selectors14.default
    });
  }
}

exports.default = Debugger; /**
                             * @typedef {Object} Contract
                             * @property {string} contractName contract name
                             * @property {string} source solidity source code
                             * @property {string} sourcePath path to source file
                             * @property {string} binary 0x-prefixed hex string with create bytecode
                             * @property {string} sourceMap solidity source map for create bytecode
                             * @property {Object} ast Abstract Syntax Tree from Solidity
                             * @property {string} deployedBinary 0x-prefixed compiled binary (on chain)
                             * @property {string} deployedSourceMap solidity source map for on-chain bytecode
                             */

/***/ }),
/* 37 */
/***/ (function(module, exports) {

module.exports = require("truffle-expect");

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _values = __webpack_require__(11);

var _values2 = _interopRequireDefault(_values);

var _promise = __webpack_require__(26);

var _promise2 = _interopRequireDefault(_promise);

var _asyncToGenerator2 = __webpack_require__(15);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _store = __webpack_require__(39);

var _store2 = _interopRequireDefault(_store);

var _actions = __webpack_require__(18);

var controller = _interopRequireWildcard(_actions);

var _actions2 = __webpack_require__(16);

var actions = _interopRequireWildcard(_actions2);

var _selectors = __webpack_require__(19);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(23);

var _selectors4 = _interopRequireDefault(_selectors3);

var _sagas = __webpack_require__(52);

var _sagas2 = _interopRequireDefault(_sagas);

var _reducers = __webpack_require__(60);

var _reducers2 = _interopRequireDefault(_reducers);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:session");

/**
 * Debugger Session
 */
class Session {
  /**
   * @param {Array<Contract>} contracts - contract definitions
   * @param {Array<String>} files - array of filenames for sourceMap indexes
   * @param {string} txHash - transaction hash
   * @param {Web3Provider} provider - web3 provider
   * @private
   */
  constructor(contracts, files, txHash, provider) {
    /**
     * @private
     */
    this._store = (0, _store2.default)(_reducers2.default, _sagas2.default);

    let { contexts, sources } = Session.normalize(contracts, files);

    // record contracts
    this._store.dispatch(actions.recordContracts(contexts, sources));

    this._store.dispatch(actions.start(txHash, provider));
  }

  ready() {
    var _this = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return new _promise2.default(function (accept, reject) {
        _this._store.subscribe(function () {
          if (_this.state.session.status == "ACTIVE") {
            accept();
          } else if (typeof _this.state.session.status == "object") {
            reject(_this.state.session.status.error);
          }
        });
      });
    })();
  }

  /**
   * Split up artifacts into "contexts" and "sources", dividing artifact
   * data into appropriate buckets.
   *
   * Multiple contracts can be defined in the same source file, but have
   * different bytecodes.
   *
   * This iterates over the contracts and collects binaries separately
   * from sources, using the optional `files` argument to force
   * source ordering.
   * @private
   */
  static normalize(contracts, files = null) {
    let sourcesByPath = {};
    let contexts = [];
    let sources;

    for (let contract of contracts) {
      let {
        contractName,
        binary,
        sourceMap,
        deployedBinary,
        deployedSourceMap,
        sourcePath,
        source,
        ast,
        abi,
        compiler
      } = contract;

      let contractNode = ast.nodes.find(node => node.nodeType === "ContractDefinition" && node.name === contractName); //ideally we'd hold this off till later, but that would break the
      //direction of the evm/solidity dependence, so we do it now

      let contractId = contractNode.id;
      let contractKind = contractNode.contractKind;

      debug("contractName %s", contractName);
      debug("sourceMap %o", sourceMap);
      debug("compiler %o", compiler);
      debug("abi %O", abi);

      sourcesByPath[sourcePath] = { sourcePath, source, ast, compiler };

      if (binary && binary != "0x") {
        contexts.push({
          contractName,
          binary,
          sourceMap,
          abi,
          compiler,
          contractId,
          contractKind,
          isConstructor: true
        });
      }

      if (deployedBinary && deployedBinary != "0x") {
        contexts.push({
          contractName,
          binary: deployedBinary,
          sourceMap: deployedSourceMap,
          abi,
          compiler,
          contractId,
          contractKind,
          isConstructor: false
        });
      }
    }

    if (!files) {
      sources = (0, _values2.default)(sourcesByPath);
    } else {
      sources = files.map(file => sourcesByPath[file]);
    }

    return { contexts, sources };
  }

  get state() {
    return this._store.getState();
  }

  view(selector) {
    return selector(this.state);
  }

  dispatch(action) {
    var _this2 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      _this2._store.dispatch(action);

      return true;
    })();
  }

  interrupt() {
    var _this3 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return _this3.dispatch(controller.interrupt());
    })();
  }

  doneStepping(stepperAction) {
    var _this4 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return new _promise2.default(function (resolve) {
        let hasStarted = false;
        let hasResolved = false;
        const unsubscribe = _this4._store.subscribe(function () {
          const isStepping = _this4.view(_selectors4.default.isStepping);

          if (isStepping && !hasStarted) {
            hasStarted = true;
            debug("heard step start");
            return;
          }

          if (!isStepping && hasStarted && !hasResolved) {
            hasResolved = true;
            debug("heard step stop");
            unsubscribe();
            resolve(true);
          }
        });
        _this4.dispatch(stepperAction);
      });
    })();
  }

  //Note: count is an optional argument; default behavior is to advance 1
  advance(count) {
    var _this5 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return yield _this5.doneStepping(controller.advance(count));
    })();
  }

  stepNext() {
    var _this6 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return yield _this6.doneStepping(controller.stepNext());
    })();
  }

  stepOver() {
    var _this7 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return yield _this7.doneStepping(controller.stepOver());
    })();
  }

  stepInto() {
    var _this8 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return yield _this8.doneStepping(controller.stepInto());
    })();
  }

  stepOut() {
    var _this9 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return yield _this9.doneStepping(controller.stepOut());
    })();
  }

  reset() {
    var _this10 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return yield _this10.doneStepping(controller.reset());
    })();
  }

  //NOTE: breakpoints is an OPTIONAL argument for if you want to supply your
  //own list of breakpoints; leave it out to use the internal one (as
  //controlled by the functions below)
  continueUntilBreakpoint(breakpoints) {
    var _this11 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return yield _this11.doneStepping(controller.continueUntilBreakpoint(breakpoints));
    })();
  }

  addBreakpoint(breakpoint) {
    var _this12 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      _this12.dispatch(controller.addBreakpoint(breakpoint));
    })();
  }

  removeBreakpoint(breakpoint) {
    var _this13 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return _this13.dispatch(controller.removeBreakpoint(breakpoint));
    })();
  }

  removeAllBreakpoints() {
    var _this14 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return _this14.dispatch(controller.removeAllBreakpoints());
    })();
  }

  decodeReady() {
    var _this15 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return new _promise2.default(function (resolve) {
        let haveResolved = false;
        const unsubscribe = _this15._store.subscribe(function () {
          const subscriptionDecodingStarted = _this15.view(_selectors2.default.proc.decodingKeys);

          debug("following decoding started: %d", subscriptionDecodingStarted);

          if (subscriptionDecodingStarted <= 0 && !haveResolved) {
            haveResolved = true;
            unsubscribe();
            resolve();
          }
        });

        const decodingStarted = _this15.view(_selectors2.default.proc.decodingKeys);

        debug("initial decoding started: %d", decodingStarted);

        if (decodingStarted <= 0) {
          haveResolved = true;
          unsubscribe();
          resolve();
        }
      });
    })();
  }

  variable(name) {
    var _this16 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      yield _this16.decodeReady();

      const definitions = _this16.view(_selectors2.default.current.identifiers.definitions);
      const refs = _this16.view(_selectors2.default.current.identifiers.refs);

      const decode = _this16.view(_selectors2.default.views.decoder);
      return yield decode(definitions[name], refs[name]);
    })();
  }

  variables() {
    var _this17 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      debug("awaiting decodeReady");
      yield _this17.decodeReady();
      debug("decode now ready");

      return yield _this17.view(_selectors2.default.current.identifiers.decoded);
      debug("got variables");
    })();
  }
}
exports.default = Session;

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (true) {
  module.exports = __webpack_require__(40);
} else if (process.env.NODE_ENV === "test") {
  module.exports = require("./test");
} else {
  module.exports = require("./development");
}

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _common = __webpack_require__(41);

var _common2 = _interopRequireDefault(_common);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _common2.default;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _entries = __webpack_require__(8);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(6);

var _assign2 = _interopRequireDefault(_assign);

exports.abbreviateValues = abbreviateValues;
exports.default = configureStore;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _redux = __webpack_require__(7);

var _reduxSaga = __webpack_require__(42);

var _reduxSaga2 = _interopRequireDefault(_reduxSaga);

var _reduxCliLogger = __webpack_require__(43);

var _reduxCliLogger2 = _interopRequireDefault(_reduxCliLogger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:store:common");
const reduxDebug = (0, _debug2.default)("debugger:redux");

function abbreviateValues(value, options = {}, depth = 0) {
  options.stringLimit = options.stringLimit || 66;
  options.arrayLimit = options.arrayLimit || 8;
  options.recurseLimit = options.recurseLimit || 4;

  if (depth > options.recurseLimit) {
    return "...";
  }

  const recurse = child => abbreviateValues(child, options, depth + 1);

  if (value instanceof Array) {
    if (value.length > options.arrayLimit) {
      value = [...value.slice(0, options.arrayLimit / 2), "...", ...value.slice(value.length - options.arrayLimit / 2 + 1)];
    }

    return value.map(recurse);
  } else if (value instanceof Object) {
    return (0, _assign2.default)({}, ...(0, _entries2.default)(value).map(([k, v]) => ({ [recurse(k)]: recurse(v) })));
  } else if (typeof value === "string" && value.length > options.stringLimit) {
    let inner = "...";
    let extractAmount = (options.stringLimit - inner.length) / 2;
    let leading = value.slice(0, Math.ceil(extractAmount));
    let trailing = value.slice(value.length - Math.floor(extractAmount));
    return `${leading}${inner}${trailing}`;
  } else {
    return value;
  }
}

function configureStore(reducer, saga, initialState, composeEnhancers) {
  const sagaMiddleware = (0, _reduxSaga2.default)();

  if (!composeEnhancers) {
    composeEnhancers = _redux.compose;
  }

  const loggerMiddleware = (0, _reduxCliLogger2.default)({
    log: reduxDebug,
    stateTransformer: state => abbreviateValues(state, {
      arrayLimit: 4,
      recurseLimit: 3
    }),
    actionTransformer: abbreviateValues
  });

  let store = (0, _redux.createStore)(reducer, initialState, composeEnhancers((0, _redux.applyMiddleware)(sagaMiddleware, loggerMiddleware)));

  sagaMiddleware.run(saga);

  return store;
}

/***/ }),
/* 42 */
/***/ (function(module, exports) {

module.exports = require("redux-saga");

/***/ }),
/* 43 */
/***/ (function(module, exports) {

module.exports = require("redux-cli-logger");

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

var json = typeof JSON !== 'undefined' ? JSON : __webpack_require__(45);

module.exports = function (obj, opts) {
    if (!opts) opts = {};
    if (typeof opts === 'function') opts = { cmp: opts };
    var space = opts.space || '';
    if (typeof space === 'number') space = Array(space+1).join(' ');
    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;
    var replacer = opts.replacer || function(key, value) { return value; };

    var cmp = opts.cmp && (function (f) {
        return function (node) {
            return function (a, b) {
                var aobj = { key: a, value: node[a] };
                var bobj = { key: b, value: node[b] };
                return f(aobj, bobj);
            };
        };
    })(opts.cmp);

    var seen = [];
    return (function stringify (parent, key, node, level) {
        var indent = space ? ('\n' + new Array(level + 1).join(space)) : '';
        var colonSeparator = space ? ': ' : ':';

        if (node && node.toJSON && typeof node.toJSON === 'function') {
            node = node.toJSON();
        }

        node = replacer.call(parent, key, node);

        if (node === undefined) {
            return;
        }
        if (typeof node !== 'object' || node === null) {
            return json.stringify(node);
        }
        if (isArray(node)) {
            var out = [];
            for (var i = 0; i < node.length; i++) {
                var item = stringify(node, i, node[i], level+1) || json.stringify(null);
                out.push(indent + space + item);
            }
            return '[' + out.join(',') + indent + ']';
        }
        else {
            if (seen.indexOf(node) !== -1) {
                if (cycles) return json.stringify('__cycle__');
                throw new TypeError('Converting circular structure to JSON');
            }
            else seen.push(node);

            var keys = objectKeys(node).sort(cmp && cmp(node));
            var out = [];
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var value = stringify(node, key, node[key], level+1);

                if(!value) continue;

                var keyValue = json.stringify(key)
                    + colonSeparator
                    + value;
                ;
                out.push(indent + space + keyValue);
            }
            seen.splice(seen.indexOf(node), 1);
            return '{' + out.join(',') + indent + '}';
        }
    })({ '': obj }, '', obj, 0);
};

var isArray = Array.isArray || function (x) {
    return {}.toString.call(x) === '[object Array]';
};

var objectKeys = Object.keys || function (obj) {
    var has = Object.prototype.hasOwnProperty || function () { return true };
    var keys = [];
    for (var key in obj) {
        if (has.call(obj, key)) keys.push(key);
    }
    return keys;
};


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

exports.parse = __webpack_require__(46);
exports.stringify = __webpack_require__(47);


/***/ }),
/* 46 */
/***/ (function(module, exports) {

var at, // The index of the current character
    ch, // The current character
    escapee = {
        '"':  '"',
        '\\': '\\',
        '/':  '/',
        b:    '\b',
        f:    '\f',
        n:    '\n',
        r:    '\r',
        t:    '\t'
    },
    text,

    error = function (m) {
        // Call error when something is wrong.
        throw {
            name:    'SyntaxError',
            message: m,
            at:      at,
            text:    text
        };
    },
    
    next = function (c) {
        // If a c parameter is provided, verify that it matches the current character.
        if (c && c !== ch) {
            error("Expected '" + c + "' instead of '" + ch + "'");
        }
        
        // Get the next character. When there are no more characters,
        // return the empty string.
        
        ch = text.charAt(at);
        at += 1;
        return ch;
    },
    
    number = function () {
        // Parse a number value.
        var number,
            string = '';
        
        if (ch === '-') {
            string = '-';
            next('-');
        }
        while (ch >= '0' && ch <= '9') {
            string += ch;
            next();
        }
        if (ch === '.') {
            string += '.';
            while (next() && ch >= '0' && ch <= '9') {
                string += ch;
            }
        }
        if (ch === 'e' || ch === 'E') {
            string += ch;
            next();
            if (ch === '-' || ch === '+') {
                string += ch;
                next();
            }
            while (ch >= '0' && ch <= '9') {
                string += ch;
                next();
            }
        }
        number = +string;
        if (!isFinite(number)) {
            error("Bad number");
        } else {
            return number;
        }
    },
    
    string = function () {
        // Parse a string value.
        var hex,
            i,
            string = '',
            uffff;
        
        // When parsing for string values, we must look for " and \ characters.
        if (ch === '"') {
            while (next()) {
                if (ch === '"') {
                    next();
                    return string;
                } else if (ch === '\\') {
                    next();
                    if (ch === 'u') {
                        uffff = 0;
                        for (i = 0; i < 4; i += 1) {
                            hex = parseInt(next(), 16);
                            if (!isFinite(hex)) {
                                break;
                            }
                            uffff = uffff * 16 + hex;
                        }
                        string += String.fromCharCode(uffff);
                    } else if (typeof escapee[ch] === 'string') {
                        string += escapee[ch];
                    } else {
                        break;
                    }
                } else {
                    string += ch;
                }
            }
        }
        error("Bad string");
    },

    white = function () {

// Skip whitespace.

        while (ch && ch <= ' ') {
            next();
        }
    },

    word = function () {

// true, false, or null.

        switch (ch) {
        case 't':
            next('t');
            next('r');
            next('u');
            next('e');
            return true;
        case 'f':
            next('f');
            next('a');
            next('l');
            next('s');
            next('e');
            return false;
        case 'n':
            next('n');
            next('u');
            next('l');
            next('l');
            return null;
        }
        error("Unexpected '" + ch + "'");
    },

    value,  // Place holder for the value function.

    array = function () {

// Parse an array value.

        var array = [];

        if (ch === '[') {
            next('[');
            white();
            if (ch === ']') {
                next(']');
                return array;   // empty array
            }
            while (ch) {
                array.push(value());
                white();
                if (ch === ']') {
                    next(']');
                    return array;
                }
                next(',');
                white();
            }
        }
        error("Bad array");
    },

    object = function () {

// Parse an object value.

        var key,
            object = {};

        if (ch === '{') {
            next('{');
            white();
            if (ch === '}') {
                next('}');
                return object;   // empty object
            }
            while (ch) {
                key = string();
                white();
                next(':');
                if (Object.hasOwnProperty.call(object, key)) {
                    error('Duplicate key "' + key + '"');
                }
                object[key] = value();
                white();
                if (ch === '}') {
                    next('}');
                    return object;
                }
                next(',');
                white();
            }
        }
        error("Bad object");
    };

value = function () {

// Parse a JSON value. It could be an object, an array, a string, a number,
// or a word.

    white();
    switch (ch) {
    case '{':
        return object();
    case '[':
        return array();
    case '"':
        return string();
    case '-':
        return number();
    default:
        return ch >= '0' && ch <= '9' ? number() : word();
    }
};

// Return the json_parse function. It will have access to all of the above
// functions and variables.

module.exports = function (source, reviver) {
    var result;
    
    text = source;
    at = 0;
    ch = ' ';
    result = value();
    white();
    if (ch) {
        error("Syntax error");
    }

    // If there is a reviver function, we recursively walk the new structure,
    // passing each name/value pair to the reviver function for possible
    // transformation, starting with a temporary root object that holds the result
    // in an empty key. If there is not a reviver function, we simply return the
    // result.

    return typeof reviver === 'function' ? (function walk(holder, key) {
        var k, v, value = holder[key];
        if (value && typeof value === 'object') {
            for (k in value) {
                if (Object.prototype.hasOwnProperty.call(value, k)) {
                    v = walk(value, k);
                    if (v !== undefined) {
                        value[k] = v;
                    } else {
                        delete value[k];
                    }
                }
            }
        }
        return reviver.call(holder, key, value);
    }({'': result}, '')) : result;
};


/***/ }),
/* 47 */
/***/ (function(module, exports) {

var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    gap,
    indent,
    meta = {    // table of character substitutions
        '\b': '\\b',
        '\t': '\\t',
        '\n': '\\n',
        '\f': '\\f',
        '\r': '\\r',
        '"' : '\\"',
        '\\': '\\\\'
    },
    rep;

function quote(string) {
    // If the string contains no control characters, no quote characters, and no
    // backslash characters, then we can safely slap some quotes around it.
    // Otherwise we must also replace the offending characters with safe escape
    // sequences.
    
    escapable.lastIndex = 0;
    return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
        var c = meta[a];
        return typeof c === 'string' ? c :
            '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    }) + '"' : '"' + string + '"';
}

function str(key, holder) {
    // Produce a string from holder[key].
    var i,          // The loop counter.
        k,          // The member key.
        v,          // The member value.
        length,
        mind = gap,
        partial,
        value = holder[key];
    
    // If the value has a toJSON method, call it to obtain a replacement value.
    if (value && typeof value === 'object' &&
            typeof value.toJSON === 'function') {
        value = value.toJSON(key);
    }
    
    // If we were called with a replacer function, then call the replacer to
    // obtain a replacement value.
    if (typeof rep === 'function') {
        value = rep.call(holder, key, value);
    }
    
    // What happens next depends on the value's type.
    switch (typeof value) {
        case 'string':
            return quote(value);
        
        case 'number':
            // JSON numbers must be finite. Encode non-finite numbers as null.
            return isFinite(value) ? String(value) : 'null';
        
        case 'boolean':
        case 'null':
            // If the value is a boolean or null, convert it to a string. Note:
            // typeof null does not produce 'null'. The case is included here in
            // the remote chance that this gets fixed someday.
            return String(value);
            
        case 'object':
            if (!value) return 'null';
            gap += indent;
            partial = [];
            
            // Array.isArray
            if (Object.prototype.toString.apply(value) === '[object Array]') {
                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }
                
                // Join all of the elements together, separated with commas, and
                // wrap them in brackets.
                v = partial.length === 0 ? '[]' : gap ?
                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                    '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }
            
            // If the replacer is an array, use it to select the members to be
            // stringified.
            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    k = rep[i];
                    if (typeof k === 'string') {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            else {
                // Otherwise, iterate through all of the keys in the object.
                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            
        // Join all of the member texts together, separated with commas,
        // and wrap them in braces.

        v = partial.length === 0 ? '{}' : gap ?
            '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
            '{' + partial.join(',') + '}';
        gap = mind;
        return v;
    }
}

module.exports = function (value, replacer, space) {
    var i;
    gap = '';
    indent = '';
    
    // If the space parameter is a number, make an indent string containing that
    // many spaces.
    if (typeof space === 'number') {
        for (i = 0; i < space; i += 1) {
            indent += ' ';
        }
    }
    // If the space parameter is a string, it will be used as the indent string.
    else if (typeof space === 'string') {
        indent = space;
    }

    // If there is a replacer, it must be a function or an array.
    // Otherwise, throw an error.
    rep = replacer;
    if (replacer && typeof replacer !== 'function'
    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {
        throw new Error('JSON.stringify');
    }
    
    // Make a fake root object containing our value under the key of ''.
    // Return the result of stringifying the value.
    return str('', {'': value});
};


/***/ }),
/* 48 */
/***/ (function(module, exports) {

module.exports = require("truffle-solidity-utils");

/***/ }),
/* 49 */
/***/ (function(module, exports) {

module.exports = require("truffle-code-utils");

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// An augmented AVL Tree where each node maintains a list of records and their search intervals.
// Record is composed of an interval and its underlying data, sent by a client. This allows the
// interval tree to have the same interval inserted multiple times, as long its data is different.
// Both insertion and deletion require O(log n) time. Searching requires O(k*logn) time, where `k`
// is the number of intervals in the output list.
Object.defineProperty(exports, "__esModule", { value: true });
var isSame = __webpack_require__(51);
function height(node) {
    if (node === undefined) {
        return -1;
    }
    else {
        return node.height;
    }
}
var Node = /** @class */ (function () {
    function Node(intervalTree, record) {
        this.intervalTree = intervalTree;
        this.records = [];
        this.height = 0;
        this.key = record.low;
        this.max = record.high;
        // Save the array of all records with the same key for this node
        this.records.push(record);
    }
    // Gets the highest record.high value for this node
    Node.prototype.getNodeHigh = function () {
        var high = this.records[0].high;
        for (var i = 1; i < this.records.length; i++) {
            if (this.records[i].high > high) {
                high = this.records[i].high;
            }
        }
        return high;
    };
    // Updates height value of the node. Called during insertion, rebalance, removal
    Node.prototype.updateHeight = function () {
        this.height = Math.max(height(this.left), height(this.right)) + 1;
    };
    // Updates the max value of all the parents after inserting into already existing node, as well as
    // removing the node completely or removing the record of an already existing node. Starts with
    // the parent of an affected node and bubbles up to root
    Node.prototype.updateMaxOfParents = function () {
        if (this === undefined) {
            return;
        }
        var thisHigh = this.getNodeHigh();
        if (this.left !== undefined && this.right !== undefined) {
            this.max = Math.max(Math.max(this.left.max, this.right.max), thisHigh);
        }
        else if (this.left !== undefined && this.right === undefined) {
            this.max = Math.max(this.left.max, thisHigh);
        }
        else if (this.left === undefined && this.right !== undefined) {
            this.max = Math.max(this.right.max, thisHigh);
        }
        else {
            this.max = thisHigh;
        }
        if (this.parent) {
            this.parent.updateMaxOfParents();
        }
    };
    /*
    Left-Left case:
  
           z                                      y
          / \                                   /   \
         y   T4      Right Rotate (z)          x     z
        / \          - - - - - - - - ->       / \   / \
       x   T3                                T1 T2 T3 T4
      / \
    T1   T2
  
    Left-Right case:
  
         z                               z                           x
        / \                             / \                        /   \
       y   T4  Left Rotate (y)         x  T4  Right Rotate(z)     y     z
      / \      - - - - - - - - ->     / \      - - - - - - - ->  / \   / \
    T1   x                           y  T3                      T1 T2 T3 T4
        / \                         / \
      T2   T3                      T1 T2
    */
    // Handles Left-Left case and Left-Right case after rebalancing AVL tree
    Node.prototype._updateMaxAfterRightRotate = function () {
        var parent = this.parent;
        var left = parent.left;
        // Update max of left sibling (x in first case, y in second)
        var thisParentLeftHigh = left.getNodeHigh();
        if (left.left === undefined && left.right !== undefined) {
            left.max = Math.max(thisParentLeftHigh, left.right.max);
        }
        else if (left.left !== undefined && left.right === undefined) {
            left.max = Math.max(thisParentLeftHigh, left.left.max);
        }
        else if (left.left === undefined && left.right === undefined) {
            left.max = thisParentLeftHigh;
        }
        else {
            left.max = Math.max(Math.max(left.left.max, left.right.max), thisParentLeftHigh);
        }
        // Update max of itself (z)
        var thisHigh = this.getNodeHigh();
        if (this.left === undefined && this.right !== undefined) {
            this.max = Math.max(thisHigh, this.right.max);
        }
        else if (this.left !== undefined && this.right === undefined) {
            this.max = Math.max(thisHigh, this.left.max);
        }
        else if (this.left === undefined && this.right === undefined) {
            this.max = thisHigh;
        }
        else {
            this.max = Math.max(Math.max(this.left.max, this.right.max), thisHigh);
        }
        // Update max of parent (y in first case, x in second)
        parent.max = Math.max(Math.max(parent.left.max, parent.right.max), parent.getNodeHigh());
    };
    /*
    Right-Right case:
  
      z                               y
     / \                            /   \
    T1  y     Left Rotate(z)       z     x
       / \   - - - - - - - ->     / \   / \
      T2  x                      T1 T2 T3 T4
         / \
        T3 T4
  
    Right-Left case:
  
       z                            z                            x
      / \                          / \                         /   \
     T1  y   Right Rotate (y)     T1  x      Left Rotate(z)   z     y
        / \  - - - - - - - - ->      / \   - - - - - - - ->  / \   / \
       x  T4                        T2  y                   T1 T2 T3 T4
      / \                              / \
    T2   T3                           T3 T4
    */
    // Handles Right-Right case and Right-Left case in rebalancing AVL tree
    Node.prototype._updateMaxAfterLeftRotate = function () {
        var parent = this.parent;
        var right = parent.right;
        // Update max of right sibling (x in first case, y in second)
        var thisParentRightHigh = right.getNodeHigh();
        if (right.left === undefined && right.right !== undefined) {
            right.max = Math.max(thisParentRightHigh, right.right.max);
        }
        else if (right.left !== undefined && right.right === undefined) {
            right.max = Math.max(thisParentRightHigh, right.left.max);
        }
        else if (right.left === undefined && right.right === undefined) {
            right.max = thisParentRightHigh;
        }
        else {
            right.max = Math.max(Math.max(right.left.max, right.right.max), thisParentRightHigh);
        }
        // Update max of itself (z)
        var thisHigh = this.getNodeHigh();
        if (this.left === undefined && this.right !== undefined) {
            this.max = Math.max(thisHigh, this.right.max);
        }
        else if (this.left !== undefined && this.right === undefined) {
            this.max = Math.max(thisHigh, this.left.max);
        }
        else if (this.left === undefined && this.right === undefined) {
            this.max = thisHigh;
        }
        else {
            this.max = Math.max(Math.max(this.left.max, this.right.max), thisHigh);
        }
        // Update max of parent (y in first case, x in second)
        parent.max = Math.max(Math.max(parent.left.max, right.max), parent.getNodeHigh());
    };
    Node.prototype._leftRotate = function () {
        var rightChild = this.right;
        rightChild.parent = this.parent;
        if (rightChild.parent === undefined) {
            this.intervalTree.root = rightChild;
        }
        else {
            if (rightChild.parent.left === this) {
                rightChild.parent.left = rightChild;
            }
            else if (rightChild.parent.right === this) {
                rightChild.parent.right = rightChild;
            }
        }
        this.right = rightChild.left;
        if (this.right !== undefined) {
            this.right.parent = this;
        }
        rightChild.left = this;
        this.parent = rightChild;
        this.updateHeight();
        rightChild.updateHeight();
    };
    Node.prototype._rightRotate = function () {
        var leftChild = this.left;
        leftChild.parent = this.parent;
        if (leftChild.parent === undefined) {
            this.intervalTree.root = leftChild;
        }
        else {
            if (leftChild.parent.left === this) {
                leftChild.parent.left = leftChild;
            }
            else if (leftChild.parent.right === this) {
                leftChild.parent.right = leftChild;
            }
        }
        this.left = leftChild.right;
        if (this.left !== undefined) {
            this.left.parent = this;
        }
        leftChild.right = this;
        this.parent = leftChild;
        this.updateHeight();
        leftChild.updateHeight();
    };
    // Rebalances the tree if the height value between two nodes of the same parent is greater than
    // two. There are 4 cases that can happen which are outlined in the graphics above
    Node.prototype._rebalance = function () {
        if (height(this.left) >= 2 + height(this.right)) {
            var left = this.left;
            if (height(left.left) >= height(left.right)) {
                // Left-Left case
                this._rightRotate();
                this._updateMaxAfterRightRotate();
            }
            else {
                // Left-Right case
                left._leftRotate();
                this._rightRotate();
                this._updateMaxAfterRightRotate();
            }
        }
        else if (height(this.right) >= 2 + height(this.left)) {
            var right = this.right;
            if (height(right.right) >= height(right.left)) {
                // Right-Right case
                this._leftRotate();
                this._updateMaxAfterLeftRotate();
            }
            else {
                // Right-Left case
                right._rightRotate();
                this._leftRotate();
                this._updateMaxAfterLeftRotate();
            }
        }
    };
    Node.prototype.insert = function (record) {
        if (record.low < this.key) {
            // Insert into left subtree
            if (this.left === undefined) {
                this.left = new Node(this.intervalTree, record);
                this.left.parent = this;
            }
            else {
                this.left.insert(record);
            }
        }
        else {
            // Insert into right subtree
            if (this.right === undefined) {
                this.right = new Node(this.intervalTree, record);
                this.right.parent = this;
            }
            else {
                this.right.insert(record);
            }
        }
        // Update the max value of this ancestor if needed
        if (this.max < record.high) {
            this.max = record.high;
        }
        // Update height of each node
        this.updateHeight();
        // Rebalance the tree to ensure all operations are executed in O(logn) time. This is especially
        // important in searching, as the tree has a high chance of degenerating without the rebalancing
        this._rebalance();
    };
    Node.prototype._getOverlappingRecords = function (currentNode, low, high) {
        if (currentNode.key <= high && low <= currentNode.getNodeHigh()) {
            // Nodes are overlapping, check if individual records in the node are overlapping
            var tempResults = [];
            for (var i = 0; i < currentNode.records.length; i++) {
                if (currentNode.records[i].high >= low) {
                    tempResults.push(currentNode.records[i]);
                }
            }
            return tempResults;
        }
        return [];
    };
    Node.prototype.search = function (low, high) {
        // Don't search nodes that don't exist
        if (this === undefined) {
            return [];
        }
        var leftSearch = [];
        var ownSearch = [];
        var rightSearch = [];
        // If interval is to the right of the rightmost point of any interval in this node and all its
        // children, there won't be any matches
        if (low > this.max) {
            return [];
        }
        // Search left children
        if (this.left !== undefined && this.left.max >= low) {
            leftSearch = this.left.search(low, high);
        }
        // Check this node
        ownSearch = this._getOverlappingRecords(this, low, high);
        // If interval is to the left of the start of this interval, then it can't be in any child to
        // the right
        if (high < this.key) {
            return leftSearch.concat(ownSearch);
        }
        // Otherwise, search right children
        if (this.right !== undefined) {
            rightSearch = this.right.search(low, high);
        }
        // Return accumulated results, if any
        return leftSearch.concat(ownSearch, rightSearch);
    };
    // Searches for a node by a `key` value
    Node.prototype.searchExisting = function (low) {
        if (this === undefined) {
            return undefined;
        }
        if (this.key === low) {
            return this;
        }
        else if (low < this.key) {
            if (this.left !== undefined) {
                return this.left.searchExisting(low);
            }
        }
        else {
            if (this.right !== undefined) {
                return this.right.searchExisting(low);
            }
        }
        return undefined;
    };
    // Returns the smallest node of the subtree
    Node.prototype._minValue = function () {
        if (this.left === undefined) {
            return this;
        }
        else {
            return this.left._minValue();
        }
    };
    Node.prototype.remove = function (node) {
        var parent = this.parent;
        if (node.key < this.key) {
            // Node to be removed is on the left side
            if (this.left !== undefined) {
                return this.left.remove(node);
            }
            else {
                return undefined;
            }
        }
        else if (node.key > this.key) {
            // Node to be removed is on the right side
            if (this.right !== undefined) {
                return this.right.remove(node);
            }
            else {
                return undefined;
            }
        }
        else {
            if (this.left !== undefined && this.right !== undefined) {
                // Node has two children
                var minValue = this.right._minValue();
                this.key = minValue.key;
                this.records = minValue.records;
                return this.right.remove(this);
            }
            else if (parent.left === this) {
                // One child or no child case on left side
                if (this.right !== undefined) {
                    parent.left = this.right;
                    this.right.parent = parent;
                }
                else {
                    parent.left = this.left;
                    if (this.left !== undefined) {
                        this.left.parent = parent;
                    }
                }
                parent.updateMaxOfParents();
                parent.updateHeight();
                parent._rebalance();
                return this;
            }
            else if (parent.right === this) {
                // One child or no child case on right side
                if (this.right !== undefined) {
                    parent.right = this.right;
                    this.right.parent = parent;
                }
                else {
                    parent.right = this.left;
                    if (this.left !== undefined) {
                        this.left.parent = parent;
                    }
                }
                parent.updateMaxOfParents();
                parent.updateHeight();
                parent._rebalance();
                return this;
            }
        }
    };
    return Node;
}());
exports.Node = Node;
var IntervalTree = /** @class */ (function () {
    function IntervalTree() {
        this.count = 0;
    }
    IntervalTree.prototype.insert = function (record) {
        if (record.low > record.high) {
            throw new Error('`low` value must be lower or equal to `high` value');
        }
        if (this.root === undefined) {
            // Base case: Tree is empty, new node becomes root
            this.root = new Node(this, record);
            this.count++;
            return true;
        }
        else {
            // Otherwise, check if node already exists with the same key
            var node = this.root.searchExisting(record.low);
            if (node !== undefined) {
                // Check the records in this node if there already is the one with same low, high, data
                for (var i = 0; i < node.records.length; i++) {
                    if (isSame(node.records[i], record)) {
                        // This record is same as the one we're trying to insert; return false to indicate
                        // nothing has been inserted
                        return false;
                    }
                }
                // Add the record to the node
                node.records.push(record);
                // Update max of the node and its parents if necessary
                if (record.high > node.max) {
                    node.max = record.high;
                    if (node.parent) {
                        node.parent.updateMaxOfParents();
                    }
                }
                this.count++;
                return true;
            }
            else {
                // Node with this key doesn't already exist. Call insert function on root's node
                this.root.insert(record);
                this.count++;
                return true;
            }
        }
    };
    IntervalTree.prototype.search = function (low, high) {
        if (this.root === undefined) {
            // Tree is empty; return empty array
            return [];
        }
        else {
            return this.root.search(low, high);
        }
    };
    IntervalTree.prototype.remove = function (record) {
        if (this.root === undefined) {
            // Tree is empty; nothing to remove
            return false;
        }
        else {
            var node = this.root.searchExisting(record.low);
            if (node === undefined) {
                return false;
            }
            else if (node.records.length > 1) {
                var removedRecord = void 0;
                // Node with this key has 2 or more records. Find the one we need and remove it
                for (var i = 0; i < node.records.length; i++) {
                    if (isSame(node.records[i], record)) {
                        removedRecord = node.records[i];
                        node.records.splice(i, 1);
                        break;
                    }
                }
                if (removedRecord) {
                    removedRecord = undefined;
                    // Update max of that node and its parents if necessary
                    if (record.high === node.max) {
                        var nodeHigh = node.getNodeHigh();
                        if (node.left !== undefined && node.right !== undefined) {
                            node.max = Math.max(Math.max(node.left.max, node.right.max), nodeHigh);
                        }
                        else if (node.left !== undefined && node.right === undefined) {
                            node.max = Math.max(node.left.max, nodeHigh);
                        }
                        else if (node.left === undefined && node.right !== undefined) {
                            node.max = Math.max(node.right.max, nodeHigh);
                        }
                        else {
                            node.max = nodeHigh;
                        }
                        if (node.parent) {
                            node.parent.updateMaxOfParents();
                        }
                    }
                    this.count--;
                    return true;
                }
                else {
                    return false;
                }
            }
            else if (node.records.length === 1) {
                // Node with this key has only 1 record. Check if the remaining record in this node is
                // actually the one we want to remove
                if (isSame(node.records[0], record)) {
                    // The remaining record is the one we want to remove. Remove the whole node from the tree
                    if (this.root.key === node.key) {
                        // We're removing the root element. Create a dummy node that will temporarily take
                        // root's parent role
                        var rootParent = new Node(this, { low: record.low, high: record.low });
                        rootParent.left = this.root;
                        this.root.parent = rootParent;
                        var removedNode = this.root.remove(node);
                        this.root = rootParent.left;
                        if (this.root !== undefined) {
                            this.root.parent = undefined;
                        }
                        if (removedNode) {
                            removedNode = undefined;
                            this.count--;
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                    else {
                        var removedNode = this.root.remove(node);
                        if (removedNode) {
                            removedNode = undefined;
                            this.count--;
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                }
                else {
                    // The remaining record is not the one we want to remove
                    return false;
                }
            }
            else {
                // No records at all in this node?! Shouldn't happen
                return false;
            }
        }
    };
    IntervalTree.prototype.inOrder = function () {
        return new InOrder(this.root);
    };
    IntervalTree.prototype.preOrder = function () {
        return new PreOrder(this.root);
    };
    return IntervalTree;
}());
exports.IntervalTree = IntervalTree;
var DataIntervalTree = /** @class */ (function () {
    function DataIntervalTree() {
        this.tree = new IntervalTree();
    }
    DataIntervalTree.prototype.insert = function (low, high, data) {
        return this.tree.insert({ low: low, high: high, data: data });
    };
    DataIntervalTree.prototype.remove = function (low, high, data) {
        return this.tree.remove({ low: low, high: high, data: data });
    };
    DataIntervalTree.prototype.search = function (low, high) {
        return this.tree.search(low, high).map(function (v) { return v.data; });
    };
    DataIntervalTree.prototype.inOrder = function () {
        return this.tree.inOrder();
    };
    DataIntervalTree.prototype.preOrder = function () {
        return this.tree.preOrder();
    };
    Object.defineProperty(DataIntervalTree.prototype, "count", {
        get: function () {
            return this.tree.count;
        },
        enumerable: true,
        configurable: true
    });
    return DataIntervalTree;
}());
exports.default = DataIntervalTree;
var InOrder = /** @class */ (function () {
    function InOrder(startNode) {
        this.stack = [];
        if (startNode !== undefined) {
            this.push(startNode);
        }
    }
    InOrder.prototype.next = function () {
        // Will only happen if stack is empty and pop is called
        if (this.currentNode === undefined) {
            return {
                done: true,
                value: undefined,
            };
        }
        // Process this node
        if (this.i < this.currentNode.records.length) {
            return {
                done: false,
                value: this.currentNode.records[this.i++],
            };
        }
        if (this.currentNode.right !== undefined) {
            this.push(this.currentNode.right);
        }
        else {
            // Might pop the last and set this.currentNode = undefined
            this.pop();
        }
        return this.next();
    };
    InOrder.prototype.push = function (node) {
        this.currentNode = node;
        this.i = 0;
        while (this.currentNode.left !== undefined) {
            this.stack.push(this.currentNode);
            this.currentNode = this.currentNode.left;
        }
    };
    InOrder.prototype.pop = function () {
        this.currentNode = this.stack.pop();
        this.i = 0;
    };
    return InOrder;
}());
exports.InOrder = InOrder;
if (typeof Symbol === 'function') {
    InOrder.prototype[Symbol.iterator] = function () { return this; };
}
var PreOrder = /** @class */ (function () {
    function PreOrder(startNode) {
        this.stack = [];
        this.i = 0;
        this.currentNode = startNode;
    }
    PreOrder.prototype.next = function () {
        // Will only happen if stack is empty and pop is called,
        // which only happens if there is no right node (i.e we are done)
        if (this.currentNode === undefined) {
            return {
                done: true,
                value: undefined,
            };
        }
        // Process this node
        if (this.i < this.currentNode.records.length) {
            return {
                done: false,
                value: this.currentNode.records[this.i++],
            };
        }
        if (this.currentNode.right !== undefined) {
            this.push(this.currentNode.right);
        }
        if (this.currentNode.left !== undefined) {
            this.push(this.currentNode.left);
        }
        this.pop();
        return this.next();
    };
    PreOrder.prototype.push = function (node) {
        this.stack.push(node);
    };
    PreOrder.prototype.pop = function () {
        this.currentNode = this.stack.pop();
        this.i = 0;
    };
    return PreOrder;
}());
exports.PreOrder = PreOrder;
if (typeof Symbol === 'function') {
    PreOrder.prototype[Symbol.iterator] = function () { return this; };
}
//# sourceMappingURL=index.js.map

/***/ }),
/* 51 */
/***/ (function(module, exports) {

//

module.exports = function shallowEqual(objA, objB, compare, compareContext) {
  var ret = compare ? compare.call(compareContext, objA, objB) : void 0;

  if (ret !== void 0) {
    return !!ret;
  }

  if (objA === objB) {
    return true;
  }

  if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);

  // Test for A's keys different from B.
  for (var idx = 0; idx < keysA.length; idx++) {
    var key = keysA[idx];

    if (!bHasOwnProperty(key)) {
      return false;
    }

    var valueA = objA[key];
    var valueB = objB[key];

    ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;

    if (ret === false || (ret === void 0 && valueA !== valueB)) {
      return false;
    }
  }

  return true;
};


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(5);

var _helpers = __webpack_require__(1);

var _sagas = __webpack_require__(53);

var ast = _interopRequireWildcard(_sagas);

var _sagas2 = __webpack_require__(55);

var controller = _interopRequireWildcard(_sagas2);

var _sagas3 = __webpack_require__(32);

var solidity = _interopRequireWildcard(_sagas3);

var _sagas4 = __webpack_require__(30);

var evm = _interopRequireWildcard(_sagas4);

var _sagas5 = __webpack_require__(14);

var trace = _interopRequireWildcard(_sagas5);

var _sagas6 = __webpack_require__(24);

var data = _interopRequireWildcard(_sagas6);

var _sagas7 = __webpack_require__(56);

var web3 = _interopRequireWildcard(_sagas7);

var _actions = __webpack_require__(16);

var actions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:session:sagas");

function* saga() {
  debug("starting listeners");
  yield* forkListeners();

  // receiving & saving contracts into state
  debug("waiting for contract information");
  let { contexts, sources } = yield (0, _effects.take)(actions.RECORD_CONTRACTS);

  debug("recording contract binaries");
  yield* recordContexts(...contexts);

  debug("recording contract sources");
  yield* recordSources(...sources);

  debug("normalizing contexts");
  yield* evm.normalizeContexts();

  debug("waiting for start");
  // wait for start signal
  let { txHash, provider } = yield (0, _effects.take)(actions.START);
  debug("starting");

  // process transaction
  debug("fetching transaction info");
  let err = yield* fetchTx(txHash, provider);
  if (err) {
    debug("error %o", err);
    yield* error(err);
    return;
  }

  debug("visiting ASTs");
  // visit asts
  yield* ast.visitAll();

  //save allocation table
  debug("saving allocation table");
  yield* data.recordAllocations();

  debug("readying");
  // signal that stepping can begin
  yield* ready();
}

exports.default = (0, _helpers.prefixName)("session", saga);


function* forkListeners() {
  return yield (0, _effects.all)([controller, data, evm, solidity, trace, web3].map(app => (0, _effects.fork)(app.saga)
  //ast no longer has a listener
  ));
}

function* fetchTx(txHash, provider) {
  let result = yield* web3.inspectTransaction(txHash, provider);
  debug("result %o", result);

  if (result.error) {
    return result.error;
  }

  yield* evm.begin(result);

  //get addresses created/called during transaction
  let addresses = yield* trace.processTrace(result.trace);
  //add in the address of the call itself (if a call)
  if (result.address && !addresses.includes(result.address)) {
    addresses.push(result.address);
  }
  //if a create, only add in address if it was successful
  if (result.binary && result.status && !addresses.includes(result.storageAddress)) {
    addresses.push(result.storageAddress);
  }

  let binaries = yield* web3.obtainBinaries(addresses);

  yield (0, _effects.all)(addresses.map((address, i) => (0, _effects.call)(recordInstance, address, binaries[i])));
}

function* recordContexts(...contexts) {
  for (let context of contexts) {
    yield* evm.addContext(context);
  }
}

function* recordSources(...sources) {
  for (let sourceData of sources) {
    if (sourceData !== undefined && sourceData !== null) {
      yield* solidity.addSource(sourceData.source, sourceData.sourcePath, sourceData.ast, sourceData.compiler);
    }
  }
}

function* recordInstance(address, binary) {
  yield* evm.addInstance(address, binary);
}

function* ready() {
  yield (0, _effects.put)(actions.ready());
}

function* error(err) {
  yield (0, _effects.put)(actions.error(err));
}

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _entries = __webpack_require__(8);

var _entries2 = _interopRequireDefault(_entries);

exports.visitAll = visitAll;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(5);

var _sagas = __webpack_require__(24);

var data = _interopRequireWildcard(_sagas);

var _selectors = __webpack_require__(29);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:ast:sagas");

function* walk(sourceId, node, pointer = "", parentId = null) {
  debug("walking %o %o", pointer, node);

  yield* handleEnter(sourceId, node, pointer, parentId);

  if (node instanceof Array) {
    for (let [i, child] of node.entries()) {
      yield (0, _effects.call)(walk, sourceId, child, `${pointer}/${i}`, parentId);
    }
  } else if (node instanceof Object) {
    for (let [key, child] of (0, _entries2.default)(node)) {
      yield (0, _effects.call)(walk, sourceId, child, `${pointer}/${key}`, node.id);
    }
  }

  yield* handleExit(sourceId, node, pointer);
}

function* handleEnter(sourceId, node, pointer, parentId) {
  if (!(node instanceof Object)) {
    return;
  }

  debug("entering %s", pointer);

  if (node.id !== undefined) {
    debug("%s recording scope %s", pointer, node.id);
    yield* data.scope(node.id, pointer, parentId, sourceId);
  }

  switch (node.nodeType) {
    case "VariableDeclaration":
      debug("%s recording variable %o", pointer, node);
      yield* data.declare(node);
      break;
    case "ContractDefinition":
    case "StructDefinition":
    case "EnumDefinition":
      yield* data.defineType(node);
      break;
  }
}

function* handleExit(sourceId, node, pointer) {
  debug("exiting %s", pointer);

  // no-op right now
}

function* visitAll() {
  let sources = yield (0, _effects.select)(_selectors2.default.views.sources);

  yield (0, _effects.all)((0, _entries2.default)(sources).filter(([_, source]) => source.ast).map(([id, { ast }]) => (0, _effects.call)(walk, id, ast)));

  debug("done visiting");
}

/***/ }),
/* 54 */
/***/ (function(module, exports) {

module.exports = require("lodash.sum");

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = __webpack_require__(21);

var _keys2 = _interopRequireDefault(_keys);

exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(5);

var _helpers = __webpack_require__(1);

var _sagas = __webpack_require__(14);

var trace = _interopRequireWildcard(_sagas);

var _sagas2 = __webpack_require__(24);

var data = _interopRequireWildcard(_sagas2);

var _sagas3 = __webpack_require__(30);

var evm = _interopRequireWildcard(_sagas3);

var _sagas4 = __webpack_require__(32);

var solidity = _interopRequireWildcard(_sagas4);

var _actions = __webpack_require__(18);

var actions = _interopRequireWildcard(_actions);

var _selectors = __webpack_require__(23);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:controller:sagas");

//NOTE: when updating this don't forget to update CONTROL_ACTIONS in
//reducers.js as well!
const CONTROL_SAGAS = {
  [actions.ADVANCE]: advance,
  [actions.STEP_NEXT]: stepNext,
  [actions.STEP_OVER]: stepOver,
  [actions.STEP_INTO]: stepInto,
  [actions.STEP_OUT]: stepOut,
  [actions.CONTINUE]: continueUntilBreakpoint,
  [actions.RESET]: reset
};

function* saga() {
  while (true) {
    debug("waiting for control action");
    let action = yield (0, _effects.take)((0, _keys2.default)(CONTROL_SAGAS));
    debug("got control action");
    let saga = CONTROL_SAGAS[action.type];

    yield (0, _effects.race)({
      exec: (0, _effects.call)(saga, action), //not all will use this
      interrupt: (0, _effects.take)(actions.INTERRUPT)
    });
    yield (0, _effects.put)(actions.doneStepping());
  }
}

exports.default = (0, _helpers.prefixName)("controller", saga);

/*
 * Advance the state by the given number of instructions (but not past the end)
 * (if no count given, advance 1)
 */

function* advance(action) {
  let count = action !== undefined && action.count !== undefined ? action.count : 1; //default is, as mentioned, to advance 1
  for (let i = 0; i < count && !(yield (0, _effects.select)(_selectors2.default.current.finished)); i++) {
    yield* trace.advance();
  }
}

/**
 * stepNext - step to the next logical code segment
 *
 * Note: It might take multiple instructions to express the same section of code.
 * "Stepping", then, is stepping to the next logical item, not stepping to the next
 * instruction. See advance() if you'd like to advance by one instruction.
 */
function* stepNext() {
  const startingRange = yield (0, _effects.select)(_selectors2.default.current.location.sourceRange);

  var upcoming, finished;

  do {
    // advance at least once step
    yield* advance();

    // and check the next source range
    try {
      upcoming = yield (0, _effects.select)(_selectors2.default.current.location);
    } catch (e) {
      upcoming = null;
    }

    finished = yield (0, _effects.select)(_selectors2.default.current.finished);

    // if the next step's source range is still the same, keep going
  } while (!finished && (!upcoming || !upcoming.node || (0, _helpers.isDeliberatelySkippedNodeType)(upcoming.node) || upcoming.sourceRange.start == startingRange.start && upcoming.sourceRange.length == startingRange.length));
}

/**
 * stepInto - step into the current function
 *
 * Conceptually this is easy, but from a programming standpoint it's hard.
 * Code like `getBalance(msg.sender)` might be highlighted, but there could
 * be a number of different intermediate steps (like evaluating `msg.sender`)
 * before `getBalance` is stepped into. This function will step into the first
 * function available (where instruction.jump == "i"), ignoring any intermediate
 * steps that fall within the same code range. If there's a step encountered
 * that exists outside of the range, then stepInto will only execute until that
 * step.
 */
function* stepInto() {
  if (yield (0, _effects.select)(_selectors2.default.current.willJump)) {
    yield* stepNext();
    return;
  }

  if (yield (0, _effects.select)(_selectors2.default.current.location.isMultiline)) {
    yield* stepOver();
    return;
  }

  const startingDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
  const startingRange = yield (0, _effects.select)(_selectors2.default.current.location.sourceRange);
  var currentDepth;
  var currentRange;

  do {
    yield* stepNext();

    currentDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
    currentRange = yield (0, _effects.select)(_selectors2.default.current.location.sourceRange);
  } while (
  // the function stack has not increased,
  currentDepth <= startingDepth &&
  // the current source range begins on or after the starting range
  currentRange.start >= startingRange.start &&
  // and the current range ends on or before the starting range ends
  currentRange.start + currentRange.length <= startingRange.start + startingRange.length);
}

/**
 * Step out of the current function
 *
 * This will run until the debugger encounters a decrease in function depth.
 */
function* stepOut() {
  if (yield (0, _effects.select)(_selectors2.default.current.location.isMultiline)) {
    yield* stepOver();
    return;
  }

  const startingDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
  var currentDepth;

  do {
    yield* stepNext();

    currentDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
  } while (currentDepth >= startingDepth);
}

/**
 * stepOver - step over the current line
 *
 * Step over the current line. This will step to the next instruction that
 * exists on a different line of code within the same function depth.
 */
function* stepOver() {
  const startingDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
  const startingRange = yield (0, _effects.select)(_selectors2.default.current.location.sourceRange);
  var currentDepth;
  var currentRange;

  do {
    yield* stepNext();

    currentDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
    currentRange = yield (0, _effects.select)(_selectors2.default.current.location.sourceRange);
  } while (
  // keep stepping provided:
  //
  // we haven't jumped out
  !(currentDepth < startingDepth) && (
  // either: function depth is greater than starting (ignore function calls)
  // or, if we're at the same depth, keep stepping until we're on a new
  // line.
  currentDepth > startingDepth || currentRange.lines.start.line == startingRange.lines.start.line));
}

/**
 * continueUntilBreakpoint - step through execution until a breakpoint
 */
function* continueUntilBreakpoint(action) {
  var currentLocation, currentNode, currentLine, currentSourceId;
  var finished;
  var previousLine, previousSourceId;

  //if breakpoints was not specified, use the stored list from the state.
  //if it was, override that with the specified list.
  //note that explicitly specifying an empty list will advance to the end.
  let breakpoints = action !== undefined && action.breakpoints !== undefined ? action.breakpoints : yield (0, _effects.select)(_selectors2.default.breakpoints);

  let breakpointHit = false;

  currentLocation = yield (0, _effects.select)(_selectors2.default.current.location);
  currentNode = currentLocation.node.id;
  currentLine = currentLocation.sourceRange.lines.start.line;
  currentSourceId = currentLocation.source.id;

  do {
    yield* stepNext();

    previousLine = currentLine;
    previousSourceId = currentSourceId;

    currentLocation = yield (0, _effects.select)(_selectors2.default.current.location);
    finished = yield (0, _effects.select)(_selectors2.default.current.finished);
    debug("finished %o", finished);

    currentNode = currentLocation.node.id;
    currentLine = currentLocation.sourceRange.lines.start.line;
    currentSourceId = currentLocation.source.id;

    breakpointHit = breakpoints.filter(({ sourceId, line, node }) => {
      if (node !== undefined) {
        debug("node %d currentNode %d", node, currentNode);
        return sourceId === currentSourceId && node === currentNode;
      }
      //otherwise, we have a line-style breakpoint; we want to stop at the
      //*first* point on the line
      return sourceId === currentSourceId && line === currentLine && (currentSourceId !== previousSourceId || currentLine !== previousLine);
    }).length > 0;
  } while (!breakpointHit && !finished);
}

/**
 * reset -- reset the state of the debugger
 */
function* reset() {
  yield* data.reset();
  yield* evm.reset();
  yield* solidity.reset();
  yield* trace.reset();
}

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.inspectTransaction = inspectTransaction;
exports.obtainBinaries = obtainBinaries;
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(5);

var _helpers = __webpack_require__(1);

var _actions = __webpack_require__(57);

var actions = _interopRequireWildcard(_actions);

var _actions2 = __webpack_require__(16);

var session = _interopRequireWildcard(_actions2);

var _bn = __webpack_require__(17);

var _bn2 = _interopRequireDefault(_bn);

var _web = __webpack_require__(34);

var _web2 = _interopRequireDefault(_web);

var _truffleDecodeUtils = __webpack_require__(4);

var DecodeUtils = _interopRequireWildcard(_truffleDecodeUtils);

var _adapter = __webpack_require__(58);

var _adapter2 = _interopRequireDefault(_adapter);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:web3:sagas"); //just for utils!


function* fetchTransactionInfo(adapter, { txHash }) {
  debug("inspecting transaction");
  var trace;
  try {
    trace = yield (0, _effects.apply)(adapter, adapter.getTrace, [txHash]);
  } catch (e) {
    debug("putting error");
    yield (0, _effects.put)(actions.error(e));
    return;
  }

  debug("got trace");
  yield (0, _effects.put)(actions.receiveTrace(trace));

  let tx = yield (0, _effects.apply)(adapter, adapter.getTransaction, [txHash]);
  debug("tx %O", tx);
  let receipt = yield (0, _effects.apply)(adapter, adapter.getReceipt, [txHash]);
  debug("receipt %O", receipt);
  let block = yield (0, _effects.apply)(adapter, adapter.getBlock, [tx.blockNumber]);
  debug("block %O", block);

  yield (0, _effects.put)(session.saveTransaction(tx));
  yield (0, _effects.put)(session.saveReceipt(receipt));
  yield (0, _effects.put)(session.saveBlock(block));

  //these ones get grouped together for convenience
  let solidityBlock = {
    coinbase: block.miner,
    difficulty: new _bn2.default(block.difficulty),
    gaslimit: new _bn2.default(block.gasLimit),
    number: new _bn2.default(block.number),
    timestamp: new _bn2.default(block.timestamp)
  };

  if (tx.to != null) {
    yield (0, _effects.put)(actions.receiveCall({
      address: tx.to,
      data: tx.input,
      storageAddress: tx.to,
      sender: tx.from,
      value: new _bn2.default(tx.value),
      gasprice: new _bn2.default(tx.gasPrice),
      block: solidityBlock
    }));
  } else {
    let storageAddress = _web2.default.utils.isAddress(receipt.contractAddress) ? receipt.contractAddress : DecodeUtils.EVM.ZERO_ADDRESS;
    yield (0, _effects.put)(actions.receiveCall({
      binary: tx.input,
      storageAddress,
      status: receipt.status,
      sender: tx.from,
      value: new _bn2.default(tx.value),
      gasprice: new _bn2.default(tx.gasPrice),
      block: solidityBlock
    }));
  }
}

function* fetchBinary(adapter, { address }) {
  debug("fetching binary for %s", address);
  let binary = yield (0, _effects.apply)(adapter, adapter.getDeployedCode, [address]);

  debug("received binary for %s", address);
  yield (0, _effects.put)(actions.receiveBinary(address, binary));
}

function* inspectTransaction(txHash, provider) {
  yield (0, _effects.put)(actions.init(provider));
  yield (0, _effects.put)(actions.inspect(txHash));

  let action = yield (0, _effects.take)([actions.RECEIVE_TRACE, actions.ERROR_WEB3]);
  debug("action %o", action);

  var trace;
  if (action.type == actions.RECEIVE_TRACE) {
    trace = action.trace;
    debug("received trace");
  } else {
    return { error: action.error };
  }

  let {
    address,
    binary,
    data,
    storageAddress,
    status,
    sender,
    value,
    gasprice,
    block
  } = yield (0, _effects.take)(actions.RECEIVE_CALL);
  debug("received call");

  return {
    trace,
    address,
    binary,
    data,
    storageAddress,
    status,
    sender,
    value,
    gasprice,
    block
  };
}

function* obtainBinaries(addresses) {
  let tasks = yield (0, _effects.all)(addresses.map(address => (0, _effects.fork)(receiveBinary, address)));

  debug("requesting binaries");
  yield (0, _effects.all)(addresses.map(address => (0, _effects.put)(actions.fetchBinary(address))));

  let binaries = [];
  binaries = yield (0, _effects.all)(tasks.map(task => (0, _effects.join)(task)));

  debug("binaries %o", binaries);

  return binaries;
}

function* receiveBinary(address) {
  let { binary } = yield (0, _effects.take)(action => action.type == actions.RECEIVE_BINARY && action.address == address);
  debug("got binary for %s", address);

  return binary;
}

function* saga() {
  // wait for web3 init signal
  let { provider } = yield (0, _effects.take)(actions.INIT_WEB3);
  let adapter = new _adapter2.default(provider);

  yield (0, _effects.takeEvery)(actions.INSPECT, fetchTransactionInfo, adapter);
  yield (0, _effects.takeEvery)(actions.FETCH_BINARY, fetchBinary, adapter);
}

exports.default = (0, _helpers.prefixName)("web3", saga);

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.init = init;
exports.inspect = inspect;
exports.fetchBinary = fetchBinary;
exports.receiveBinary = receiveBinary;
exports.receiveTrace = receiveTrace;
exports.receiveCall = receiveCall;
exports.error = error;
const INIT_WEB3 = exports.INIT_WEB3 = "INIT_WEB3";
function init(provider) {
  return {
    type: INIT_WEB3,
    provider
  };
}

const INSPECT = exports.INSPECT = "INSPECT_TRANSACTION";
function inspect(txHash) {
  return {
    type: INSPECT,
    txHash
  };
}

const FETCH_BINARY = exports.FETCH_BINARY = "FETCH_BINARY";
function fetchBinary(address) {
  return {
    type: FETCH_BINARY,
    address
  };
}

const RECEIVE_BINARY = exports.RECEIVE_BINARY = "RECEIVE_BINARY";
function receiveBinary(address, binary) {
  return {
    type: RECEIVE_BINARY,
    address,
    binary
  };
}

const RECEIVE_TRACE = exports.RECEIVE_TRACE = "RECEIVE_TRACE";
function receiveTrace(trace) {
  return {
    type: RECEIVE_TRACE,
    trace
  };
}

const RECEIVE_CALL = exports.RECEIVE_CALL = "RECEIVE_CALL";
function receiveCall({
  address,
  binary,
  data,
  storageAddress,
  status,
  sender,
  value,
  gasprice,
  block
}) {
  return {
    type: RECEIVE_CALL,
    address,
    binary,
    data,
    storageAddress,
    status, //only used for creation calls at present!
    sender,
    value,
    gasprice,
    block
  };
}

const ERROR_WEB3 = exports.ERROR_WEB3 = "ERROR_WEB3";
function error(error) {
  return {
    type: ERROR_WEB3,
    error
  };
}

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _asyncToGenerator2 = __webpack_require__(15);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _web = __webpack_require__(34);

var _web2 = _interopRequireDefault(_web);

var _util = __webpack_require__(59);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:web3:adapter");

class Web3Adapter {
  constructor(provider) {
    this.web3 = new _web2.default(provider);
  }

  getTrace(txHash) {
    var _this = this;

    return (0, _asyncToGenerator3.default)(function* () {
      let result = yield (0, _util.promisify)(_this.web3.currentProvider.send)(
      //send *only* uses callbacks, so we use promsifiy to make things more
      //readable
      {
        jsonrpc: "2.0",
        method: "debug_traceTransaction",
        params: [txHash, {}],
        id: new Date().getTime()
      });
      if (result.error) {
        throw new Error(result.error.message);
      } else {
        return result.result.structLogs;
      }
    })();
  }

  getTransaction(txHash) {
    var _this2 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return yield _this2.web3.eth.getTransaction(txHash);
    })();
  }

  getReceipt(txHash) {
    var _this3 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return yield _this3.web3.eth.getTransactionReceipt(txHash);
    })();
  }

  getBlock(blockNumberOrHash) {
    var _this4 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return yield _this4.web3.eth.getBlock(blockNumberOrHash);
    })();
  }

  /**
   * getDeployedCode - get the deployed code for an address from the client
   * @param  {String} address
   * @return {String}         deployedBinary
   */
  getDeployedCode(address) {
    var _this5 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      debug("getting deployed code for %s", address);
      let code = yield _this5.web3.eth.getCode(address);
      return code === "0x0" ? "0x" : code;
    })();
  }
}
exports.default = Web3Adapter;

/***/ }),
/* 59 */
/***/ (function(module, exports) {

module.exports = require("util");

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ERROR = exports.ACTIVE = exports.WAITING = undefined;

var _redux = __webpack_require__(7);

var _reducers = __webpack_require__(61);

var _reducers2 = _interopRequireDefault(_reducers);

var _reducers3 = __webpack_require__(62);

var _reducers4 = _interopRequireDefault(_reducers3);

var _reducers5 = __webpack_require__(65);

var _reducers6 = _interopRequireDefault(_reducers5);

var _reducers7 = __webpack_require__(66);

var _reducers8 = _interopRequireDefault(_reducers7);

var _reducers9 = __webpack_require__(67);

var _reducers10 = _interopRequireDefault(_reducers9);

var _actions = __webpack_require__(16);

var actions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const WAITING = exports.WAITING = "WAITING";
const ACTIVE = exports.ACTIVE = "ACTIVE";
const ERROR = exports.ERROR = "ERROR";

function status(state = WAITING, action) {
  switch (action.type) {
    case actions.READY:
      return ACTIVE;

    case actions.ERROR:
      return { error: action.error };

    default:
      return state;
  }
}

function transaction(state = {}, action) {
  switch (action.type) {
    case actions.SAVE_TRANSACTION:
      return action.transaction;
    default:
      return state;
  }
}

function receipt(state = {}, action) {
  switch (action.type) {
    case actions.SAVE_RECEIPT:
      return action.receipt;
    default:
      return state;
  }
}

function block(state = {}, action) {
  switch (action.type) {
    case actions.SAVE_BLOCK:
      return action.block;
    default:
      return state;
  }
}

const session = (0, _redux.combineReducers)({
  status,
  transaction,
  receipt,
  block
});

const reduceState = (0, _redux.combineReducers)({
  session,
  data: _reducers2.default,
  evm: _reducers4.default,
  solidity: _reducers6.default,
  trace: _reducers8.default,
  controller: _reducers10.default
});

exports.default = reduceState;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _set = __webpack_require__(25);

var _set2 = _interopRequireDefault(_set);

var _values = __webpack_require__(11);

var _values2 = _interopRequireDefault(_values);

var _assign = __webpack_require__(6);

var _assign2 = _interopRequireDefault(_assign);

var _extends2 = __webpack_require__(2);

var _extends3 = _interopRequireDefault(_extends2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _redux = __webpack_require__(7);

var _actions = __webpack_require__(28);

var actions = _interopRequireWildcard(_actions);

var _truffleDecoder = __webpack_require__(22);

var _helpers = __webpack_require__(1);

var _truffleDecodeUtils = __webpack_require__(4);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:data:reducers");

const DEFAULT_SCOPES = {
  byId: {}
};

function scopes(state = DEFAULT_SCOPES, action) {
  var scope;
  var variables;

  switch (action.type) {
    case actions.SCOPE:
      scope = state.byId[action.id] || {};

      return {
        byId: (0, _extends3.default)({}, state.byId, {

          [action.id]: (0, _extends3.default)({}, scope, {

            id: action.id,
            sourceId: action.sourceId,
            parentId: action.parentId,
            pointer: action.pointer
          })
        })
      };

    case actions.DECLARE:
      scope = state.byId[action.node.scope] || {};
      variables = scope.variables || [];

      return {
        byId: (0, _extends3.default)({}, state.byId, {

          [action.node.scope]: (0, _extends3.default)({}, scope, {

            variables: [...variables, { name: action.node.name, id: action.node.id }]
          })
        })
      };

    default:
      return state;
  }
}

//a note on the following reducer: solidity assigns a unique AST ID to every
//AST node among all the files being compiled together.  thus, it is, for now,
//safe to identify user-defined types solely by their AST ID.  In the future,
//once we eventually support having some files compiled separately from others,
//this will become a bug you'll have to fix, and you'll have to fix it in the
//decoder, too.  Sorry, future me! (or whoever's stuck doing this)

function userDefinedTypes(state = [], action) {
  switch (action.type) {
    case actions.DEFINE_TYPE:
      return [...state, action.node.id];
    default:
      return state;
  }
}

const DEFAULT_ALLOCATIONS = {
  storage: {},
  memory: {},
  calldata: {}
};

function allocations(state = DEFAULT_ALLOCATIONS, action) {
  if (action.type === actions.ALLOCATE) {
    return {
      storage: action.storage,
      memory: action.memory,
      calldata: action.calldata
    };
  } else {
    return state;
  }
}

const info = (0, _redux.combineReducers)({
  scopes,
  userDefinedTypes,
  allocations
});

const GLOBAL_ASSIGNMENTS = [[{ builtin: "msg" }, { special: "msg" }], [{ builtin: "tx" }, { special: "tx" }], [{ builtin: "block" }, { special: "block" }], [{ builtin: "this" }, { special: "this" }], [{ builtin: "now" }, { special: "timestamp" }] //we don't have an alias "now"
].map(([idObj, ref]) => (0, _helpers.makeAssignment)(idObj, ref));

const DEFAULT_ASSIGNMENTS = {
  byId: (0, _assign2.default)({}, //we start out with all globals assigned
  ...GLOBAL_ASSIGNMENTS.map(assignment => ({ [assignment.id]: assignment }))),
  byAstId: {}, //no regular variables assigned at start
  byBuiltin: (0, _assign2.default)({}, //again, all globals start assigned
  ...GLOBAL_ASSIGNMENTS.map(assignment => ({
    [assignment.builtin]: [assignment.id] //yes, that's a 1-element array
  })))
};

function assignments(state = DEFAULT_ASSIGNMENTS, action) {
  switch (action.type) {
    case actions.ASSIGN:
    case actions.MAP_PATH_AND_ASSIGN:
      debug("action.type %O", action.type);
      debug("action.assignments %O", action.assignments);
      return (0, _values2.default)(action.assignments).reduce((acc, assignment) => {
        let { id, astId } = assignment;
        //we assume for now that only ordinary variables will be assigned this
        //way, and not globals; globals are handled in DEFAULT_ASSIGNMENTS
        return (0, _extends3.default)({}, acc, {
          byId: (0, _extends3.default)({}, acc.byId, {
            [id]: assignment
          }),
          byAstId: (0, _extends3.default)({}, acc.byAstId, {
            [astId]: [...new _set2.default([...(acc.byAstId[astId] || []), id])]
            //we use a set for uniqueness
          })
        });
      }, state);

    case actions.RESET:
      return DEFAULT_ASSIGNMENTS;

    default:
      return state;
  }
}

const DEFAULT_PATHS = {
  decodingStarted: 0,
  byAddress: {}
};

//WARNING: do *not* rely on mappedPaths to keep track of paths that do not
//involve mapping keys!  Yes, many will get mapped, but there is no guarantee.
//Only when mapping keys are involved does it necessarily work reliably --
//which is fine, as that's all we need it for.
function mappedPaths(state = DEFAULT_PATHS, action) {
  switch (action.type) {
    case actions.MAP_KEY_DECODING:
      debug("decoding started: %d", state.decodingStarted + (action.started ? 1 : -1));
      return (0, _extends3.default)({}, state, {
        decodingStarted: state.decodingStarted + (action.started ? 1 : -1)
      });
    case actions.MAP_PATH_AND_ASSIGN:
      let { address, slot, typeIdentifier, parentType } = action;
      //how this case works: first, we find the spot in our table (based on
      //address, type identifier, and slot address) where the new entry should
      //be added; if needed we set up all the objects needed along the way.  If
      //there's already something there, we do nothing.  If there's nothing
      //there, we record our given slot in that spot in that table -- however,
      //we alter it in one key way.  Before entry, we check if the slot's
      //*parent* has a spot in the table, based on address (same for both child
      //and parent), parentType, and the parent's slot address (which can be
      //found as the slotAddress of the slot's path object, if it exists -- if
      //it doesn't then we conclude that no the parent does not have a spot in
      //the table).  If the parent has a slot in the table already, then we
      //alter the child slot by replacing its path with the parent slot.  This
      //will keep the slotAddress the same, but since the versions kept in the
      //table here are supposed to preserve path information, we'll be
      //replacing a fairly bare-bones Slot object with one with a full path.

      //we do NOT want to distinguish between types with and without "_ptr" on
      //the end here!
      debug("typeIdentifier %s", typeIdentifier);
      typeIdentifier = _truffleDecodeUtils.Definition.restorePtr(typeIdentifier);
      parentType = _truffleDecodeUtils.Definition.restorePtr(parentType);

      debug("slot %o", slot);
      let hexSlotAddress = _truffleDecodeUtils.Conversion.toHexString((0, _truffleDecoder.slotAddress)(slot), _truffleDecodeUtils.EVM.WORD_SIZE);
      let parentAddress = slot.path ? _truffleDecodeUtils.Conversion.toHexString((0, _truffleDecoder.slotAddress)(slot.path), _truffleDecodeUtils.EVM.WORD_SIZE) : undefined;

      //this is going to be messy and procedural, sorry.  but let's start with
      //the easy stuff: create the new address if needed, clone if not
      let newState = (0, _extends3.default)({}, state, {
        byAddress: (0, _extends3.default)({}, state.byAddress, {
          [address]: {
            byType: (0, _extends3.default)({}, (state.byAddress[address] || { byType: {} }).byType)
          }
        })
      });

      //now, let's add in the new type, if needed
      newState.byAddress[address].byType = (0, _extends3.default)({}, newState.byAddress[address].byType, {
        [typeIdentifier]: {
          bySlotAddress: (0, _extends3.default)({}, (newState.byAddress[address].byType[typeIdentifier] || {
            bySlotAddress: {}
          }).bySlotAddress)
        }
      });

      let oldSlot = newState.byAddress[address].byType[typeIdentifier].bySlotAddress[hexSlotAddress];
      //yes, this looks strange, but we haven't changed it yet except to
      //clone or create empty (and we don't want undefined!)
      //now: is there something already there or no?  if no, we must add
      if (oldSlot === undefined) {
        let newSlot;
        debug("parentAddress %o", parentAddress);
        if (parentAddress !== undefined && newState.byAddress[address].byType[parentType] && newState.byAddress[address].byType[parentType].bySlotAddress[parentAddress]) {
          //if the parent is already present, use that instead of the given
          //parent!
          newSlot = (0, _extends3.default)({}, slot, {
            path: newState.byAddress[address].byType[parentType].bySlotAddress[parentAddress]
          });
        } else {
          newSlot = slot;
        }
        newState.byAddress[address].byType[typeIdentifier].bySlotAddress[hexSlotAddress] = newSlot;
      }
      //if there's already something there, we don't need to do anything

      return newState;

    case actions.RESET:
      return DEFAULT_PATHS;

    default:
      return state;
  }
}

const proc = (0, _redux.combineReducers)({
  assignments,
  mappedPaths
});

const reducer = (0, _redux.combineReducers)({
  info,
  proc
});

exports.default = reducer;

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _set = __webpack_require__(25);

var _set2 = _interopRequireDefault(_set);

var _from = __webpack_require__(63);

var _from2 = _interopRequireDefault(_from);

var _values = __webpack_require__(11);

var _values2 = _interopRequireDefault(_values);

var _entries = __webpack_require__(8);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(6);

var _assign2 = _interopRequireDefault(_assign);

var _extends2 = __webpack_require__(2);

var _extends3 = _interopRequireDefault(_extends2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _redux = __webpack_require__(7);

var _actions = __webpack_require__(31);

var actions = _interopRequireWildcard(_actions);

var _helpers = __webpack_require__(1);

var _truffleDecodeUtils = __webpack_require__(4);

var DecodeUtils = _interopRequireWildcard(_truffleDecodeUtils);

var _lodash = __webpack_require__(64);

var _lodash2 = _interopRequireDefault(_lodash);

var _bn = __webpack_require__(17);

var _bn2 = _interopRequireDefault(_bn);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:evm:reducers");

const DEFAULT_CONTEXTS = {
  byContexts: {}
};

function contexts(state = DEFAULT_CONTEXTS, action) {
  switch (action.type) {
    /*
     * Adding a new context
     */
    case actions.ADD_CONTEXT:
      {
        const {
          contractName,
          binary,
          sourceMap,
          compiler,
          abi,
          contractId,
          contractKind,
          isConstructor
        } = action;
        debug("action %O", action);
        //NOTE: we take hash as *string*, not as bytes, because the binary may
        //contain link references!
        const context = (0, _helpers.keccak256)({ type: "string", value: binary });
        let primarySource;
        if (sourceMap !== undefined) {
          primarySource = (0, _helpers.extractPrimarySource)(sourceMap);
        }
        //otherwise leave it undefined

        return (0, _extends3.default)({}, state, {
          byContext: (0, _extends3.default)({}, state.byContext, {
            [context]: {
              contractName,
              context,
              binary,
              sourceMap,
              primarySource,
              compiler,
              abi,
              contractId,
              contractKind,
              isConstructor
            }
          })
        });
      }

    case actions.NORMALIZE_CONTEXTS:
      {
        //unfortunately, due to our current link references format, we can't
        //really use the binary frm the artifact directly -- neither for purposes
        //of matching, nor for purposes of decoding internal functions.  So, we
        //need to perform this normalization step on our contexts before using
        //them.  Once we have truffle-db, this step should largely go away.

        debug("normalizing contexts");

        //first, let's clone the state; we're going to make some deep modifications,
        //so we'll want more than a shallow clone here
        let newState = {
          byContext: (0, _assign2.default)({}, ...(0, _entries2.default)(state.byContext).map(([id, context]) => ({
            [id]: (0, _extends3.default)({}, context)
          })))
        };

        debug("state cloned");

        //next, we get all the contract names and sort them descending by length.
        //We're going to want to go in descending order of length so that we
        //don't run into problems when one name is a substring of another.
        //For simplicity, we'll exclude names of length <38, because we can
        //handle these with our more general check for link references at the end
        const fillerLength = 2 * DecodeUtils.EVM.ADDRESS_SIZE;
        let names = (0, _values2.default)(newState.byContext).map(context => context.contractName).filter(name => name.length >= fillerLength - 3)
        //the -3 is for 2 leading underscores and 1 trailing
        .sort((name1, name2) => name2.length - name1.length);

        debug("names sorted");

        //now, we need to turn all these names into regular expressions, because,
        //unfortunately, str.replace() will only replace all if you use a /g regexp;
        //note that because names may contain '$', we need to escape them
        //(also we prepend "__" because that's the placeholder format)
        let regexps = names.map(name => new RegExp((0, _lodash2.default)("__" + name), "g"));

        debug("regexps prepared");

        //having done so, we can do the replace for these names!
        const replacement = ".".repeat(fillerLength);
        for (let regexp of regexps) {
          for (let context of (0, _values2.default)(newState.byContext)) {
            context.binary = context.binary.replace(regexp, replacement);
          }
        }

        debug("long replacements complete");

        //now we can do a generic replace that will catch all names of length
        //<40, while also catching the Solidity compiler's link reference format
        //as well as Truffle's.  Hooray!
        const genericRegexp = new RegExp("_.{" + (fillerLength - 2) + "}_", "g");
        //we're constructing the regexp /_.{38}_/g, but I didn't want to use a
        //literal 38 :P
        for (let context of (0, _values2.default)(newState.byContext)) {
          context.binary = context.binary.replace(genericRegexp, replacement);
        }

        debug("short replacements complete");
        //but there's one more step -- libraries' deployedBytecode will include
        //0s in place of their own address instead of a link reference at the
        //beginning, so we need to account for that too
        const pushAddressInstruction = (0x60 + DecodeUtils.EVM.ADDRESS_SIZE - 1).toString(16); //"73"
        for (let context of (0, _values2.default)(newState.byContext)) {
          if (context.contractKind === "library" && !context.isConstructor) {
            context.binary = context.binary.replace("0x" + pushAddressInstruction + "00".repeat(DecodeUtils.EVM.ADDRESS_SIZE), "0x" + pushAddressInstruction + replacement);
          }
        }

        debug("extra library replacements complete");

        //finally, return this mess!
        return newState;
      }

    /*
     * Default case
     */
    default:
      return state;
  }
}

const DEFAULT_INSTANCES = {
  byAddress: {},
  byContext: {}
};

function instances(state = DEFAULT_INSTANCES, action) {
  switch (action.type) {
    /*
     * Adding a new address for context
     */
    case actions.ADD_INSTANCE:
      let { address, context, binary } = action;

      // get known addresses for this context
      let otherInstances = state.byContext[context] || [];
      let otherAddresses = otherInstances.map(({ address }) => address);

      return {
        byAddress: (0, _extends3.default)({}, state.byAddress, {

          [address]: { address, context, binary }
        }),

        byContext: (0, _extends3.default)({}, state.byContext, {

          // reconstruct context instances to include new address
          [context]: (0, _from2.default)(new _set2.default(otherAddresses).add(address)).map(address => ({ address }))
        })
      };

    /*
     * Default case
     */
    default:
      return state;
  }
}

const DEFAULT_TX = {
  gasprice: new _bn2.default(0),
  origin: DecodeUtils.EVM.ZERO_ADDRESS
};

function tx(state = DEFAULT_TX, action) {
  if (action.type === actions.SAVE_GLOBALS) {
    let { gasprice, origin } = action;
    return { gasprice, origin };
  } else {
    return state;
  }
}

const DEFAULT_BLOCK = {
  coinbase: DecodeUtils.EVM.ZERO_ADDRESS,
  difficulty: new _bn2.default(0),
  gaslimit: new _bn2.default(0),
  number: new _bn2.default(0),
  timestamp: new _bn2.default(0)
};

function block(state = DEFAULT_BLOCK, action) {
  if (action.type === actions.SAVE_GLOBALS) {
    debug("action %O", action);
    return action.block;
  } else {
    return state;
  }
}

const globals = (0, _redux.combineReducers)({
  tx,
  block
});

const info = (0, _redux.combineReducers)({
  contexts,
  instances,
  globals
});

function callstack(state = [], action) {
  switch (action.type) {
    case actions.CALL:
      {
        const { address, data, storageAddress, sender, value } = action;
        return state.concat([{ address, data, storageAddress, sender, value }]);
      }

    case actions.CREATE:
      {
        const { binary, storageAddress, sender, value } = action;
        return state.concat([{ binary, data: "0x", storageAddress, sender, value }]
        //the empty data field is to make msg.data and msg.sig come out right
        );
      }

    case actions.RETURN:
    case actions.FAIL:
      //pop the stack... unless (HACK) that would leave it empty (this will
      //only happen at the end when we want to keep the last one around)
      return state.length > 1 ? state.slice(0, -1) : state;

    case actions.RESET:
      return [state[0]]; //leave the initial call still on the stack

    default:
      return state;
  }
}

//default codex stackframe with a single address (or none if address not
//supplied)
function defaultCodexFrame(address) {
  if (address !== undefined) {
    return {
      //there will be more here in the future!
      accounts: {
        [address]: {
          //there will be more here in the future!
          storage: {}
        }
      }
    };
  } else {
    return {
      //there will be more here in the future!
      accounts: {}
    };
  }
}

function codex(state = [], action) {
  let newState, topCodex;

  const updateFrameStorage = (frame, address, slot, value) => {
    let existingPage = frame.accounts[address] || { storage: {} };
    return (0, _extends3.default)({}, frame, {
      accounts: (0, _extends3.default)({}, frame.accounts, {
        [address]: (0, _extends3.default)({}, existingPage, {
          storage: (0, _extends3.default)({}, existingPage.storage, {
            [slot]: value
          })
        })
      })
    });
  };

  switch (action.type) {
    case actions.CALL:
    case actions.CREATE:
      //on a call or create, make a new stackframe, then add a new pages to the
      //codex if necessary; don't add a zero page though (or pages that already
      //exist)

      //first, add a new stackframe; if there's an existing stackframe, clone
      //that, otherwise make one from scratch
      newState = state.length > 0 ? [...state, state[state.length - 1]] : [defaultCodexFrame()];
      topCodex = newState[newState.length - 1];
      //now, do we need to add a new address to this stackframe?
      if (topCodex.accounts[action.storageAddress] !== undefined || action.storageAddress === DecodeUtils.EVM.ZERO_ADDRESS) {
        //if we don't
        return newState;
      }
      //if we do
      newState[newState.length - 1] = (0, _extends3.default)({}, topCodex, {
        accounts: (0, _extends3.default)({}, topCodex.accounts, {
          [action.storageAddress]: {
            storage: {}
            //there will be more here in the future!
          }
        })
      });
      return newState;

    case actions.STORE:
      {
        //on a store, the relevant page should already exist, so we can just
        //add or update the needed slot
        const { address, slot, value } = action;
        if (address === DecodeUtils.EVM.ZERO_ADDRESS) {
          //as always, we do not maintain a zero page
          return state;
        }
        newState = state.slice(); //clone the state
        topCodex = newState[newState.length - 1];
        newState[newState.length - 1] = updateFrameStorage(topCodex, address, slot, value);
        return newState;
      }

    case actions.LOAD:
      {
        //loads are a little more complicated -- usually we do nothing, but if
        //it's an external load (there was nothing already there), then we want
        //to update *every* stackframe
        const { address, slot, value } = action;
        if (address === DecodeUtils.EVM.ZERO_ADDRESS) {
          //as always, we do not maintain a zero page
          return state;
        }
        topCodex = state[state.length - 1];
        if (topCodex.accounts[address].storage[slot] !== undefined) {
          //if we already have a value in the *top* stackframe, update *no*
          //stackframes; don't update the top (no need, it's just a load, not a
          //store), don't update the rest (that would be wrong, you might be
          //loading a value that will get reverted later)
          return state;
        } else {
          //if we *don't* already have a value in the top stackframe, that means
          //we're loading a value from a previous transaction!  That's not a
          //value that will get reverted if this call fails, so update *every*
          //stackframe
          return state.map(frame => updateFrameStorage(frame, address, slot, value));
        }
      }

    case actions.RETURN:
      //we want to pop the top while making the new top a copy of the old top;
      //that is to say, we want to drop just the element *second* from the top
      //(although, HACK, if the stack only has one element, just leave it alone)
      return state.length > 1 ? state.slice(0, -2).concat([state[state.length - 1]]) : state;

    case actions.FAIL:
      //pop the stack... unless (HACK) that would leave it empty (this will
      //only happen at the end when we want to keep the last one around)
      return state.length > 1 ? state.slice(0, -1) : state;

    case actions.RESET:
      return [defaultCodexFrame(action.storageAddress)];

    default:
      return state;
  }
}

const proc = (0, _redux.combineReducers)({
  callstack,
  codex
});

const reducer = (0, _redux.combineReducers)({
  info,
  proc
});

exports.default = reducer;

/***/ }),
/* 63 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/array/from");

/***/ }),
/* 64 */
/***/ (function(module, exports) {

module.exports = require("lodash.escaperegexp");

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__(2);

var _extends3 = _interopRequireDefault(_extends2);

var _keys = __webpack_require__(21);

var _keys2 = _interopRequireDefault(_keys);

var _redux = __webpack_require__(7);

var _actions = __webpack_require__(33);

var actions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const DEFAULT_SOURCES = {
  byId: {}
};

function sources(state = DEFAULT_SOURCES, action) {
  switch (action.type) {
    /*
     * Adding a new source
     */
    case actions.ADD_SOURCE:
      let { ast, source, sourcePath, compiler } = action;

      let id = (0, _keys2.default)(state.byId).length;

      return {
        byId: (0, _extends3.default)({}, state.byId, {

          [id]: {
            id,
            ast,
            source,
            sourcePath,
            compiler
          }
        })
      };

    /*
     * Default case
     */
    default:
      return state;
  }
}

const info = (0, _redux.combineReducers)({
  sources
});

function functionDepthStack(state = [0], action) {
  switch (action.type) {
    case actions.JUMP:
      let newState = state.slice(); //clone the state
      const delta = spelunk(action.jumpDirection);
      let top = newState[newState.length - 1];
      newState[newState.length - 1] = top + delta;
      return newState;

    case actions.RESET:
      return [0];

    case actions.EXTERNAL_CALL:
      return [...state, state[state.length - 1] + 1];

    case actions.EXTERNAL_RETURN:
      //just pop the stack! unless, HACK, that would leave it empty
      return state.length > 1 ? state.slice(0, -1) : state;

    default:
      return state;
  }
}

function spelunk(jump) {
  if (jump === "i") {
    return 1;
  } else if (jump === "o") {
    return -1;
  } else {
    return 0;
  }
}

const proc = (0, _redux.combineReducers)({
  functionDepthStack
});

const reducer = (0, _redux.combineReducers)({
  info,
  proc
});

exports.default = reducer;

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _redux = __webpack_require__(7);

var _actions = __webpack_require__(13);

var actions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function index(state = 0, action) {
  switch (action.type) {
    case actions.TOCK:
      return state + 1;

    case actions.RESET:
      return 0;

    default:
      return state;
  }
}

function finished(state = false, action) {
  switch (action.type) {
    case actions.END_OF_TRACE:
      return true;

    case actions.RESET:
      return false;

    default:
      return state;
  }
}

function steps(state = null, action) {
  if (action.type === actions.SAVE_STEPS) {
    return action.steps;
  } else {
    return state;
  }
}

const info = (0, _redux.combineReducers)({
  steps
});

const proc = (0, _redux.combineReducers)({
  index,
  finished
});

const reducer = (0, _redux.combineReducers)({
  info,
  proc
});

exports.default = reducer;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _redux = __webpack_require__(7);

var _actions = __webpack_require__(18);

var actions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:controller:reducers");

function breakpoints(state = [], action) {
  switch (action.type) {
    case actions.ADD_BREAKPOINT:
      //check for any existing identical breakpoints to avoid redundancy
      if (state.filter(breakpoint => breakpoint.sourceId === action.breakpoint.sourceId && breakpoint.line === action.breakpoint.line && breakpoint.node === action.breakpoint.node //may be undefined
      ).length > 0) {
        //if it's already there, do nothing
        return state;
      } else {
        //otherwise add it
        return state.concat([action.breakpoint]);
      }
      break;

    case actions.REMOVE_BREAKPOINT:
      return state.filter(breakpoint => breakpoint.sourceId !== action.breakpoint.sourceId || breakpoint.line !== action.breakpoint.line || breakpoint.node !== action.breakpoint.node //may be undefined
      );
      break;

    case actions.REMOVE_ALL_BREAKPOINTS:
      return [];

    default:
      return state;
  }
}

const CONTROL_ACTIONS = [actions.ADVANCE, actions.STEP_NEXT, actions.STEP_OVER, actions.STEP_INTO, actions.STEP_OUT, actions.CONTINUE, actions.RESET];

function isStepping(state = false, action) {
  if (CONTROL_ACTIONS.includes(action.type)) {
    debug("got step start action");
    return true;
  } else if (action.type === actions.DONE_STEPPING) {
    debug("got step stop action");
    return false;
  } else {
    return state;
  }
}

const reducer = (0, _redux.combineReducers)({
  breakpoints,
  isStepping
});

exports.default = reducer;

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _entries = __webpack_require__(8);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(6);

var _assign2 = _interopRequireDefault(_assign);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(3);

var _selectors = __webpack_require__(9);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(10);

var _selectors4 = _interopRequireDefault(_selectors3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:session:selectors");

const session = (0, _reselectTree.createSelectorTree)({
  /**
   * session.info
   */
  info: {
    /**
     * session.info.affectedInstances
     */
    affectedInstances: (0, _reselectTree.createLeaf)([_selectors2.default.info.instances, _selectors2.default.info.contexts, _selectors4.default.info.sources], (instances, contexts, sources) => (0, _assign2.default)({}, ...(0, _entries2.default)(instances).map(([address, { context, binary }]) => {
      debug("instances %O", instances);
      debug("contexts %O", contexts);
      let { contractName, primarySource } = contexts[context];

      let source = primarySource !== undefined ? sources[primarySource] : undefined;

      return {
        [address]: {
          contractName,
          source,
          binary
        }
      };
    })))
  },

  /**
   * session.transaction (namespace)
   */
  transaction: {
    /**
     * session.transaction (selector)
     * contains the web3 transaction object
     */
    _: state => state.session.transaction,

    /**
     * session.transaction.receipt
     * contains the web3 receipt object
     */
    receipt: state => state.session.receipt,

    /**
     * session.transaction.block
     * contains the web3 block object
     */
    block: state => state.session.block
  }
});

exports.default = session;

/***/ })
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVidWdnZXIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2svYm9vdHN0cmFwIDczN2EzNzMwNzYxOWZhMzdhYjVhIiwiZXh0ZXJuYWwgXCJkZWJ1Z1wiIiwibGliL2hlbHBlcnMvaW5kZXguanMiLCJleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9leHRlbmRzXCIiLCJleHRlcm5hbCBcInJlc2VsZWN0LXRyZWVcIiIsImV4dGVybmFsIFwidHJ1ZmZsZS1kZWNvZGUtdXRpbHNcIiIsImV4dGVybmFsIFwicmVkdXgtc2FnYS9lZmZlY3RzXCIiLCJleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduXCIiLCJleHRlcm5hbCBcInJlZHV4XCIiLCJleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZW50cmllc1wiIiwibGliL2V2bS9zZWxlY3RvcnMvaW5kZXguanMiLCJsaWIvc29saWRpdHkvc2VsZWN0b3JzL2luZGV4LmpzIiwiZXh0ZXJuYWwgXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L3ZhbHVlc1wiIiwibGliL3RyYWNlL3NlbGVjdG9ycy9pbmRleC5qcyIsImxpYi90cmFjZS9hY3Rpb25zL2luZGV4LmpzIiwibGliL3RyYWNlL3NhZ2FzL2luZGV4LmpzIiwiZXh0ZXJuYWwgXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiIiwibGliL3Nlc3Npb24vYWN0aW9ucy9pbmRleC5qcyIsImV4dGVybmFsIFwiYm4uanNcIiIsImxpYi9jb250cm9sbGVyL2FjdGlvbnMvaW5kZXguanMiLCJsaWIvZGF0YS9zZWxlY3RvcnMvaW5kZXguanMiLCJleHRlcm5hbCBcImpzb24tcG9pbnRlclwiIiwiZXh0ZXJuYWwgXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2tleXNcIiIsImV4dGVybmFsIFwidHJ1ZmZsZS1kZWNvZGVyXCIiLCJsaWIvY29udHJvbGxlci9zZWxlY3RvcnMvaW5kZXguanMiLCJsaWIvZGF0YS9zYWdhcy9pbmRleC5qcyIsImV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL3NldFwiIiwiZXh0ZXJuYWwgXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvcHJvbWlzZVwiIiwibGliL2FzdC9tYXAuanMiLCJsaWIvZGF0YS9hY3Rpb25zL2luZGV4LmpzIiwibGliL2FzdC9zZWxlY3RvcnMvaW5kZXguanMiLCJsaWIvZXZtL3NhZ2FzL2luZGV4LmpzIiwibGliL2V2bS9hY3Rpb25zL2luZGV4LmpzIiwibGliL3NvbGlkaXR5L3NhZ2FzL2luZGV4LmpzIiwibGliL3NvbGlkaXR5L2FjdGlvbnMvaW5kZXguanMiLCJleHRlcm5hbCBcIndlYjNcIiIsIi9Vc2Vycy9mYWluYXNoYWx0cy90cnVmZmxlLWRldi90cnVmZmxlL3BhY2thZ2VzL3RydWZmbGUtZGVidWdnZXIvZGVidWdnZXIuanMiLCJsaWIvZGVidWdnZXIuanMiLCJleHRlcm5hbCBcInRydWZmbGUtZXhwZWN0XCIiLCJsaWIvc2Vzc2lvbi9pbmRleC5qcyIsImxpYi9zdG9yZS9pbmRleC5qcyIsImxpYi9zdG9yZS9wcm9kdWN0aW9uLmpzIiwibGliL3N0b3JlL2NvbW1vbi5qcyIsImV4dGVybmFsIFwicmVkdXgtc2FnYVwiIiwiZXh0ZXJuYWwgXCJyZWR1eC1jbGktbG9nZ2VyXCIiLCIvVXNlcnMvZmFpbmFzaGFsdHMvdHJ1ZmZsZS1kZXYvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvanNvbi1zdGFibGUtc3RyaW5naWZ5L2luZGV4LmpzIiwiL1VzZXJzL2ZhaW5hc2hhbHRzL3RydWZmbGUtZGV2L3RydWZmbGUvbm9kZV9tb2R1bGVzL2pzb25pZnkvaW5kZXguanMiLCIvVXNlcnMvZmFpbmFzaGFsdHMvdHJ1ZmZsZS1kZXYvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvanNvbmlmeS9saWIvcGFyc2UuanMiLCIvVXNlcnMvZmFpbmFzaGFsdHMvdHJ1ZmZsZS1kZXYvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvanNvbmlmeS9saWIvc3RyaW5naWZ5LmpzIiwiZXh0ZXJuYWwgXCJ0cnVmZmxlLXNvbGlkaXR5LXV0aWxzXCIiLCJleHRlcm5hbCBcInRydWZmbGUtY29kZS11dGlsc1wiIiwiL1VzZXJzL2ZhaW5hc2hhbHRzL3RydWZmbGUtZGV2L3RydWZmbGUvbm9kZV9tb2R1bGVzL25vZGUtaW50ZXJ2YWwtdHJlZS9saWIvaW5kZXguanMiLCIvVXNlcnMvZmFpbmFzaGFsdHMvdHJ1ZmZsZS1kZXYvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvc2hhbGxvd2VxdWFsL2luZGV4LmpzIiwibGliL3Nlc3Npb24vc2FnYXMvaW5kZXguanMiLCJsaWIvYXN0L3NhZ2FzL2luZGV4LmpzIiwiZXh0ZXJuYWwgXCJsb2Rhc2guc3VtXCIiLCJsaWIvY29udHJvbGxlci9zYWdhcy9pbmRleC5qcyIsImxpYi93ZWIzL3NhZ2FzL2luZGV4LmpzIiwibGliL3dlYjMvYWN0aW9ucy9pbmRleC5qcyIsImxpYi93ZWIzL2FkYXB0ZXIuanMiLCJleHRlcm5hbCBcInV0aWxcIiIsImxpYi9zZXNzaW9uL3JlZHVjZXJzLmpzIiwibGliL2RhdGEvcmVkdWNlcnMuanMiLCJsaWIvZXZtL3JlZHVjZXJzLmpzIiwiZXh0ZXJuYWwgXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvYXJyYXkvZnJvbVwiIiwiZXh0ZXJuYWwgXCJsb2Rhc2guZXNjYXBlcmVnZXhwXCIiLCJsaWIvc29saWRpdHkvcmVkdWNlcnMuanMiLCJsaWIvdHJhY2UvcmVkdWNlcnMuanMiLCJsaWIvY29udHJvbGxlci9yZWR1Y2Vycy5qcyIsImxpYi9zZXNzaW9uL3NlbGVjdG9ycy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShcIkRlYnVnZ2VyXCIsIFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIkRlYnVnZ2VyXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIkRlYnVnZ2VyXCJdID0gZmFjdG9yeSgpO1xufSkodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAzNSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgNzM3YTM3MzA3NjE5ZmEzN2FiNWEiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImRlYnVnXCJcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICogYXMgdXRpbHMgZnJvbSBcInRydWZmbGUtZGVjb2RlLXV0aWxzXCI7XG5cbmNvbnN0IHN0cmluZ2lmeSA9IHJlcXVpcmUoXCJqc29uLXN0YWJsZS1zdHJpbmdpZnlcIik7XG5cbi8qKiBBU1Qgbm9kZSB0eXBlcyB0aGF0IGFyZSBza2lwcGVkIGJ5IHN0ZXBOZXh0KCkgdG8gZmlsdGVyIG91dCBzb21lIG5vaXNlICovXG5leHBvcnQgZnVuY3Rpb24gaXNEZWxpYmVyYXRlbHlTa2lwcGVkTm9kZVR5cGUobm9kZSkge1xuICBjb25zdCBza2lwcGVkVHlwZXMgPSBbXCJDb250cmFjdERlZmluaXRpb25cIiwgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCJdO1xuICByZXR1cm4gc2tpcHBlZFR5cGVzLmluY2x1ZGVzKG5vZGUubm9kZVR5cGUpO1xufVxuXG4vL0hBQ0tcbi8vdGhlc2UgYXJlbid0IHRoZSBvbmx5IHR5cGVzIG9mIHNraXBwZWQgbm9kZXMsIGJ1dCBkZXRlcm1pbmluZyBhbGwgc2tpcHBlZFxuLy9ub2RlcyB3b3VsZCBiZSB0b28gZGlmZmljdWx0XG5leHBvcnQgZnVuY3Rpb24gaXNTa2lwcGVkTm9kZVR5cGUobm9kZSkge1xuICBjb25zdCBvdGhlclNraXBwZWRUeXBlcyA9IFtcIlZhcmlhYmxlRGVjbGFyYXRpb25TdGF0ZW1lbnRcIiwgXCJNYXBwaW5nXCJdO1xuICByZXR1cm4gKFxuICAgIGlzRGVsaWJlcmF0ZWx5U2tpcHBlZE5vZGVUeXBlKG5vZGUpIHx8XG4gICAgb3RoZXJTa2lwcGVkVHlwZXMuaW5jbHVkZXMobm9kZS5ub2RlVHlwZSkgfHxcbiAgICBub2RlLm5vZGVUeXBlLmluY2x1ZGVzKFwiVHlwZU5hbWVcIikgfHwgLy9IQUNLXG4gICAgLy9za2lwIHN0cmluZyBsaXRlcmFscyB0b28gLS0gd2UnbGwgaGFuZGxlIHRoYXQgbWFudWFsbHlcbiAgICAobm9kZS50eXBlRGVzY3JpcHRpb25zICE9PSB1bmRlZmluZWQgJiYgLy9zZWVtcyB0aGlzIHNvbWV0aW1lcyBoYXBwZW5zP1xuICAgICAgdXRpbHMuRGVmaW5pdGlvbi50eXBlQ2xhc3Mobm9kZSkgPT09IFwic3RyaW5nbGl0ZXJhbFwiKVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJlZml4TmFtZShwcmVmaXgsIGZuKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwgXCJuYW1lXCIsIHtcbiAgICB2YWx1ZTogYCR7cHJlZml4fS4ke2ZuLm5hbWV9YCxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG5cbiAgcmV0dXJuIGZuO1xufVxuXG4vKlxuICogZXh0cmFjdCB0aGUgcHJpbWFyeSBzb3VyY2UgZnJvbSBhIHNvdXJjZSBtYXBcbiAqIChpLmUuLCB0aGUgc291cmNlIGZvciB0aGUgZmlyc3QgaW5zdHJ1Y3Rpb24sIGZvdW5kXG4gKiBiZXR3ZWVuIHRoZSBzZWNvbmQgYW5kIHRoaXJkIGNvbG9ucylcbiAqICh0aGlzIGlzIHNvbWV0aGluZyBvZiBhIEhBQ0spXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0UHJpbWFyeVNvdXJjZShzb3VyY2VNYXApIHtcbiAgcmV0dXJuIHBhcnNlSW50KHNvdXJjZU1hcC5tYXRjaCgvXlteOl0rOlteOl0rOihbXjpdKyk6LylbMV0pO1xufVxuXG4vKipcbiAqIEByZXR1cm4gMHgtcHJlZml4IHN0cmluZyBvZiBrZWNjYWsyNTYgaGFzaFxuICovXG5leHBvcnQgZnVuY3Rpb24ga2VjY2FrMjU2KC4uLmFyZ3MpIHtcbiAgcmV0dXJuIHV0aWxzLkNvbnZlcnNpb24udG9IZXhTdHJpbmcodXRpbHMuRVZNLmtlY2NhazI1NiguLi5hcmdzKSk7XG59XG5cbi8qKlxuICogR2l2ZW4gYW4gb2JqZWN0LCByZXR1cm4gYSBzdGFibGUgaGFzaCBieSBmaXJzdCBydW5uaW5nIGl0IHRocm91Z2ggYSBzdGFibGVcbiAqIHN0cmluZ2lmeSBvcGVyYXRpb24gYmVmb3JlIGhhc2hpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YWJsZUtlY2NhazI1NihvYmopIHtcbiAgcmV0dXJuIGtlY2NhazI1Nih7IHR5cGU6IFwic3RyaW5nXCIsIHZhbHVlOiBzdHJpbmdpZnkob2JqKSB9KTtcbn1cblxuLypcbiAqIHVzZWQgYnkgZGF0YTsgdGFrZXMgYW4gaWQgb2JqZWN0IGFuZCBhIHJlZiAocG9pbnRlcikgYW5kIHJldHVybnMgYSBmdWxsXG4gKiBjb3JyZXNwb25kaW5nIGFzc2lnbm1lbnQgb2JqZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlQXNzaWdubWVudChpZE9iaiwgcmVmKSB7XG4gIGxldCBpZCA9IHN0YWJsZUtlY2NhazI1NihpZE9iaik7XG4gIHJldHVybiB7IC4uLmlkT2JqLCBpZCwgcmVmIH07XG59XG5cbi8qXG4gKiBHaXZlbiBhIG1tZW1vbmljLCBkZXRlcm1pbmUgd2hldGhlciBpdCdzIHRoZSBtbmVtb25pYyBvZiBhIGNhbGxpbmdcbiAqIGluc3RydWN0aW9uIChkb2VzIE5PVCBpbmNsdWRlIGNyZWF0aW9uIGluc3RydWN0aW9ucylcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQ2FsbE1uZW1vbmljKG9wKSB7XG4gIGNvbnN0IGNhbGxzID0gW1wiQ0FMTFwiLCBcIkRFTEVHQVRFQ0FMTFwiLCBcIlNUQVRJQ0NBTExcIiwgXCJDQUxMQ09ERVwiXTtcbiAgcmV0dXJuIGNhbGxzLmluY2x1ZGVzKG9wKTtcbn1cblxuLypcbiAqIHJldHVybnMgdHJ1ZSBmb3IgbW5lbW9uaWNzIGZvciBjYWxscyB0aGF0IHRha2Ugb25seSA2IGFyZ3MgaW5zdGVhZCBvZiA3XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1Nob3J0Q2FsbE1uZW1vbmljKG9wKSB7XG4gIGNvbnN0IHNob3J0Q2FsbHMgPSBbXCJERUxFR0FURUNBTExcIiwgXCJTVEFUSUNDQUxMXCJdO1xuICByZXR1cm4gc2hvcnRDYWxscy5pbmNsdWRlcyhvcCk7XG59XG5cbi8qXG4gKiByZXR1cm5zIHRydWUgZm9yIG1uZW1vbmljcyBmb3IgY2FsbHMgdGhhdCBkZWxlZ2F0ZSBzdG9yYWdlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0RlbGVnYXRlQ2FsbE1uZW1vbmljQnJvYWQob3ApIHtcbiAgY29uc3QgZGVsZWdhdGVDYWxscyA9IFtcIkRFTEVHQVRFQ0FMTFwiLCBcIkNBTExDT0RFXCJdO1xuICByZXR1cm4gZGVsZWdhdGVDYWxscy5pbmNsdWRlcyhvcCk7XG59XG5cbi8qXG4gKiByZXR1cm5zIHRydWUgZm9yIG1uZW1vbmljcyBmb3IgY2FsbHMgdGhhdCBkZWxlZ2F0ZSBldmVyeXRoaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0RlbGVnYXRlQ2FsbE1uZW1vbmljU3RyaWN0KG9wKSB7XG4gIGNvbnN0IGRlbGVnYXRlQ2FsbHMgPSBbXCJERUxFR0FURUNBTExcIl07XG4gIHJldHVybiBkZWxlZ2F0ZUNhbGxzLmluY2x1ZGVzKG9wKTtcbn1cblxuLypcbiAqIHJldHVybnMgdHJ1ZSBmb3IgbW5lbW9uaWNzIGZvciBzdGF0aWMgY2FsbHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU3RhdGljQ2FsbE1uZW1vbmljKG9wKSB7XG4gIGNvbnN0IGRlbGVnYXRlQ2FsbHMgPSBbXCJTVEFUSUNDQUxMXCJdO1xuICByZXR1cm4gZGVsZWdhdGVDYWxscy5pbmNsdWRlcyhvcCk7XG59XG5cbi8qXG4gKiBHaXZlbiBhIG1tZW1vbmljLCBkZXRlcm1pbmUgd2hldGhlciBpdCdzIHRoZSBtbmVtb25pYyBvZiBhIGNyZWF0aW9uXG4gKiBpbnN0cnVjdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNDcmVhdGVNbmVtb25pYyhvcCkge1xuICBjb25zdCBjcmVhdGVzID0gW1wiQ1JFQVRFXCIsIFwiQ1JFQVRFMlwiXTtcbiAgcmV0dXJuIGNyZWF0ZXMuaW5jbHVkZXMob3ApO1xufVxuXG4vKlxuICogR2l2ZW4gYSBtbWVtb25pYywgZGV0ZXJtaW5lIHdoZXRoZXIgaXQncyB0aGUgbW5lbW9uaWMgb2YgYSBub3JtYWxcbiAqIGhhbHRpbmcgaW5zdHJ1Y3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTm9ybWFsSGFsdGluZ01uZW1vbmljKG9wKSB7XG4gIGNvbnN0IGhhbHRzID0gW1wiU1RPUFwiLCBcIlJFVFVSTlwiLCBcIlNFTEZERVNUUlVDVFwiLCBcIlNVSUNJREVcIl07XG4gIC8vdGhlIG1uZW1vbmljIFNVSUNJREUgaXMgbm8gbG9uZ2VyIHVzZWQsIGJ1dCBqdXN0IGluIGNhc2UsIEknbSBpbmNsdWRpbmcgaXRcbiAgcmV0dXJuIGhhbHRzLmluY2x1ZGVzKG9wKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvaGVscGVycy9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9leHRlbmRzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2V4dGVuZHNcIlxuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZXNlbGVjdC10cmVlXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwicmVzZWxlY3QtdHJlZVwiXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInRydWZmbGUtZGVjb2RlLXV0aWxzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwidHJ1ZmZsZS1kZWNvZGUtdXRpbHNcIlxuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWR1eC1zYWdhL2VmZmVjdHNcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJyZWR1eC1zYWdhL2VmZmVjdHNcIlxuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2Fzc2lnblwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduXCJcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVkdXhcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJyZWR1eFwiXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZW50cmllc1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZW50cmllc1wiXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjpldm06c2VsZWN0b3JzXCIpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbmltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yVHJlZSwgY3JlYXRlTGVhZiB9IGZyb20gXCJyZXNlbGVjdC10cmVlXCI7XG5pbXBvcnQgQk4gZnJvbSBcImJuLmpzXCI7XG5cbmltcG9ydCB0cmFjZSBmcm9tIFwibGliL3RyYWNlL3NlbGVjdG9yc1wiO1xuXG5pbXBvcnQgKiBhcyBEZWNvZGVVdGlscyBmcm9tIFwidHJ1ZmZsZS1kZWNvZGUtdXRpbHNcIjtcbmltcG9ydCB7XG4gIGlzQ2FsbE1uZW1vbmljLFxuICBpc0NyZWF0ZU1uZW1vbmljLFxuICBpc1Nob3J0Q2FsbE1uZW1vbmljLFxuICBpc0RlbGVnYXRlQ2FsbE1uZW1vbmljQnJvYWQsXG4gIGlzRGVsZWdhdGVDYWxsTW5lbW9uaWNTdHJpY3QsXG4gIGlzU3RhdGljQ2FsbE1uZW1vbmljLFxuICBpc05vcm1hbEhhbHRpbmdNbmVtb25pY1xufSBmcm9tIFwibGliL2hlbHBlcnNcIjtcblxuZnVuY3Rpb24gbWF0Y2hDb250ZXh0KHsgYmluYXJ5LCBpc0NvbnN0cnVjdG9yIH0sIGdpdmVuQmluYXJ5KSB7XG4gIGxldCBsZW5ndGhEaWZmZXJlbmNlID0gZ2l2ZW5CaW5hcnkubGVuZ3RoIC0gYmluYXJ5Lmxlbmd0aDtcbiAgLy9maXJzdDogaWYgaXQncyBub3QgYSBjb25zdHJ1Y3RvciwgdGhleSdkIGJldHRlciBiZSBlcXVhbCBpbiBsZW5ndGguXG4gIC8vaWYgaXQgaXMgYSBjb25zdHJ1Y3RvciwgdGhlIGdpdmVuIGJpbmFyeSBtdXN0IGJlIGF0IGxlYXN0IGFzIGxvbmcsXG4gIC8vYW5kIHRoZSBkaWZmZXJlbmNlIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NFxuICBpZiAoXG4gICAgKCFpc0NvbnN0cnVjdG9yICYmIGxlbmd0aERpZmZlcmVuY2UgIT09IDApIHx8XG4gICAgbGVuZ3RoRGlmZmVyZW5jZSA8IDAgfHxcbiAgICBsZW5ndGhEaWZmZXJlbmNlICUgKDIgKiBEZWNvZGVVdGlscy5FVk0uV09SRF9TSVpFKSAhPT0gMFxuICApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW5hcnkubGVuZ3RoOyBpKyspIHtcbiAgICAvL25vdGU6IHVzaW5nIHN0cmluZ3MgbGlrZSBhcnJheXMgaXMga2luZCBvZiBkYW5nZXJvdXMgaW4gZ2VuZXJhbCBpbiBKUyxcbiAgICAvL2J1dCBldmVyeXRoaW5nIGhlcmUgaXMgQVNDSUkgc28gaXQncyBmaW5lXG4gICAgLy9ub3RlIHRoYXQgd2UgbmVlZCB0byBjb21wYXJlIGNhc2UtaW5zZW5zaXRpdmUsIHNpbmNlIFNvbGlkaXR5IHdpbGxcbiAgICAvL3B1dCBhZGRyZXNzZXMgaW4gY2hlY2tzdW0gY2FzZSBpbiB0aGUgY29tcGlsZWQgc291cmNlXG4gICAgLy8od2UgZG9uJ3QgYWN0dWFsbHkgbmVlZCB0aGF0IHNlY29uZCB0b0xvd2VyQ2FzZSgpLCBidXQgd2hhdGV2ZXIpXG4gICAgaWYgKFxuICAgICAgYmluYXJ5W2ldICE9PSBcIi5cIiAmJlxuICAgICAgYmluYXJ5W2ldLnRvTG93ZXJDYXNlKCkgIT09IGdpdmVuQmluYXJ5W2ldLnRvTG93ZXJDYXNlKClcbiAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogY3JlYXRlIEVWTS1sZXZlbCBzZWxlY3RvcnMgZm9yIGEgZ2l2ZW4gdHJhY2Ugc3RlcCBzZWxlY3RvclxuICogbWF5IHNwZWNpZnkgYWRkaXRpb25hbCBzZWxlY3RvcnMgdG8gaW5jbHVkZVxuICovXG5mdW5jdGlvbiBjcmVhdGVTdGVwU2VsZWN0b3JzKHN0ZXAsIHN0YXRlID0gbnVsbCkge1xuICBsZXQgYmFzZSA9IHtcbiAgICAvKipcbiAgICAgKiAudHJhY2VcbiAgICAgKlxuICAgICAqIHRyYWNlIHN0ZXAgaW5mbyByZWxhdGVkIHRvIG9wZXJhdGlvblxuICAgICAqL1xuICAgIHRyYWNlOiBjcmVhdGVMZWFmKFtzdGVwXSwgKHsgZ2FzQ29zdCwgb3AsIHBjIH0pID0+ICh7IGdhc0Nvc3QsIG9wLCBwYyB9KSksXG5cbiAgICAvKipcbiAgICAgKiAucHJvZ3JhbUNvdW50ZXJcbiAgICAgKi9cbiAgICBwcm9ncmFtQ291bnRlcjogY3JlYXRlTGVhZihbXCIuL3RyYWNlXCJdLCBzdGVwID0+IHN0ZXAucGMpLFxuXG4gICAgLyoqXG4gICAgICogLmlzSnVtcFxuICAgICAqL1xuICAgIGlzSnVtcDogY3JlYXRlTGVhZihcbiAgICAgIFtcIi4vdHJhY2VcIl0sXG4gICAgICBzdGVwID0+IHN0ZXAub3AgIT0gXCJKVU1QREVTVFwiICYmIHN0ZXAub3AuaW5kZXhPZihcIkpVTVBcIikgPT0gMFxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiAuaXNDYWxsXG4gICAgICpcbiAgICAgKiB3aGV0aGVyIHRoZSBvcGNvZGUgd2lsbCBzd2l0Y2ggdG8gYW5vdGhlciBjYWxsaW5nIGNvbnRleHRcbiAgICAgKi9cbiAgICBpc0NhbGw6IGNyZWF0ZUxlYWYoW1wiLi90cmFjZVwiXSwgc3RlcCA9PiBpc0NhbGxNbmVtb25pYyhzdGVwLm9wKSksXG5cbiAgICAvKipcbiAgICAgKiAuaXNTaG9ydENhbGxcbiAgICAgKlxuICAgICAqIGZvciBjYWxscyB0aGF0IG9ubHkgdGFrZSA2IGFyZ3VtZW50cyBpbnN0ZWFkIG9mIDdcbiAgICAgKi9cbiAgICBpc1Nob3J0Q2FsbDogY3JlYXRlTGVhZihbXCIuL3RyYWNlXCJdLCBzdGVwID0+IGlzU2hvcnRDYWxsTW5lbW9uaWMoc3RlcC5vcCkpLFxuXG4gICAgLyoqXG4gICAgICogLmlzRGVsZWdhdGVDYWxsQnJvYWRcbiAgICAgKlxuICAgICAqIGZvciBjYWxscyB0aGF0IGRlbGVnYXRlIHN0b3JhZ2VcbiAgICAgKi9cbiAgICBpc0RlbGVnYXRlQ2FsbEJyb2FkOiBjcmVhdGVMZWFmKFtcIi4vdHJhY2VcIl0sIHN0ZXAgPT5cbiAgICAgIGlzRGVsZWdhdGVDYWxsTW5lbW9uaWNCcm9hZChzdGVwLm9wKVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiAuaXNEZWxlZ2F0ZUNhbGxTdHJpY3RcbiAgICAgKlxuICAgICAqIGZvciBjYWxscyB0aGF0IGFkZGl0aW9uYWxseSBkZWxlZ2F0ZSBzZW5kZXIgYW5kIHZhbHVlXG4gICAgICovXG4gICAgaXNEZWxlZ2F0ZUNhbGxTdHJpY3Q6IGNyZWF0ZUxlYWYoW1wiLi90cmFjZVwiXSwgc3RlcCA9PlxuICAgICAgaXNEZWxlZ2F0ZUNhbGxNbmVtb25pY1N0cmljdChzdGVwLm9wKVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiAuaXNTdGF0aWNDYWxsXG4gICAgICovXG4gICAgaXNTdGF0aWNDYWxsOiBjcmVhdGVMZWFmKFtcIi4vdHJhY2VcIl0sIHN0ZXAgPT5cbiAgICAgIGlzU3RhdGljQ2FsbE1uZW1vbmljKHN0ZXAub3ApXG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIC5pc0NyZWF0ZVxuICAgICAqL1xuICAgIGlzQ3JlYXRlOiBjcmVhdGVMZWFmKFtcIi4vdHJhY2VcIl0sIHN0ZXAgPT4gaXNDcmVhdGVNbmVtb25pYyhzdGVwLm9wKSksXG5cbiAgICAvKipcbiAgICAgKiAuaXNIYWx0aW5nXG4gICAgICpcbiAgICAgKiB3aGV0aGVyIHRoZSBpbnN0cnVjdGlvbiBoYWx0cyBvciByZXR1cm5zIGZyb20gYSBjYWxsaW5nIGNvbnRleHRcbiAgICAgKiAoY292ZXJzIG9ubHkgb3JkaW5hcnkgaGFsZHMsIG5vdCBleGNlcHRpb25hbCBoYWx0cylcbiAgICAgKi9cbiAgICBpc0hhbHRpbmc6IGNyZWF0ZUxlYWYoW1wiLi90cmFjZVwiXSwgc3RlcCA9PlxuICAgICAgaXNOb3JtYWxIYWx0aW5nTW5lbW9uaWMoc3RlcC5vcClcbiAgICApLFxuXG4gICAgLypcbiAgICAgKiAuaXNTdG9yZVxuICAgICAqL1xuICAgIGlzU3RvcmU6IGNyZWF0ZUxlYWYoW1wiLi90cmFjZVwiXSwgc3RlcCA9PiBzdGVwLm9wID09IFwiU1NUT1JFXCIpLFxuXG4gICAgLypcbiAgICAgKiAuaXNMb2FkXG4gICAgICovXG4gICAgaXNMb2FkOiBjcmVhdGVMZWFmKFtcIi4vdHJhY2VcIl0sIHN0ZXAgPT4gc3RlcC5vcCA9PSBcIlNMT0FEXCIpLFxuXG4gICAgLypcbiAgICAgKiAudG91Y2hlc1N0b3JhZ2VcbiAgICAgKlxuICAgICAqIHdoZXRoZXIgdGhlIGluc3RydWN0aW9uIGludm9sdmVzIHN0b3JhZ2VcbiAgICAgKi9cbiAgICB0b3VjaGVzU3RvcmFnZTogY3JlYXRlTGVhZihcbiAgICAgIFtcIi4vaXNTdG9yZVwiLCBcImlzTG9hZFwiXSxcbiAgICAgIChzdG9yZXMsIGxvYWRzKSA9PiBzdG9yZXMgfHwgbG9hZHNcbiAgICApXG4gIH07XG5cbiAgaWYgKHN0YXRlKSB7XG4gICAgY29uc3QgaXNSZWxhdGl2ZSA9IHBhdGggPT5cbiAgICAgIHR5cGVvZiBwYXRoID09IFwic3RyaW5nXCIgJiZcbiAgICAgIChwYXRoLnN0YXJ0c1dpdGgoXCIuL1wiKSB8fCBwYXRoLnN0YXJ0c1dpdGgoXCIuLi9cIikpO1xuXG4gICAgaWYgKGlzUmVsYXRpdmUoc3RhdGUpKSB7XG4gICAgICBzdGF0ZSA9IGAuLi8ke3N0YXRlfWA7XG4gICAgfVxuXG4gICAgT2JqZWN0LmFzc2lnbihiYXNlLCB7XG4gICAgICAvKipcbiAgICAgICAqIC5jYWxsQWRkcmVzc1xuICAgICAgICpcbiAgICAgICAqIGFkZHJlc3MgdHJhbnNmZXJyZWQgdG8gYnkgY2FsbCBvcGVyYXRpb25cbiAgICAgICAqL1xuICAgICAgY2FsbEFkZHJlc3M6IGNyZWF0ZUxlYWYoXG4gICAgICAgIFtcIi4vaXNDYWxsXCIsIHN0YXRlXSxcblxuICAgICAgICAobWF0Y2hlcywgeyBzdGFjayB9KSA9PiB7XG4gICAgICAgICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgYWRkcmVzcyA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDJdO1xuICAgICAgICAgIHJldHVybiBEZWNvZGVVdGlscy5Db252ZXJzaW9uLnRvQWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgKSxcblxuICAgICAgLyoqXG4gICAgICAgKiAuY3JlYXRlQmluYXJ5XG4gICAgICAgKlxuICAgICAgICogYmluYXJ5IGNvZGUgdG8gZXhlY3V0ZSB2aWEgY3JlYXRlIG9wZXJhdGlvblxuICAgICAgICovXG4gICAgICBjcmVhdGVCaW5hcnk6IGNyZWF0ZUxlYWYoXG4gICAgICAgIFtcIi4vaXNDcmVhdGVcIiwgc3RhdGVdLFxuXG4gICAgICAgIChtYXRjaGVzLCB7IHN0YWNrLCBtZW1vcnkgfSkgPT4ge1xuICAgICAgICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gR2V0IHRoZSBjb2RlIHRoYXQncyBnb2luZyB0byBiZSBjcmVhdGVkIGZyb20gbWVtb3J5LlxuICAgICAgICAgIC8vIE5vdGUgd2UgbXVsdGlwbHkgYnkgMiBiZWNhdXNlIHRoZXNlIG9mZnNldHMgYXJlIGluIGJ5dGVzLlxuICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHBhcnNlSW50KHN0YWNrW3N0YWNrLmxlbmd0aCAtIDJdLCAxNikgKiAyO1xuICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHBhcnNlSW50KHN0YWNrW3N0YWNrLmxlbmd0aCAtIDNdLCAxNikgKiAyO1xuXG4gICAgICAgICAgcmV0dXJuIFwiMHhcIiArIG1lbW9yeS5qb2luKFwiXCIpLnN1YnN0cmluZyhvZmZzZXQsIG9mZnNldCArIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICksXG5cbiAgICAgIC8qKlxuICAgICAgICogLmNhbGxEYXRhXG4gICAgICAgKlxuICAgICAgICogZGF0YSBwYXNzZWQgdG8gRVZNIGNhbGxcbiAgICAgICAqL1xuICAgICAgY2FsbERhdGE6IGNyZWF0ZUxlYWYoXG4gICAgICAgIFtcIi4vaXNDYWxsXCIsIFwiLi9pc1Nob3J0Q2FsbFwiLCBzdGF0ZV0sXG4gICAgICAgIChtYXRjaGVzLCBzaG9ydCwgeyBzdGFjaywgbWVtb3J5IH0pID0+IHtcbiAgICAgICAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vaWYgaXQncyA2LWFyZ3VtZW50IGNhbGwsIHRoZSBkYXRhIHN0YXJ0IGFuZCBvZmZzZXQgd2lsbCBiZSBvbmUgc3BvdFxuICAgICAgICAgIC8vaGlnaGVyIGluIHRoZSBzdGFjayB0aGFuIHRoZXkgd291bGQgYmUgZm9yIGEgNy1hcmd1bWVudCBjYWxsLCBzb1xuICAgICAgICAgIC8vbGV0J3MgaW50cm9kdWNlIGFuIG9mZnNldCB0byBoYW5kbGUgdGhpc1xuICAgICAgICAgIGxldCBhcmdPZmZzZXQgPSBzaG9ydCA/IDEgOiAwO1xuXG4gICAgICAgICAgLy8gR2V0IHRoZSBkYXRhIGZyb20gbWVtb3J5LlxuICAgICAgICAgIC8vIE5vdGUgd2UgbXVsdGlwbHkgYnkgMiBiZWNhdXNlIHRoZXNlIG9mZnNldHMgYXJlIGluIGJ5dGVzLlxuICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHBhcnNlSW50KHN0YWNrW3N0YWNrLmxlbmd0aCAtIDQgKyBhcmdPZmZzZXRdLCAxNikgKiAyO1xuICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHBhcnNlSW50KHN0YWNrW3N0YWNrLmxlbmd0aCAtIDUgKyBhcmdPZmZzZXRdLCAxNikgKiAyO1xuXG4gICAgICAgICAgcmV0dXJuIFwiMHhcIiArIG1lbW9yeS5qb2luKFwiXCIpLnN1YnN0cmluZyhvZmZzZXQsIG9mZnNldCArIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICksXG5cbiAgICAgIC8qKlxuICAgICAgICogLmNhbGxWYWx1ZVxuICAgICAgICpcbiAgICAgICAqIHZhbHVlIGZvciB0aGUgY2FsbCAobm90IGNyZWF0ZSk7IHJldHVybnMgbnVsbCBmb3IgREVMRUdBVEVDQUxMXG4gICAgICAgKi9cbiAgICAgIGNhbGxWYWx1ZTogY3JlYXRlTGVhZihcbiAgICAgICAgW1wiLi9pc0NhbGxcIiwgXCIuL2lzRGVsZWdhdGVDYWxsU3RyaWN0XCIsIFwiLi9pc1N0YXRpY0NhbGxcIiwgc3RhdGVdLFxuICAgICAgICAoY2FsbHMsIGRlbGVnYXRlcywgaXNTdGF0aWMsIHsgc3RhY2sgfSkgPT4ge1xuICAgICAgICAgIGlmICghY2FsbHMgfHwgZGVsZWdhdGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNTdGF0aWMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQk4oMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy9vdGhlcndpc2UsIGZvciBDQUxMIGFuZCBDQUxMQ09ERSwgaXQncyB0aGUgM3JkIGFyZ3VtZW50XG4gICAgICAgICAgbGV0IHZhbHVlID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gM107XG4gICAgICAgICAgcmV0dXJuIERlY29kZVV0aWxzLkNvbnZlcnNpb24udG9CTih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICksXG5cbiAgICAgIC8qKlxuICAgICAgICogLmNyZWF0ZVZhbHVlXG4gICAgICAgKlxuICAgICAgICogdmFsdWUgZm9yIHRoZSBjcmVhdGVcbiAgICAgICAqL1xuICAgICAgY3JlYXRlVmFsdWU6IGNyZWF0ZUxlYWYoW1wiLi9pc0NyZWF0ZVwiLCBzdGF0ZV0sIChtYXRjaGVzLCB7IHN0YWNrIH0pID0+IHtcbiAgICAgICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvL2NyZWF0ZXMgaGF2ZSB0aGUgdmFsdWUgYXMgdGhlIGZpcnN0IGFyZ3VtZW50XG4gICAgICAgIGxldCB2YWx1ZSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gRGVjb2RlVXRpbHMuQ29udmVyc2lvbi50b0JOKHZhbHVlKTtcbiAgICAgIH0pLFxuXG4gICAgICAvKipcbiAgICAgICAqIC5zdG9yYWdlQWZmZWN0ZWRcbiAgICAgICAqXG4gICAgICAgKiBzdG9yYWdlIHNsb3QgYmVpbmcgc3RvcmVkIHRvIG9yIGxvYWRlZCBmcm9tXG4gICAgICAgKiB3ZSBkbyBOT1QgcHJlcGVuZCBcIjB4XCJcbiAgICAgICAqL1xuICAgICAgc3RvcmFnZUFmZmVjdGVkOiBjcmVhdGVMZWFmKFxuICAgICAgICBbXCIuL3RvdWNoZXNTdG9yYWdlXCIsIHN0YXRlXSxcblxuICAgICAgICAobWF0Y2hlcywgeyBzdGFjayB9KSA9PiB7XG4gICAgICAgICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgIClcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBiYXNlO1xufVxuXG5jb25zdCBldm0gPSBjcmVhdGVTZWxlY3RvclRyZWUoe1xuICAvKipcbiAgICogZXZtLnN0YXRlXG4gICAqL1xuICBzdGF0ZTogc3RhdGUgPT4gc3RhdGUuZXZtLFxuXG4gIC8qKlxuICAgKiBldm0uaW5mb1xuICAgKi9cbiAgaW5mbzoge1xuICAgIC8qKlxuICAgICAqIGV2bS5pbmZvLmNvbnRleHRzXG4gICAgICovXG4gICAgY29udGV4dHM6IGNyZWF0ZUxlYWYoW1wiL3N0YXRlXCJdLCBzdGF0ZSA9PiBzdGF0ZS5pbmZvLmNvbnRleHRzLmJ5Q29udGV4dCksXG5cbiAgICAvKipcbiAgICAgKiBldm0uaW5mby5pbnN0YW5jZXNcbiAgICAgKi9cbiAgICBpbnN0YW5jZXM6IGNyZWF0ZUxlYWYoW1wiL3N0YXRlXCJdLCBzdGF0ZSA9PiBzdGF0ZS5pbmZvLmluc3RhbmNlcy5ieUFkZHJlc3MpLFxuXG4gICAgLyoqXG4gICAgICogZXZtLmluZm8uYmluYXJpZXNcbiAgICAgKi9cbiAgICBiaW5hcmllczoge1xuICAgICAgLyoqXG4gICAgICAgKiBldm0uaW5mby5iaW5hcmllcy5zZWFyY2hcbiAgICAgICAqXG4gICAgICAgKiByZXR1cm5zIGZ1bmN0aW9uIChiaW5hcnkpID0+IGNvbnRleHQgKHJldHVybnMgdGhlICpJRCogb2YgdGhlIGNvbnRleHQpXG4gICAgICAgKiAocmV0dXJucyBudWxsIG9uIG5vIG1hdGNoKVxuICAgICAgICovXG4gICAgICBzZWFyY2g6IGNyZWF0ZUxlYWYoW1wiL2luZm8vY29udGV4dHNcIl0sIGNvbnRleHRzID0+IGJpbmFyeSA9PiB7XG4gICAgICAgIGRlYnVnKFwiYmluYXJ5ICVzXCIsIGJpbmFyeSk7XG4gICAgICAgIGxldCBjb250ZXh0ID0gT2JqZWN0LnZhbHVlcyhjb250ZXh0cykuZmluZChjb250ZXh0ID0+XG4gICAgICAgICAgbWF0Y2hDb250ZXh0KGNvbnRleHQsIGJpbmFyeSlcbiAgICAgICAgKTtcbiAgICAgICAgZGVidWcoXCJjb250ZXh0IGZvdW5kOiAlT1wiLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQgIT09IHVuZGVmaW5lZCA/IGNvbnRleHQuY29udGV4dCA6IG51bGw7XG4gICAgICB9KVxuICAgIH0sXG5cbiAgICAvKlxuICAgICAqIGV2bS5pbmZvLmdsb2JhbHNcbiAgICAgKi9cbiAgICBnbG9iYWxzOiB7XG4gICAgICAvKlxuICAgICAgICogZXZtLmluZm8uZ2xvYmFscy50eFxuICAgICAgICovXG4gICAgICB0eDogY3JlYXRlTGVhZihbXCIvc3RhdGVcIl0sIHN0YXRlID0+IHN0YXRlLmluZm8uZ2xvYmFscy50eCksXG4gICAgICAvKlxuICAgICAgICogZXZtLmluZm8uZ2xvYmFscy5ibG9ja1xuICAgICAgICovXG4gICAgICBibG9jazogY3JlYXRlTGVhZihbXCIvc3RhdGVcIl0sIHN0YXRlID0+IHN0YXRlLmluZm8uZ2xvYmFscy5ibG9jaylcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIGV2bS5jdXJyZW50XG4gICAqL1xuICBjdXJyZW50OiB7XG4gICAgLyoqXG4gICAgICogZXZtLmN1cnJlbnQuY2FsbHN0YWNrXG4gICAgICovXG4gICAgY2FsbHN0YWNrOiBzdGF0ZSA9PiBzdGF0ZS5ldm0ucHJvYy5jYWxsc3RhY2ssXG5cbiAgICAvKipcbiAgICAgKiBldm0uY3VycmVudC5jYWxsXG4gICAgICovXG4gICAgY2FsbDogY3JlYXRlTGVhZihcbiAgICAgIFtcIi4vY2FsbHN0YWNrXCJdLFxuXG4gICAgICBzdGFjayA9PiAoc3RhY2subGVuZ3RoID8gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gOiB7fSlcbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogZXZtLmN1cnJlbnQuY29udGV4dFxuICAgICAqL1xuICAgIGNvbnRleHQ6IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIuL2NhbGxcIiwgXCIvaW5mby9pbnN0YW5jZXNcIiwgXCIvaW5mby9iaW5hcmllcy9zZWFyY2hcIiwgXCIvaW5mby9jb250ZXh0c1wiXSxcbiAgICAgICh7IGFkZHJlc3MsIGJpbmFyeSB9LCBpbnN0YW5jZXMsIHNlYXJjaCwgY29udGV4dHMpID0+IHtcbiAgICAgICAgbGV0IGNvbnRleHRJZDtcbiAgICAgICAgaWYgKGFkZHJlc3MpIHtcbiAgICAgICAgICAvL2lmIHdlJ3JlIGluIGEgY2FsbCB0byBhIGRlcGxveWVkIGNvbnRyYWN0LCB3ZSAqbXVzdCogaGF2ZSByZWNvcmRlZFxuICAgICAgICAgIC8vaXQgaW4gdGhlIGluc3RhbmNlIHRhYmxlLCBzbyB3ZSBqdXN0IG5lZWQgdG8gbG9vayB1cCB0aGUgY29udGV4dCBJRFxuICAgICAgICAgIC8vZnJvbSB0aGVyZTsgd2UgZG9uJ3QgbmVlZCB0byBkbyBhbnkgZnVydGhlciBzZWFyY2hpbmdcbiAgICAgICAgICBjb250ZXh0SWQgPSBpbnN0YW5jZXNbYWRkcmVzc10uY29udGV4dDtcbiAgICAgICAgICBiaW5hcnkgPSBpbnN0YW5jZXNbYWRkcmVzc10uYmluYXJ5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vb3RoZXJ3aXNlLCBpZiB3ZSdyZSBpbiBhIGNvbnN0cnVjdG9yLCB3ZSdsbCBuZWVkIHRvIGFjdHVhbGx5IGRvIGFcbiAgICAgICAgICAvL3NlYXJjaFxuICAgICAgICAgIGNvbnRleHRJZCA9IHNlYXJjaChiaW5hcnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNvbnRleHQgPSBjb250ZXh0c1tjb250ZXh0SWRdO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uY29udGV4dCxcbiAgICAgICAgICBiaW5hcnlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogZXZtLmN1cnJlbnQuc3RhdGVcbiAgICAgKlxuICAgICAqIGV2bSBzdGF0ZSBpbmZvOiBhcyBvZiBsYXN0IG9wZXJhdGlvbiwgYmVmb3JlIG9wIGRlZmluZWQgaW4gc3RlcFxuICAgICAqL1xuICAgIHN0YXRlOiBPYmplY3QuYXNzaWduKFxuICAgICAge30sXG4gICAgICAuLi5bXCJkZXB0aFwiLCBcImVycm9yXCIsIFwiZ2FzXCIsIFwibWVtb3J5XCIsIFwic3RhY2tcIiwgXCJzdG9yYWdlXCJdLm1hcChwYXJhbSA9PiAoe1xuICAgICAgICBbcGFyYW1dOiBjcmVhdGVMZWFmKFt0cmFjZS5zdGVwXSwgc3RlcCA9PiBzdGVwW3BhcmFtXSlcbiAgICAgIH0pKVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBldm0uY3VycmVudC5zdGVwXG4gICAgICovXG4gICAgc3RlcDoge1xuICAgICAgLi4uY3JlYXRlU3RlcFNlbGVjdG9ycyh0cmFjZS5zdGVwLCBcIi4vc3RhdGVcIiksXG5cbiAgICAgIC8vdGhlIGZvbGxvd2luZyBzdGVwIHNlbGVjdG9ycyBvbmx5IGV4aXN0IGZvciBjdXJyZW50LCBub3QgbmV4dCBvciBhbnlcbiAgICAgIC8vb3RoZXIgc3RlcFxuXG4gICAgICAvKlxuICAgICAgICogZXZtLmN1cnJlbnQuc3RlcC5jcmVhdGVkQWRkcmVzc1xuICAgICAgICpcbiAgICAgICAqIGFkZHJlc3MgY3JlYXRlZCBieSB0aGUgY3VycmVudCBjcmVhdGUgc3RlcFxuICAgICAgICovXG4gICAgICBjcmVhdGVkQWRkcmVzczogY3JlYXRlTGVhZihcbiAgICAgICAgW1wiLi9pc0NyZWF0ZVwiLCBcIi9uZXh0T2ZTYW1lRGVwdGgvc3RhdGUvc3RhY2tcIl0sXG4gICAgICAgIChtYXRjaGVzLCBzdGFjaykgPT4ge1xuICAgICAgICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBhZGRyZXNzID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgICAgcmV0dXJuIERlY29kZVV0aWxzLkNvbnZlcnNpb24udG9BZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICApLFxuXG4gICAgICAvKipcbiAgICAgICAqIGV2bS5jdXJyZW50LnN0ZXAuY2FsbHNQcmVjb21waWxlT3JFeHRlcm5hbFxuICAgICAgICpcbiAgICAgICAqIGFyZSB3ZSBjYWxsaW5nIGEgcHJlY29tcGlsZWQgY29udHJhY3Qgb3IgYW4gZXh0ZXJuYWxseS1vd25lZCBhY2NvdW50LFxuICAgICAgICogcmF0aGVyIHRoYW4gYSBjb250cmFjdCBhY2NvdW50IHRoYXQgaXNuJ3QgcHJlY29tcGlsZWQ/XG4gICAgICAgKi9cbiAgICAgIGNhbGxzUHJlY29tcGlsZU9yRXh0ZXJuYWw6IGNyZWF0ZUxlYWYoXG4gICAgICAgIFtcIi4vaXNDYWxsXCIsIFwiL2N1cnJlbnQvc3RhdGUvZGVwdGhcIiwgXCIvbmV4dC9zdGF0ZS9kZXB0aFwiXSxcbiAgICAgICAgKGNhbGxzLCBjdXJyZW50RGVwdGgsIG5leHREZXB0aCkgPT4gY2FsbHMgJiYgY3VycmVudERlcHRoID09PSBuZXh0RGVwdGhcbiAgICAgICksXG5cbiAgICAgIC8qKlxuICAgICAgICogZXZtLmN1cnJlbnQuc3RlcC5pc0NvbnRleHRDaGFuZ2VcbiAgICAgICAqIGdyb3VwcyB0b2dldGhlciBjYWxscywgY3JlYXRlcywgaGFsdHMsIGFuZCBleGNlcHRpb25hbCBoYWx0c1xuICAgICAgICovXG4gICAgICBpc0NvbnRleHRDaGFuZ2U6IGNyZWF0ZUxlYWYoXG4gICAgICAgIFtcIi9jdXJyZW50L3N0YXRlL2RlcHRoXCIsIFwiL25leHQvc3RhdGUvZGVwdGhcIl0sXG4gICAgICAgIChjdXJyZW50RGVwdGgsIG5leHREZXB0aCkgPT4gY3VycmVudERlcHRoICE9PSBuZXh0RGVwdGhcbiAgICAgICksXG5cbiAgICAgIC8qKlxuICAgICAgICogZXZtLmN1cnJlbnQuc3RlcC5pc0V4Y2VwdGlvbmFsSGFsdGluZ1xuICAgICAgICpcbiAgICAgICAqL1xuICAgICAgaXNFeGNlcHRpb25hbEhhbHRpbmc6IGNyZWF0ZUxlYWYoXG4gICAgICAgIFtcIi4vaXNIYWx0aW5nXCIsIFwiL2N1cnJlbnQvc3RhdGUvZGVwdGhcIiwgXCIvbmV4dC9zdGF0ZS9kZXB0aFwiXSxcbiAgICAgICAgKGhhbHRpbmcsIGN1cnJlbnREZXB0aCwgbmV4dERlcHRoKSA9PlxuICAgICAgICAgIG5leHREZXB0aCA8IGN1cnJlbnREZXB0aCAmJiAhaGFsdGluZ1xuICAgICAgKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBldm0uY3VycmVudC5jb2RleCAobmFtZXNwYWNlKVxuICAgICAqL1xuICAgIGNvZGV4OiB7XG4gICAgICAvKipcbiAgICAgICAqIGV2bS5jdXJyZW50LmNvZGV4IChzZWxlY3RvcilcbiAgICAgICAqIHRoZSB3aG9sZSBjb2RleCEgbm90IHRoYXQgdGhhdCdzIHZlcnkgbXVjaCBhdCB0aGUgbW9tZW50XG4gICAgICAgKi9cbiAgICAgIF86IGNyZWF0ZUxlYWYoW1wiL3N0YXRlXCJdLCBzdGF0ZSA9PiBzdGF0ZS5wcm9jLmNvZGV4KSxcblxuICAgICAgLyoqXG4gICAgICAgKiBldm0uY3VycmVudC5jb2RleC5zdG9yYWdlXG4gICAgICAgKiB0aGUgY3VycmVudCBzdG9yYWdlLCBhcyBmZXRjaGVkIGZyb20gdGhlIGNvZGV4Li4uIHVubGVzcyB3ZSdyZSBpbiBhXG4gICAgICAgKiBmYWlsZWQgY3JlYXRpb24gY2FsbCwgdGhlbiB3ZSBqdXN0IGZhbGwgYmFjayBvbiB0aGUgc3RhdGUgKHdoaWNoIHdpbGxcbiAgICAgICAqIHdvcmssIHNpbmNlIG5vdGhpbmcgZWxzZSBjYW4gaW50ZXJmZXJlIHdpdGggdGhlIHN0b3JhZ2Ugb2YgYSBmYWlsZWRcbiAgICAgICAqIGNyZWF0aW9uIGNhbGwhKVxuICAgICAgICovXG4gICAgICBzdG9yYWdlOiBjcmVhdGVMZWFmKFxuICAgICAgICBbXCIuL19cIiwgXCIuLi9zdGF0ZS9zdG9yYWdlXCIsIFwiLi4vY2FsbFwiXSxcbiAgICAgICAgKGNvZGV4LCByYXdTdG9yYWdlLCB7IHN0b3JhZ2VBZGRyZXNzIH0pID0+XG4gICAgICAgICAgc3RvcmFnZUFkZHJlc3MgPT09IERlY29kZVV0aWxzLkVWTS5aRVJPX0FERFJFU1NcbiAgICAgICAgICAgID8gcmF3U3RvcmFnZSAvL0hBQ0sgLS0gaWYgemVybyBhZGRyZXNzIGlnbm9yZSB0aGUgY29kZXhcbiAgICAgICAgICAgIDogY29kZXhbY29kZXgubGVuZ3RoIC0gMV0uYWNjb3VudHNbc3RvcmFnZUFkZHJlc3NdLnN0b3JhZ2VcbiAgICAgIClcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIGV2bS5uZXh0XG4gICAqL1xuICBuZXh0OiB7XG4gICAgLyoqXG4gICAgICogZXZtLm5leHQuc3RhdGVcbiAgICAgKlxuICAgICAqIGV2bSBzdGF0ZSBhcyBhIHJlc3VsdCBvZiBuZXh0IHN0ZXAgb3BlcmF0aW9uXG4gICAgICovXG4gICAgc3RhdGU6IE9iamVjdC5hc3NpZ24oXG4gICAgICB7fSxcbiAgICAgIC4uLltcImRlcHRoXCIsIFwiZXJyb3JcIiwgXCJnYXNcIiwgXCJtZW1vcnlcIiwgXCJzdGFja1wiLCBcInN0b3JhZ2VcIl0ubWFwKHBhcmFtID0+ICh7XG4gICAgICAgIFtwYXJhbV06IGNyZWF0ZUxlYWYoW3RyYWNlLm5leHRdLCBzdGVwID0+IHN0ZXBbcGFyYW1dKVxuICAgICAgfSkpXG4gICAgKSxcblxuICAgIC8qXG4gICAgICogZXZtLm5leHQuc3RlcFxuICAgICAqL1xuICAgIHN0ZXA6IGNyZWF0ZVN0ZXBTZWxlY3RvcnModHJhY2UubmV4dCwgXCIuL3N0YXRlXCIpXG4gIH0sXG5cbiAgLyoqXG4gICAqIGV2bS5uZXh0T2ZTYW1lRGVwdGhcbiAgICovXG4gIG5leHRPZlNhbWVEZXB0aDoge1xuICAgIC8qKlxuICAgICAqIGV2bS5uZXh0T2ZTYW1lRGVwdGguc3RhdGVcbiAgICAgKlxuICAgICAqIGV2bSBzdGF0ZSBhdCB0aGUgbmV4dCBzdGVwIG9mIHNhbWUgZGVwdGhcbiAgICAgKi9cbiAgICBzdGF0ZTogT2JqZWN0LmFzc2lnbihcbiAgICAgIHt9LFxuICAgICAgLi4uW1wiZGVwdGhcIiwgXCJlcnJvclwiLCBcImdhc1wiLCBcIm1lbW9yeVwiLCBcInN0YWNrXCIsIFwic3RvcmFnZVwiXS5tYXAocGFyYW0gPT4gKHtcbiAgICAgICAgW3BhcmFtXTogY3JlYXRlTGVhZihbdHJhY2UubmV4dE9mU2FtZURlcHRoXSwgc3RlcCA9PiBzdGVwW3BhcmFtXSlcbiAgICAgIH0pKVxuICAgIClcbiAgfVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGV2bTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvZXZtL3NlbGVjdG9ycy9pbmRleC5qcyIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjpzb2xpZGl0eTpzZWxlY3RvcnNcIik7XG5cbmltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yVHJlZSwgY3JlYXRlTGVhZiB9IGZyb20gXCJyZXNlbGVjdC10cmVlXCI7XG5pbXBvcnQgU29saWRpdHlVdGlscyBmcm9tIFwidHJ1ZmZsZS1zb2xpZGl0eS11dGlsc1wiO1xuaW1wb3J0IENvZGVVdGlscyBmcm9tIFwidHJ1ZmZsZS1jb2RlLXV0aWxzXCI7XG5cbmltcG9ydCB7IGZpbmRSYW5nZSB9IGZyb20gXCJsaWIvYXN0L21hcFwiO1xuaW1wb3J0IGpzb25wb2ludGVyIGZyb20gXCJqc29uLXBvaW50ZXJcIjtcblxuaW1wb3J0IGV2bSBmcm9tIFwibGliL2V2bS9zZWxlY3RvcnNcIjtcbmltcG9ydCB0cmFjZSBmcm9tIFwibGliL3RyYWNlL3NlbGVjdG9yc1wiO1xuXG5mdW5jdGlvbiBnZXRTb3VyY2VSYW5nZShpbnN0cnVjdGlvbiA9IHt9KSB7XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IGluc3RydWN0aW9uLnN0YXJ0IHx8IDAsXG4gICAgbGVuZ3RoOiBpbnN0cnVjdGlvbi5sZW5ndGggfHwgMCxcbiAgICBsaW5lczogaW5zdHJ1Y3Rpb24ucmFuZ2UgfHwge1xuICAgICAgc3RhcnQ6IHtcbiAgICAgICAgbGluZTogMCxcbiAgICAgICAgY29sdW1uOiAwXG4gICAgICB9LFxuICAgICAgZW5kOiB7XG4gICAgICAgIGxpbmU6IDAsXG4gICAgICAgIGNvbHVtbjogMFxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuLy9mdW5jdGlvbiB0byBjcmVhdGUgc2VsZWN0b3JzIHRoYXQgbmVlZCBib3RoIGEgY3VycmVudCBhbmQgbmV4dCB2ZXJzaW9uXG5mdW5jdGlvbiBjcmVhdGVNdWx0aXN0ZXBTZWxlY3RvcnMoc3RlcFNlbGVjdG9yKSB7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogLmluc3RydWN0aW9uXG4gICAgICovXG4gICAgaW5zdHJ1Y3Rpb246IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIvY3VycmVudC9pbnN0cnVjdGlvbkF0UHJvZ3JhbUNvdW50ZXJcIiwgc3RlcFNlbGVjdG9yLnByb2dyYW1Db3VudGVyXSxcbiAgICAgIC8vSEFDSzogd2UgdXNlIHNvbGlkaXR5LmN1cnJlbnQuaW5zdHJ1Y3Rpb25BdFByb2dyYW1Db3VudGVyXG4gICAgICAvL2V2ZW4gaWYgd2UncmUgbG9va2luZyBhdCBzb2xpZGl0eS5uZXh0LlxuICAgICAgLy9UaGlzIGlzIGhhcm1sZXNzLi4uIHNvIGxvbmcgYXMgdGhlIGN1cnJlbnQgaW5zdHJ1Y3Rpb24gaXNuJ3QgYSBjb250ZXh0XG4gICAgICAvL2NoYW5nZS4gIFNvLCBkb24ndCB1c2Ugc29saWRpdHkubmV4dCB3aGVuIGl0IGlzLlxuXG4gICAgICAobWFwLCBwYykgPT4gbWFwW3BjXSB8fCB7fVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiAuc291cmNlXG4gICAgICovXG4gICAgc291cmNlOiBjcmVhdGVMZWFmKFxuICAgICAgW1wiL2luZm8vc291cmNlc1wiLCBcIi4vaW5zdHJ1Y3Rpb25cIl0sXG5cbiAgICAgIChzb3VyY2VzLCB7IGZpbGU6IGlkIH0pID0+IHNvdXJjZXNbaWRdIHx8IHt9XG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIC5zb3VyY2VSYW5nZVxuICAgICAqL1xuICAgIHNvdXJjZVJhbmdlOiBjcmVhdGVMZWFmKFtcIi4vaW5zdHJ1Y3Rpb25cIl0sIGdldFNvdXJjZVJhbmdlKSxcblxuICAgIC8qKlxuICAgICAqIC5wb2ludGVyXG4gICAgICovXG4gICAgcG9pbnRlcjogY3JlYXRlTGVhZihcbiAgICAgIFtcIi4vc291cmNlXCIsIFwiLi9zb3VyY2VSYW5nZVwiXSxcblxuICAgICAgKHsgYXN0IH0sIHJhbmdlKSA9PiBmaW5kUmFuZ2UoYXN0LCByYW5nZS5zdGFydCwgcmFuZ2UubGVuZ3RoKVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiAubm9kZVxuICAgICAqL1xuICAgIG5vZGU6IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIuL3NvdXJjZVwiLCBcIi4vcG9pbnRlclwiXSxcbiAgICAgICh7IGFzdCB9LCBwb2ludGVyKSA9PlxuICAgICAgICBwb2ludGVyID8ganNvbnBvaW50ZXIuZ2V0KGFzdCwgcG9pbnRlcikgOiBqc29ucG9pbnRlci5nZXQoYXN0LCBcIlwiKVxuICAgIClcbiAgfTtcbn1cblxubGV0IHNvbGlkaXR5ID0gY3JlYXRlU2VsZWN0b3JUcmVlKHtcbiAgLyoqXG4gICAqIHNvbGlkaXR5LnN0YXRlXG4gICAqL1xuICBzdGF0ZTogc3RhdGUgPT4gc3RhdGUuc29saWRpdHksXG5cbiAgLyoqXG4gICAqIHNvbGlkaXR5LmluZm9cbiAgICovXG4gIGluZm86IHtcbiAgICAvKipcbiAgICAgKiBzb2xpZGl0eS5pbmZvLnNvdXJjZXNcbiAgICAgKi9cbiAgICBzb3VyY2VzOiBjcmVhdGVMZWFmKFtcIi9zdGF0ZVwiXSwgc3RhdGUgPT4gc3RhdGUuaW5mby5zb3VyY2VzLmJ5SWQpXG4gIH0sXG5cbiAgLyoqXG4gICAqIHNvbGlkaXR5LmN1cnJlbnRcbiAgICovXG4gIGN1cnJlbnQ6IHtcbiAgICAvKipcbiAgICAgKiBzb2xpZGl0eS5jdXJyZW50LnNvdXJjZU1hcFxuICAgICAqL1xuICAgIHNvdXJjZU1hcDogY3JlYXRlTGVhZihcbiAgICAgIFtldm0uY3VycmVudC5jb250ZXh0XSxcblxuICAgICAgKHsgc291cmNlTWFwIH0pID0+IHNvdXJjZU1hcFxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBzb2xpZGl0eS5jdXJyZW50LmZ1bmN0aW9uRGVwdGhTdGFja1xuICAgICAqL1xuICAgIGZ1bmN0aW9uRGVwdGhTdGFjazogc3RhdGUgPT4gc3RhdGUuc29saWRpdHkucHJvYy5mdW5jdGlvbkRlcHRoU3RhY2ssXG5cbiAgICAvKipcbiAgICAgKiBzb2xpZGl0eS5jdXJyZW50LmZ1bmN0aW9uRGVwdGhcbiAgICAgKi9cbiAgICBmdW5jdGlvbkRlcHRoOiBjcmVhdGVMZWFmKFxuICAgICAgW1wiLi9mdW5jdGlvbkRlcHRoU3RhY2tcIl0sXG4gICAgICBzdGFjayA9PiBzdGFja1tzdGFjay5sZW5ndGggLSAxXVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBzb2xpZGl0eS5jdXJyZW50Lmluc3RydWN0aW9uc1xuICAgICAqL1xuICAgIGluc3RydWN0aW9uczogY3JlYXRlTGVhZihcbiAgICAgIFtcIi9pbmZvL3NvdXJjZXNcIiwgZXZtLmN1cnJlbnQuY29udGV4dCwgXCIuL3NvdXJjZU1hcFwiXSxcblxuICAgICAgKHNvdXJjZXMsIHsgYmluYXJ5IH0sIHNvdXJjZU1hcCkgPT4ge1xuICAgICAgICBpZiAoIWJpbmFyeSkge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBudW1JbnN0cnVjdGlvbnM7XG4gICAgICAgIGlmIChzb3VyY2VNYXApIHtcbiAgICAgICAgICBudW1JbnN0cnVjdGlvbnMgPSBzb3VyY2VNYXAuc3BsaXQoXCI7XCIpLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvL0hBQ0tcbiAgICAgICAgICBudW1JbnN0cnVjdGlvbnMgPSAoYmluYXJ5Lmxlbmd0aCAtIDIpIC8gMjtcbiAgICAgICAgICAvL3RoaXMgaXMgYWN0dWFsbHkgYW4gb3ZlcmVzdGltYXRlLCBidXQgdGhhdCdzIE9LXG4gICAgICAgIH1cblxuICAgICAgICAvL2JlY2F1c2Ugd2UgbWlnaHQgYmUgZGVhbGluZyB3aXRoIGEgY29uc3RydWN0b3Igd2l0aCBhcmd1bWVudHMsIHdlIGRvXG4gICAgICAgIC8vKm5vdCogcmVtb3ZlIG1ldGFkYXRhIG1hbnVhbGx5XG4gICAgICAgIGxldCBpbnN0cnVjdGlvbnMgPSBDb2RlVXRpbHMucGFyc2VDb2RlKGJpbmFyeSwgbnVtSW5zdHJ1Y3Rpb25zKTtcblxuICAgICAgICBpZiAoIXNvdXJjZU1hcCkge1xuICAgICAgICAgIC8vIEhBQ0tcbiAgICAgICAgICAvLyBMZXQncyBjcmVhdGUgYSBzb3VyY2UgbWFwIHRvIHVzZSBzaW5jZSBub25lIGV4aXN0cy4gVGhpcyBzb3VyY2VcbiAgICAgICAgICAvLyBtYXAgbWFwcyBqdXN0IGFzIG1hbnkgcmFuZ2VzIGFzIHRoZXJlIGFyZSBpbnN0cnVjdGlvbnMgKG9yXG4gICAgICAgICAgLy8gcG9zc2libHkgbW9yZSksIGFuZCBtYXJrcyB0aGVtIGFsbCBhcyBiZWluZyBTb2xpZGl0eS1pbnRlcm5hbCBhbmRcbiAgICAgICAgICAvLyBub3QganVtcHMuXG4gICAgICAgICAgc291cmNlTWFwID1cbiAgICAgICAgICAgIGJpbmFyeSAhPT0gXCIweFwiXG4gICAgICAgICAgICAgID8gXCIwOjA6LTE6LVwiLmNvbmNhdChcIjtcIi5yZXBlYXQoaW5zdHJ1Y3Rpb25zLmxlbmd0aCAtIDEpKVxuICAgICAgICAgICAgICA6IFwiXCI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGluZUFuZENvbHVtbk1hcHBpbmdzID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7fSxcbiAgICAgICAgICAuLi5PYmplY3QuZW50cmllcyhzb3VyY2VzKS5tYXAoKFtpZCwgeyBzb3VyY2UgfV0pID0+ICh7XG4gICAgICAgICAgICBbaWRdOiBTb2xpZGl0eVV0aWxzLmdldENoYXJhY3Rlck9mZnNldFRvTGluZUFuZENvbHVtbk1hcHBpbmcoXG4gICAgICAgICAgICAgIHNvdXJjZSB8fCBcIlwiXG4gICAgICAgICAgICApXG4gICAgICAgICAgfSkpXG4gICAgICAgICk7XG4gICAgICAgIHZhciBodW1hblJlYWRhYmxlU291cmNlTWFwID0gU29saWRpdHlVdGlscy5nZXRIdW1hblJlYWRhYmxlU291cmNlTWFwKFxuICAgICAgICAgIHNvdXJjZU1hcFxuICAgICAgICApO1xuXG4gICAgICAgIGxldCBwcmltYXJ5RmlsZSA9IGh1bWFuUmVhZGFibGVTb3VyY2VNYXBbMF0uZmlsZTtcbiAgICAgICAgZGVidWcoXCJwcmltYXJ5RmlsZSAlb1wiLCBwcmltYXJ5RmlsZSk7XG5cbiAgICAgICAgcmV0dXJuIGluc3RydWN0aW9uc1xuICAgICAgICAgIC5tYXAoKGluc3RydWN0aW9uLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgLy8gbG9va3VwIHNvdXJjZSBtYXAgYnkgaW5kZXggYW5kIGFkZCBgaW5kZXhgIHByb3BlcnR5IHRvXG4gICAgICAgICAgICAvLyBpbnN0cnVjdGlvblxuICAgICAgICAgICAgLy9cblxuICAgICAgICAgICAgY29uc3Qgc291cmNlTWFwID0gaHVtYW5SZWFkYWJsZVNvdXJjZU1hcFtpbmRleF0gfHwge307XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGluc3RydWN0aW9uOiB7IC4uLmluc3RydWN0aW9uLCBpbmRleCB9LFxuICAgICAgICAgICAgICBzb3VyY2VNYXBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSlcbiAgICAgICAgICAubWFwKCh7IGluc3RydWN0aW9uLCBzb3VyY2VNYXAgfSkgPT4ge1xuICAgICAgICAgICAgLy8gYWRkIHNvdXJjZSBtYXAgaW5mb3JtYXRpb24gdG8gaW5zdHJ1Y3Rpb24sIG9yIGRlZmF1bHRzXG4gICAgICAgICAgICAvL1xuXG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGp1bXAsXG4gICAgICAgICAgICAgIHN0YXJ0ID0gMCxcbiAgICAgICAgICAgICAgbGVuZ3RoID0gMCxcbiAgICAgICAgICAgICAgZmlsZSA9IHByaW1hcnlGaWxlXG4gICAgICAgICAgICB9ID0gc291cmNlTWFwO1xuICAgICAgICAgICAgY29uc3QgbGluZUFuZENvbHVtbk1hcHBpbmcgPSBsaW5lQW5kQ29sdW1uTWFwcGluZ3NbZmlsZV0gfHwge307XG4gICAgICAgICAgICBjb25zdCByYW5nZSA9IHtcbiAgICAgICAgICAgICAgc3RhcnQ6IGxpbmVBbmRDb2x1bW5NYXBwaW5nW3N0YXJ0XSB8fCB7XG4gICAgICAgICAgICAgICAgbGluZTogbnVsbCxcbiAgICAgICAgICAgICAgICBjb2x1bW46IG51bGxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZW5kOiBsaW5lQW5kQ29sdW1uTWFwcGluZ1tzdGFydCArIGxlbmd0aF0gfHwge1xuICAgICAgICAgICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBudWxsXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChyYW5nZS5zdGFydC5saW5lID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIGRlYnVnKFwic291cmNlTWFwICVvXCIsIHNvdXJjZU1hcCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLmluc3RydWN0aW9uLFxuXG4gICAgICAgICAgICAgIGp1bXAsXG4gICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICBsZW5ndGgsXG4gICAgICAgICAgICAgIGZpbGUsXG4gICAgICAgICAgICAgIHJhbmdlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBzb2xpZGl0eS5jdXJyZW50Lmluc3RydWN0aW9uQXRQcm9ncmFtQ291bnRlclxuICAgICAqL1xuICAgIGluc3RydWN0aW9uQXRQcm9ncmFtQ291bnRlcjogY3JlYXRlTGVhZihcbiAgICAgIFtcIi4vaW5zdHJ1Y3Rpb25zXCJdLFxuXG4gICAgICBpbnN0cnVjdGlvbnMgPT4ge1xuICAgICAgICBsZXQgbWFwID0ge307XG4gICAgICAgIGluc3RydWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGluc3RydWN0aW9uKSB7XG4gICAgICAgICAgbWFwW2luc3RydWN0aW9uLnBjXSA9IGluc3RydWN0aW9uO1xuICAgICAgICB9KTtcbiAgICAgICAgLy9ub3RlOiB0aGlzIHdpbGwgaGF2ZSBnYXBzIGluIGl0LiAgVGhhdCdzIE9LISAgVGhvc2UgZ2FwcyBhcmUgdGhlIGRhdGFcbiAgICAgICAgLy9wb3J0aW9ucyBvZiBwdXNoIGluc3RydWN0aW9ucywgd2hpY2ggaXQgaXMgaWxsZWdhbCB0byBqdW1wIGludG8uICBXZVxuICAgICAgICAvL2Rvbid0IG5lZWQgdG8gYXNzaWduIGluc3RydWN0aW9ucyB0byBpbGxlZ2FsIFBDIHZhbHVlcy5cbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgIH1cbiAgICApLFxuXG4gICAgLi4uY3JlYXRlTXVsdGlzdGVwU2VsZWN0b3JzKGV2bS5jdXJyZW50LnN0ZXApLFxuXG4gICAgLyoqXG4gICAgICogc29saWRpdHkuY3VycmVudC5pc1NvdXJjZVJhbmdlRmluYWxcbiAgICAgKi9cbiAgICBpc1NvdXJjZVJhbmdlRmluYWw6IGNyZWF0ZUxlYWYoXG4gICAgICBbXG4gICAgICAgIFwiLi9pbnN0cnVjdGlvbkF0UHJvZ3JhbUNvdW50ZXJcIixcbiAgICAgICAgZXZtLmN1cnJlbnQuc3RlcC5wcm9ncmFtQ291bnRlcixcbiAgICAgICAgZXZtLm5leHQuc3RlcC5wcm9ncmFtQ291bnRlclxuICAgICAgXSxcblxuICAgICAgKG1hcCwgY3VycmVudCwgbmV4dCkgPT4ge1xuICAgICAgICBpZiAoIW1hcFtuZXh0XSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudCA9IG1hcFtjdXJyZW50XTtcbiAgICAgICAgbmV4dCA9IG1hcFtuZXh0XTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGN1cnJlbnQuc3RhcnQgIT0gbmV4dC5zdGFydCB8fFxuICAgICAgICAgIGN1cnJlbnQubGVuZ3RoICE9IG5leHQubGVuZ3RoIHx8XG4gICAgICAgICAgY3VycmVudC5maWxlICE9IG5leHQuZmlsZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBzb2xpZGl0eS5jdXJyZW50LmlzTXVsdGlsaW5lXG4gICAgICovXG4gICAgaXNNdWx0aWxpbmU6IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIuL3NvdXJjZVJhbmdlXCJdLFxuXG4gICAgICAoeyBsaW5lcyB9KSA9PiBsaW5lcy5zdGFydC5saW5lICE9IGxpbmVzLmVuZC5saW5lXG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIHNvbGlkaXR5LmN1cnJlbnQud2lsbEp1bXBcbiAgICAgKi9cbiAgICB3aWxsSnVtcDogY3JlYXRlTGVhZihbZXZtLmN1cnJlbnQuc3RlcC5pc0p1bXBdLCBpc0p1bXAgPT4gaXNKdW1wKSxcblxuICAgIC8qKlxuICAgICAqIHNvbGlkaXR5LmN1cnJlbnQuanVtcERpcmVjdGlvblxuICAgICAqL1xuICAgIGp1bXBEaXJlY3Rpb246IGNyZWF0ZUxlYWYoW1wiLi9pbnN0cnVjdGlvblwiXSwgKGkgPSB7fSkgPT4gaS5qdW1wIHx8IFwiLVwiKSxcblxuICAgIC8qKlxuICAgICAqIHNvbGlkaXR5LmN1cnJlbnQud2lsbENhbGxcbiAgICAgKi9cbiAgICB3aWxsQ2FsbDogY3JlYXRlTGVhZihbZXZtLmN1cnJlbnQuc3RlcC5pc0NhbGxdLCB4ID0+IHgpLFxuXG4gICAgLyoqXG4gICAgICogc29saWRpdHkuY3VycmVudC53aWxsQ3JlYXRlXG4gICAgICovXG4gICAgd2lsbENyZWF0ZTogY3JlYXRlTGVhZihbZXZtLmN1cnJlbnQuc3RlcC5pc0NyZWF0ZV0sIHggPT4geCksXG5cbiAgICAvKipcbiAgICAgKiBzb2xpZGl0eS5jdXJyZW50LmNhbGxzUHJlY29tcGlsZU9yRXh0ZXJuYWxcbiAgICAgKi9cbiAgICBjYWxsc1ByZWNvbXBpbGVPckV4dGVybmFsOiBjcmVhdGVMZWFmKFxuICAgICAgW2V2bS5jdXJyZW50LnN0ZXAuY2FsbHNQcmVjb21waWxlT3JFeHRlcm5hbF0sXG4gICAgICB4ID0+IHhcbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogc29saWRpdHkuY3VycmVudC53aWxsUmV0dXJuXG4gICAgICovXG4gICAgd2lsbFJldHVybjogY3JlYXRlTGVhZihcbiAgICAgIFtldm0uY3VycmVudC5zdGVwLmlzSGFsdGluZ10sXG4gICAgICBpc0hhbHRpbmcgPT4gaXNIYWx0aW5nXG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIHNvbGlkaXR5LmN1cnJlbnQud2lsbEZhaWxcbiAgICAgKi9cbiAgICB3aWxsRmFpbDogY3JlYXRlTGVhZihbZXZtLmN1cnJlbnQuc3RlcC5pc0V4Y2VwdGlvbmFsSGFsdGluZ10sIHggPT4geCksXG5cbiAgICAvKlxuICAgICAqIHNvbGlkaXR5LmN1cnJlbnQubmV4dE1hcHBlZFxuICAgICAqIHJldHVybnMgdGhlIG5leHQgdHJhY2Ugc3RlcCBhZnRlciB0aGlzIG9uZSB3aGljaCBpcyBzb3VyY2VtYXBwZWRcbiAgICAgKiBIQUNLOiB0aGlzIGFzc3VtZXMgd2UncmUgbm90IGFib3V0IHRvIGNoYW5nZSBjb250ZXh0ISBkb24ndCB1c2UgdGhpcyBpZlxuICAgICAqIHdlIGFyZSFcbiAgICAgKiBBTFNPLCB0aGlzIG1heSByZXR1cm4gdW5kZWZpbmVkLCBzbyBiZSBwcmVwYXJlZCBmb3IgdGhhdFxuICAgICAqL1xuICAgIG5leHRNYXBwZWQ6IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIuL2luc3RydWN0aW9uQXRQcm9ncmFtQ291bnRlclwiLCB0cmFjZS5zdGVwcywgdHJhY2UuaW5kZXhdLFxuICAgICAgKG1hcCwgc3RlcHMsIGluZGV4KSA9PlxuICAgICAgICBzdGVwcy5zbGljZShpbmRleCArIDEpLmZpbmQoKHsgcGMgfSkgPT4gbWFwW3BjXSAmJiBtYXBbcGNdLmZpbGUgIT09IC0xKVxuICAgIClcbiAgfSxcblxuICAvKipcbiAgICogc29saWRpdHkubmV4dFxuICAgKiBIQUNLIFdBUk5JTkc6IGRvIG5vdCB1c2UgdGhlc2Ugc2VsZWN0b3JzIHdoZW4gdGhlIGN1cnJlbnQgaW5zdHJ1Y3Rpb24gaXMgYVxuICAgKiBjb250ZXh0IGNoYW5nZSEgKGV2bSBjYWxsIG9yIGV2bSByZXR1cm4pXG4gICAqL1xuICBuZXh0OiBjcmVhdGVNdWx0aXN0ZXBTZWxlY3RvcnMoZXZtLm5leHQuc3RlcClcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBzb2xpZGl0eTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvc29saWRpdHkvc2VsZWN0b3JzL2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC92YWx1ZXNcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L3ZhbHVlc1wiXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBjcmVhdGVTZWxlY3RvclRyZWUsIGNyZWF0ZUxlYWYgfSBmcm9tIFwicmVzZWxlY3QtdHJlZVwiO1xuXG5jb25zdCBQQVNUX0VORF9PRl9UUkFDRSA9IHtcbiAgZGVwdGg6IC0xLCAvL3RoaXMgaXMgdGhlIHBhcnQgdGhhdCBtYXR0ZXJzIVxuICAvL3RoZSByZXN0IG9mIHRoaXMgaXMganVzdCB0byBsb29rIGxpa2UgYSB0cmFjZSBzdGVwXG4gIGVycm9yOiBcIlwiLFxuICBnYXM6IDAsXG4gIG1lbW9yeTogW10sXG4gIHN0YWNrOiBbXSxcbiAgc3RvcmFnZToge30sXG4gIGdhc0Nvc3Q6IDAsXG4gIG9wOiBcIlNUT1BcIixcbiAgcGM6IC0xIC8vdGhpcyBpcyBub3QgYXQgYWxsIHZhbGlkIGJ1dCB0aGF0J3MgZmluZVxufTtcblxubGV0IHRyYWNlID0gY3JlYXRlU2VsZWN0b3JUcmVlKHtcbiAgLyoqXG4gICAqIHRyYWNlLmluZGV4XG4gICAqXG4gICAqIGN1cnJlbnQgc3RlcCBpbmRleFxuICAgKi9cbiAgaW5kZXg6IHN0YXRlID0+IHN0YXRlLnRyYWNlLnByb2MuaW5kZXgsXG5cbiAgLyoqXG4gICAqIHRyYWNlLmZpbmlzaGVkXG4gICAqXG4gICAqIGlzIHRoZSB0cmFjZSBmaW5pc2hlZD9cbiAgICovXG4gIGZpbmlzaGVkOiBzdGF0ZSA9PiBzdGF0ZS50cmFjZS5wcm9jLmZpbmlzaGVkLFxuXG4gIC8qKlxuICAgKiB0cmFjZS5zdGVwc1xuICAgKlxuICAgKiBhbGwgdHJhY2Ugc3RlcHNcbiAgICovXG4gIHN0ZXBzOiBzdGF0ZSA9PiBzdGF0ZS50cmFjZS5pbmZvLnN0ZXBzLFxuXG4gIC8qKlxuICAgKiB0cmFjZS5zdGVwc1JlbWFpbmluZ1xuICAgKlxuICAgKiBudW1iZXIgb2Ygc3RlcHMgcmVtYWluaW5nIGluIHRyYWNlXG4gICAqL1xuICBzdGVwc1JlbWFpbmluZzogY3JlYXRlTGVhZihcbiAgICBbXCIuL3N0ZXBzXCIsIFwiLi9pbmRleFwiXSxcbiAgICAoc3RlcHMsIGluZGV4KSA9PiBzdGVwcy5sZW5ndGggLSBpbmRleFxuICApLFxuXG4gIC8qKlxuICAgKiB0cmFjZS5zdGVwXG4gICAqXG4gICAqIGN1cnJlbnQgdHJhY2Ugc3RlcFxuICAgKi9cbiAgc3RlcDogY3JlYXRlTGVhZihbXCIuL3N0ZXBzXCIsIFwiLi9pbmRleFwiXSwgKHN0ZXBzLCBpbmRleCkgPT4gc3RlcHNbaW5kZXhdKSxcblxuICAvKipcbiAgICogdHJhY2UubmV4dFxuICAgKlxuICAgKiBuZXh0IHRyYWNlIHN0ZXBcbiAgICogSEFDSzogaWYgYXQgdGhlIGVuZCxcbiAgICogd2Ugd2lsbCByZXR1cm4gYSBzcG9vZmVkIFwicGFzdCBlbmRcIiBzdGVwXG4gICAqL1xuICBuZXh0OiBjcmVhdGVMZWFmKFxuICAgIFtcIi4vc3RlcHNcIiwgXCIuL2luZGV4XCJdLFxuICAgIChzdGVwcywgaW5kZXgpID0+XG4gICAgICBpbmRleCA8IHN0ZXBzLmxlbmd0aCAtIDEgPyBzdGVwc1tpbmRleCArIDFdIDogUEFTVF9FTkRfT0ZfVFJBQ0VcbiAgKSxcblxuICAvKlxuICAgKiB0cmFjZS5uZXh0T2ZTYW1lRGVwdGhcbiAgICogbmV4dCB0cmFjZSBzdGVwIHRoYXQncyBhdCB0aGUgc2FtZSBkZXB0aCBhcyB0aGlzIG9uZVxuICAgKiBOT1RFOiBpZiB0aGVyZSBpcyBub25lLCB3aWxsIHJldHVybiB1bmRlZmluZWRcbiAgICogKHNob3VsZCBub3QgYmUgdXNlZCBpbiBzdWNoIGNhc2VzKVxuICAgKi9cbiAgbmV4dE9mU2FtZURlcHRoOiBjcmVhdGVMZWFmKFtcIi4vc3RlcHNcIiwgXCIuL2luZGV4XCJdLCAoc3RlcHMsIGluZGV4KSA9PiB7XG4gICAgbGV0IGRlcHRoID0gc3RlcHNbaW5kZXhdLmRlcHRoO1xuICAgIHJldHVybiBzdGVwcy5zbGljZShpbmRleCArIDEpLmZpbmQoc3RlcCA9PiBzdGVwLmRlcHRoID09PSBkZXB0aCk7XG4gIH0pXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgdHJhY2U7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3RyYWNlL3NlbGVjdG9ycy9pbmRleC5qcyIsImV4cG9ydCBjb25zdCBTQVZFX1NURVBTID0gXCJTQVZFX1NURVBTXCI7XG5leHBvcnQgZnVuY3Rpb24gc2F2ZVN0ZXBzKHN0ZXBzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogU0FWRV9TVEVQUyxcbiAgICBzdGVwc1xuICB9O1xufVxuXG5leHBvcnQgY29uc3QgUkVDRUlWRV9BRERSRVNTRVMgPSBcIlJFQ0VJVkVfQUREUkVTU0VTXCI7XG5leHBvcnQgZnVuY3Rpb24gcmVjZWl2ZUFkZHJlc3NlcyhhZGRyZXNzZXMpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBSRUNFSVZFX0FERFJFU1NFUyxcbiAgICBhZGRyZXNzZXNcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IE5FWFQgPSBcIk5FWFRcIjtcbmV4cG9ydCBmdW5jdGlvbiBuZXh0KCkge1xuICByZXR1cm4geyB0eXBlOiBORVhUIH07XG59XG5cbmV4cG9ydCBjb25zdCBUSUNLID0gXCJUSUNLXCI7XG5leHBvcnQgZnVuY3Rpb24gdGljaygpIHtcbiAgcmV0dXJuIHsgdHlwZTogVElDSyB9O1xufVxuXG5leHBvcnQgY29uc3QgVE9DSyA9IFwiVE9DS1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHRvY2soKSB7XG4gIHJldHVybiB7IHR5cGU6IFRPQ0sgfTtcbn1cblxuZXhwb3J0IGNvbnN0IEVORF9PRl9UUkFDRSA9IFwiRU9UXCI7XG5leHBvcnQgZnVuY3Rpb24gZW5kVHJhY2UoKSB7XG4gIHJldHVybiB7IHR5cGU6IEVORF9PRl9UUkFDRSB9O1xufVxuXG5leHBvcnQgY29uc3QgUkVTRVQgPSBcIlRSQUNFX1JFU0VUXCI7XG5leHBvcnQgZnVuY3Rpb24gcmVzZXQoKSB7XG4gIHJldHVybiB7IHR5cGU6IFJFU0VUIH07XG59XG5cbmV4cG9ydCBjb25zdCBCQUNLVElDSyA9IFwiQkFDS1RJQ0tcIjtcbmV4cG9ydCBmdW5jdGlvbiBzdWJ0b2NrKCkge1xuICByZXR1cm4geyB0eXBlOiBCQUNLVElDSyB9O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi90cmFjZS9hY3Rpb25zL2luZGV4LmpzIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOnRyYWNlOnNhZ2FzXCIpO1xuXG5pbXBvcnQgeyB0YWtlLCB0YWtlRXZlcnksIHB1dCwgc2VsZWN0IH0gZnJvbSBcInJlZHV4LXNhZ2EvZWZmZWN0c1wiO1xuaW1wb3J0IHsgcHJlZml4TmFtZSwgaXNDYWxsTW5lbW9uaWMsIGlzQ3JlYXRlTW5lbW9uaWMgfSBmcm9tIFwibGliL2hlbHBlcnNcIjtcblxuaW1wb3J0ICogYXMgRGVjb2RlVXRpbHMgZnJvbSBcInRydWZmbGUtZGVjb2RlLXV0aWxzXCI7XG5cbmltcG9ydCAqIGFzIGFjdGlvbnMgZnJvbSBcIi4uL2FjdGlvbnNcIjtcblxuaW1wb3J0IHRyYWNlIGZyb20gXCIuLi9zZWxlY3RvcnNcIjtcblxuZnVuY3Rpb24qIHdhaXRGb3JUcmFjZSgpIHtcbiAgbGV0IHsgc3RlcHMgfSA9IHlpZWxkIHRha2UoYWN0aW9ucy5TQVZFX1NURVBTKTtcblxuICBsZXQgYWRkcmVzc2VzID0gW1xuICAgIC4uLm5ldyBTZXQoXG4gICAgICBzdGVwc1xuICAgICAgICAubWFwKCh7IG9wLCBzdGFjaywgZGVwdGggfSwgaW5kZXgpID0+IHtcbiAgICAgICAgICBpZiAoaXNDYWxsTW5lbW9uaWMob3ApKSB7XG4gICAgICAgICAgICAvL2lmIGl0J3MgYSBjYWxsLCBqdXN0IGZldGNoIHRoZSBhZGRyZXNzIG9mZiB0aGUgc3RhY2tcbiAgICAgICAgICAgIHJldHVybiBEZWNvZGVVdGlscy5Db252ZXJzaW9uLnRvQWRkcmVzcyhzdGFja1tzdGFjay5sZW5ndGggLSAyXSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0NyZWF0ZU1uZW1vbmljKG9wKSkge1xuICAgICAgICAgICAgLy9pZiBpdCdzIGEgY3JlYXRlLCBsb29rIGFoZWFkIHRvIHdoZW4gaXQgcmV0dXJucyBhbmQgZ2V0IHRoZVxuICAgICAgICAgICAgLy9hZGRyZXNzIG9mZiB0aGUgc3RhY2tcbiAgICAgICAgICAgIGxldCByZXR1cm5TdGFjayA9IHN0ZXBzXG4gICAgICAgICAgICAgIC5zbGljZShpbmRleCArIDEpXG4gICAgICAgICAgICAgIC5maW5kKHN0ZXAgPT4gc3RlcC5kZXB0aCA9PT0gZGVwdGgpLnN0YWNrO1xuICAgICAgICAgICAgcmV0dXJuIERlY29kZVV0aWxzLkNvbnZlcnNpb24udG9BZGRyZXNzKFxuICAgICAgICAgICAgICByZXR1cm5TdGFja1tyZXR1cm5TdGFjay5sZW5ndGggLSAxXVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9pZiBpdCdzIG5vdCBhIGNhbGwgb3IgY3JlYXRlLCB0aGVyZSdzIG5vIGFkZHJlc3MgdG8gZ2V0XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLy9maWx0ZXIgb3V0IHplcm8gYWRkcmVzc2VzIGZyb20gZmFpbGVkIGNyZWF0ZXMgKGFzIHdlbGwgYXMgdW5kZWZpbmVkcylcbiAgICAgICAgLmZpbHRlcihcbiAgICAgICAgICBhZGRyZXNzID0+XG4gICAgICAgICAgICBhZGRyZXNzICE9PSB1bmRlZmluZWQgJiYgYWRkcmVzcyAhPT0gRGVjb2RlVXRpbHMuRVZNLlpFUk9fQUREUkVTU1xuICAgICAgICApXG4gICAgKVxuICBdO1xuXG4gIHlpZWxkIHB1dChhY3Rpb25zLnJlY2VpdmVBZGRyZXNzZXMoYWRkcmVzc2VzKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogYWR2YW5jZSgpIHtcbiAgeWllbGQgcHV0KGFjdGlvbnMubmV4dCgpKTtcblxuICBkZWJ1ZyhcIlRPQ0sgdG8gdGFrZVwiKTtcbiAgeWllbGQgdGFrZShbYWN0aW9ucy5UT0NLLCBhY3Rpb25zLkVORF9PRl9UUkFDRV0pO1xuICBkZWJ1ZyhcIlRPQ0sgdGFrZW5cIik7XG59XG5cbmNvbnN0IFNVQk1PRFVMRV9DT1VOVCA9IDM7IC8vZGF0YSwgZXZtLCBzb2xpZGl0eVxuXG5mdW5jdGlvbiogbmV4dCgpIHtcbiAgbGV0IHJlbWFpbmluZyA9IHlpZWxkIHNlbGVjdCh0cmFjZS5zdGVwc1JlbWFpbmluZyk7XG4gIGRlYnVnKFwicmVtYWluaW5nOiAlb1wiLCByZW1haW5pbmcpO1xuICBsZXQgc3RlcHMgPSB5aWVsZCBzZWxlY3QodHJhY2Uuc3RlcHMpO1xuICBkZWJ1ZyhcInRvdGFsIHN0ZXBzOiAlb1wiLCBzdGVwcy5sZW5ndGgpO1xuICBsZXQgd2FpdGluZ0ZvclN1Ym1vZHVsZXMgPSAwO1xuXG4gIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgZGVidWcoXCJwdXR0aW5nIFRJQ0tcIik7XG4gICAgLy8gdXBkYXRlcyBzdGF0ZSBmb3IgY3VycmVudCBzdGVwXG4gICAgd2FpdGluZ0ZvclN1Ym1vZHVsZXMgPSBTVUJNT0RVTEVfQ09VTlQ7XG4gICAgeWllbGQgcHV0KGFjdGlvbnMudGljaygpKTtcbiAgICBkZWJ1ZyhcInB1dCBUSUNLXCIpO1xuXG4gICAgLy93YWl0IGZvciBhbGwgc3VidG9ja3MgYmVmb3JlIGNvbnRpbnVpbmdcbiAgICB3aGlsZSAod2FpdGluZ0ZvclN1Ym1vZHVsZXMgPiAwKSB7XG4gICAgICB5aWVsZCB0YWtlKGFjdGlvbnMuQkFDS1RJQ0spO1xuICAgICAgZGVidWcoXCJnb3QgQkFDS1RJQ0tcIik7XG4gICAgICB3YWl0aW5nRm9yU3VibW9kdWxlcy0tO1xuICAgIH1cblxuICAgIHJlbWFpbmluZy0tOyAvLyBsb2NhbCB1cGRhdGUsIGp1c3QgZm9yIGNvbnZlbmllbmNlXG4gIH1cblxuICBpZiAocmVtYWluaW5nKSB7XG4gICAgZGVidWcoXCJwdXR0aW5nIFRPQ0tcIik7XG4gICAgLy8gdXBkYXRlcyBzdGVwIHRvIG5leHQgc3RlcCBpbiB0cmFjZVxuICAgIHlpZWxkIHB1dChhY3Rpb25zLnRvY2soKSk7XG4gICAgZGVidWcoXCJwdXQgVE9DS1wiKTtcbiAgfSBlbHNlIHtcbiAgICBkZWJ1ZyhcInB1dHRpbmcgRU5EX09GX1RSQUNFXCIpO1xuICAgIHlpZWxkIHB1dChhY3Rpb25zLmVuZFRyYWNlKCkpO1xuICAgIGRlYnVnKFwicHV0IEVORF9PRl9UUkFDRVwiKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24qIHNpZ25hbFRpY2tTYWdhQ29tcGxldGlvbigpIHtcbiAgeWllbGQgcHV0KGFjdGlvbnMuc3VidG9jaygpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiBwcm9jZXNzVHJhY2UodHJhY2UpIHtcbiAgeWllbGQgcHV0KGFjdGlvbnMuc2F2ZVN0ZXBzKHRyYWNlKSk7XG5cbiAgbGV0IHsgYWRkcmVzc2VzIH0gPSB5aWVsZCB0YWtlKGFjdGlvbnMuUkVDRUlWRV9BRERSRVNTRVMpO1xuICBkZWJ1ZyhcInJlY2VpdmVkIGFkZHJlc3Nlc1wiKTtcblxuICByZXR1cm4gYWRkcmVzc2VzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24qIHJlc2V0KCkge1xuICB5aWVsZCBwdXQoYWN0aW9ucy5yZXNldCgpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiBzYWdhKCkge1xuICAvLyB3YWl0IGZvciB0cmFjZSB0byBiZSBkZWZpbmVkXG4gIHlpZWxkKiB3YWl0Rm9yVHJhY2UoKTtcblxuICB5aWVsZCB0YWtlRXZlcnkoYWN0aW9ucy5ORVhULCBuZXh0KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcHJlZml4TmFtZShcInRyYWNlXCIsIHNhZ2EpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi90cmFjZS9zYWdhcy9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIlxuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0IGNvbnN0IFNUQVJUID0gXCJTRVNTSU9OX1NUQVJUXCI7XG5leHBvcnQgZnVuY3Rpb24gc3RhcnQodHhIYXNoLCBwcm92aWRlcikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFNUQVJULFxuICAgIHR4SGFzaCxcbiAgICBwcm92aWRlclxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgUkVBRFkgPSBcIlNFU1NJT05fUkVBRFlcIjtcbmV4cG9ydCBmdW5jdGlvbiByZWFkeSgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBSRUFEWVxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgRVJST1IgPSBcIlNFU1NJT05fRVJST1JcIjtcbmV4cG9ydCBmdW5jdGlvbiBlcnJvcihlcnJvcikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEVSUk9SLFxuICAgIGVycm9yXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBSRUNPUkRfQ09OVFJBQ1RTID0gXCJSRUNPUkRfQ09OVFJBQ1RTXCI7XG5leHBvcnQgZnVuY3Rpb24gcmVjb3JkQ29udHJhY3RzKGNvbnRleHRzLCBzb3VyY2VzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogUkVDT1JEX0NPTlRSQUNUUyxcbiAgICBjb250ZXh0cyxcbiAgICBzb3VyY2VzXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBTQVZFX1RSQU5TQUNUSU9OID0gXCJTQVZFX1RSQU5TQUNUSU9OXCI7XG5leHBvcnQgZnVuY3Rpb24gc2F2ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogU0FWRV9UUkFOU0FDVElPTixcbiAgICB0cmFuc2FjdGlvblxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgU0FWRV9SRUNFSVBUID0gXCJTQVZFX1JFQ0VJUFRcIjtcbmV4cG9ydCBmdW5jdGlvbiBzYXZlUmVjZWlwdChyZWNlaXB0KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogU0FWRV9SRUNFSVBULFxuICAgIHJlY2VpcHRcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IFNBVkVfQkxPQ0sgPSBcIlNBVkVfQkxPQ0tcIjtcbmV4cG9ydCBmdW5jdGlvbiBzYXZlQmxvY2soYmxvY2spIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBTQVZFX0JMT0NLLFxuICAgIGJsb2NrXG4gIH07XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3Nlc3Npb24vYWN0aW9ucy9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImJuLmpzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiYm4uanNcIlxuLy8gbW9kdWxlIGlkID0gMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0IGNvbnN0IEFEVkFOQ0UgPSBcIkFEVkFOQ0VcIjtcbmV4cG9ydCBmdW5jdGlvbiBhZHZhbmNlKGNvdW50KSB7XG4gIHJldHVybiB7IHR5cGU6IEFEVkFOQ0UsIGNvdW50IH07XG59XG5cbmV4cG9ydCBjb25zdCBTVEVQX05FWFQgPSBcIlNURVBfTkVYVFwiO1xuZXhwb3J0IGZ1bmN0aW9uIHN0ZXBOZXh0KCkge1xuICByZXR1cm4geyB0eXBlOiBTVEVQX05FWFQgfTtcbn1cblxuZXhwb3J0IGNvbnN0IFNURVBfT1ZFUiA9IFwiU1RFUF9PVkVSXCI7XG5leHBvcnQgZnVuY3Rpb24gc3RlcE92ZXIoKSB7XG4gIHJldHVybiB7IHR5cGU6IFNURVBfT1ZFUiB9O1xufVxuXG5leHBvcnQgY29uc3QgU1RFUF9JTlRPID0gXCJTVEVQX0lOVE9cIjtcbmV4cG9ydCBmdW5jdGlvbiBzdGVwSW50bygpIHtcbiAgcmV0dXJuIHsgdHlwZTogU1RFUF9JTlRPIH07XG59XG5cbmV4cG9ydCBjb25zdCBTVEVQX09VVCA9IFwiU1RFUF9PVVRcIjtcbmV4cG9ydCBmdW5jdGlvbiBzdGVwT3V0KCkge1xuICByZXR1cm4geyB0eXBlOiBTVEVQX09VVCB9O1xufVxuXG5leHBvcnQgY29uc3QgUkVTRVQgPSBcIlJFU0VUXCI7XG5leHBvcnQgZnVuY3Rpb24gcmVzZXQoKSB7XG4gIHJldHVybiB7IHR5cGU6IFJFU0VUIH07XG59XG5cbmV4cG9ydCBjb25zdCBJTlRFUlJVUFQgPSBcIklOVEVSUlVQVFwiO1xuZXhwb3J0IGZ1bmN0aW9uIGludGVycnVwdCgpIHtcbiAgcmV0dXJuIHsgdHlwZTogSU5URVJSVVBUIH07XG59XG5cbmV4cG9ydCBjb25zdCBDT05USU5VRSA9IFwiQ09OVElOVUVcIjtcbmV4cG9ydCBmdW5jdGlvbiBjb250aW51ZVVudGlsQnJlYWtwb2ludChicmVha3BvaW50cykge1xuICAvL1wiY29udGludWVcIiBpcyBub3QgYSBsZWdhbCBuYW1lXG4gIHJldHVybiB7XG4gICAgdHlwZTogQ09OVElOVUUsXG4gICAgYnJlYWtwb2ludHNcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IEFERF9CUkVBS1BPSU5UID0gXCJBRERfQlJFQUtQT0lOVFwiO1xuZXhwb3J0IGZ1bmN0aW9uIGFkZEJyZWFrcG9pbnQoYnJlYWtwb2ludCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEFERF9CUkVBS1BPSU5ULFxuICAgIGJyZWFrcG9pbnRcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IFJFTU9WRV9CUkVBS1BPSU5UID0gXCJSRU1PVkVfQlJFQUtQT0lOVFwiO1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUJyZWFrcG9pbnQoYnJlYWtwb2ludCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFJFTU9WRV9CUkVBS1BPSU5ULFxuICAgIGJyZWFrcG9pbnRcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IFJFTU9WRV9BTExfQlJFQUtQT0lOVFMgPSBcIlJFTU9WRV9BTExfQlJFQUtQT0lOVFNcIjtcbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVBbGxCcmVha3BvaW50cygpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBSRU1PVkVfQUxMX0JSRUFLUE9JTlRTXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBET05FX1NURVBQSU5HID0gXCJET05FX1NURVBQSU5HXCI7XG5leHBvcnQgZnVuY3Rpb24gZG9uZVN0ZXBwaW5nKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IERPTkVfU1RFUFBJTkdcbiAgfTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvY29udHJvbGxlci9hY3Rpb25zL2luZGV4LmpzIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOmRhdGE6c2VsZWN0b3JzXCIpO1xuXG5pbXBvcnQgeyBjcmVhdGVTZWxlY3RvclRyZWUsIGNyZWF0ZUxlYWYgfSBmcm9tIFwicmVzZWxlY3QtdHJlZVwiO1xuaW1wb3J0IGpzb25wb2ludGVyIGZyb20gXCJqc29uLXBvaW50ZXJcIjtcblxuaW1wb3J0IHsgc3RhYmxlS2VjY2FrMjU2IH0gZnJvbSBcImxpYi9oZWxwZXJzXCI7XG5cbmltcG9ydCBldm0gZnJvbSBcImxpYi9ldm0vc2VsZWN0b3JzXCI7XG5pbXBvcnQgc29saWRpdHkgZnJvbSBcImxpYi9zb2xpZGl0eS9zZWxlY3RvcnNcIjtcblxuaW1wb3J0ICogYXMgRGVjb2RlVXRpbHMgZnJvbSBcInRydWZmbGUtZGVjb2RlLXV0aWxzXCI7XG5pbXBvcnQgeyBmb3JFdm1TdGF0ZSB9IGZyb20gXCJ0cnVmZmxlLWRlY29kZXJcIjtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBpZGVudGl0eSA9IHggPT4geDtcblxuZnVuY3Rpb24gZmluZEFuY2VzdG9yT2ZUeXBlKG5vZGUsIHR5cGVzLCBzY29wZXMpIHtcbiAgLy9ub3RlOiBJJ20gbm90IGluY2x1ZGluZyBhbnkgcHJvdGVjdGlvbiBhZ2FpbnN0IG51bGwgaW4gdGhpcyBmdW5jdGlvbi5cbiAgLy9Zb3UgYXJlIGFkdmlzZWQgdG8gaW5jbHVkZSBcIlNvdXJjZVVuaXRcIiBhcyBhIGZhbGxiYWNrIHR5cGUuXG4gIHdoaWxlIChub2RlICYmICF0eXBlcy5pbmNsdWRlcyhub2RlLm5vZGVUeXBlKSkge1xuICAgIG5vZGUgPSBzY29wZXNbc2NvcGVzW25vZGUuaWRdLnBhcmVudElkXS5kZWZpbml0aW9uO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG4vL2dpdmVuIGEgbW9kaWZpZXIgaW52b2NhdGlvbiAob3IgaW5oZXJpdGFuY2Ugc3BlY2lmaWVyKSBub2RlLFxuLy9nZXQgdGhlIG5vZGUgZm9yIHRoZSBhY3R1YWwgbW9kaWZpZXIgKG9yIGNvbnN0cnVjdG9yKVxuZnVuY3Rpb24gbW9kaWZpZXJGb3JJbnZvY2F0aW9uKGludm9jYXRpb24sIHNjb3Blcykge1xuICBsZXQgcmF3SWQ7IC8vcmF3IHJlZmVyZW5jZWREZWNsYXJhdGlvbiBJRCBleHRyYWN0ZWQgZnJvbSB0aGUgQVNULlxuICAvL2lmIGl0J3MgYSBtb2RpZmllciB0aGlzIGlzIHdoYXQgd2Ugd2FudCwgYnV0IGlmIGl0J3MgYmFzZVxuICAvL2NvbnN0cnVjdG9yLCB3ZSdsbCBnZXQgdGhlIGNvbnRyYWN0IGluc3RlYWQsIGFuZCBuZWVkIHRvIGZpbmQgaXRzXG4gIC8vY29uc3RydWN0b3IuXG4gIHN3aXRjaCAoaW52b2NhdGlvbi5ub2RlVHlwZSkge1xuICAgIGNhc2UgXCJNb2RpZmllckludm9jYXRpb25cIjpcbiAgICAgIHJhd0lkID0gaW52b2NhdGlvbi5tb2RpZmllck5hbWUucmVmZXJlbmNlZERlY2xhcmF0aW9uO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIkluaGVyaXRhbmNlU3BlY2lmaWVyXCI6XG4gICAgICByYXdJZCA9IGludm9jYXRpb24uYmFzZU5hbWUucmVmZXJlbmNlZERlY2xhcmF0aW9uO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGRlYnVnKFwiYmFkIGludm9jYXRpb24gbm9kZVwiKTtcbiAgfVxuICBsZXQgcmF3Tm9kZSA9IHNjb3Blc1tyYXdJZF0uZGVmaW5pdGlvbjtcbiAgc3dpdGNoIChyYXdOb2RlLm5vZGVUeXBlKSB7XG4gICAgY2FzZSBcIk1vZGlmaWVyRGVmaW5pdGlvblwiOlxuICAgICAgcmV0dXJuIHJhd05vZGU7XG4gICAgY2FzZSBcIkNvbnRyYWN0RGVmaW5pdGlvblwiOlxuICAgICAgcmV0dXJuIHJhd05vZGUubm9kZXMuZmluZChcbiAgICAgICAgbm9kZSA9PlxuICAgICAgICAgIG5vZGUubm9kZVR5cGUgPT09IFwiRnVuY3Rpb25EZWZpbml0aW9uXCIgJiYgbm9kZS5raW5kID09PSBcImNvbnN0cnVjdG9yXCJcbiAgICAgICk7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vd2Ugc2hvdWxkIG5ldmVyIGhpdCB0aGlzIGNhc2VcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuY29uc3QgZGF0YSA9IGNyZWF0ZVNlbGVjdG9yVHJlZSh7XG4gIHN0YXRlOiBzdGF0ZSA9PiBzdGF0ZS5kYXRhLFxuXG4gIC8qKlxuICAgKiBkYXRhLnZpZXdzXG4gICAqL1xuICB2aWV3czoge1xuICAgIC8qXG4gICAgICogZGF0YS52aWV3cy5hdExhc3RJbnN0cnVjdGlvbkZvclNvdXJjZVJhbmdlXG4gICAgICovXG4gICAgYXRMYXN0SW5zdHJ1Y3Rpb25Gb3JTb3VyY2VSYW5nZTogY3JlYXRlTGVhZihcbiAgICAgIFtzb2xpZGl0eS5jdXJyZW50LmlzU291cmNlUmFuZ2VGaW5hbF0sXG4gICAgICBmaW5hbCA9PiBmaW5hbFxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBkYXRhLnZpZXdzLnNjb3BlcyAobmFtZXNwYWNlKVxuICAgICAqL1xuICAgIHNjb3Blczoge1xuICAgICAgLyoqXG4gICAgICAgKiBkYXRhLnZpZXdzLnNjb3Blcy5pbmxpbmVkIChuYW1lc3BhY2UpXG4gICAgICAgKi9cbiAgICAgIGlubGluZWQ6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRhdGEudmlld3Muc2NvcGVzLmlubGluZWQgKHNlbGVjdG9yKVxuICAgICAgICAgKiBzZWUgZGF0YS5pbmZvLnNjb3BlcyBmb3IgaG93IHRoaXMgZGlmZmVycyBmcm9tIHRoZSByYXcgdmVyc2lvblxuICAgICAgICAgKi9cbiAgICAgICAgXzogY3JlYXRlTGVhZihbXCIvaW5mby9zY29wZXNcIiwgXCIuL3Jhd1wiXSwgKHNjb3BlcywgaW5saW5lZCkgPT5cbiAgICAgICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICAuLi5PYmplY3QuZW50cmllcyhpbmxpbmVkKS5tYXAoKFtpZCwgaW5mb10pID0+IHtcbiAgICAgICAgICAgICAgbGV0IG5ld0luZm8gPSB7IC4uLmluZm8gfTtcbiAgICAgICAgICAgICAgbmV3SW5mby52YXJpYWJsZXMgPSBzY29wZXNbaWRdLnZhcmlhYmxlcztcbiAgICAgICAgICAgICAgcmV0dXJuIHsgW2lkXTogbmV3SW5mbyB9O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG4gICAgICAgICksXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRhdGEudmlld3Muc2NvcGVzLmlubGluZWQucmF3XG4gICAgICAgICAqL1xuICAgICAgICByYXc6IGNyZWF0ZUxlYWYoXG4gICAgICAgICAgW1wiL2luZm8vc2NvcGVzL3Jhd1wiLCBzb2xpZGl0eS5pbmZvLnNvdXJjZXNdLFxuXG4gICAgICAgICAgKHNjb3Blcywgc291cmNlcykgPT5cbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICAuLi5PYmplY3QuZW50cmllcyhzY29wZXMpLm1hcCgoW2lkLCBlbnRyeV0pID0+ICh7XG4gICAgICAgICAgICAgICAgW2lkXToge1xuICAgICAgICAgICAgICAgICAgLi4uZW50cnksXG5cbiAgICAgICAgICAgICAgICAgIGRlZmluaXRpb246IGpzb25wb2ludGVyLmdldChcbiAgICAgICAgICAgICAgICAgICAgc291cmNlc1tlbnRyeS5zb3VyY2VJZF0uYXN0LFxuICAgICAgICAgICAgICAgICAgICBlbnRyeS5wb2ludGVyXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBkYXRhLnZpZXdzLmRlY29kZXJcbiAgICAgKlxuICAgICAqIHNlbGVjdG9yIHJldHVybnMgKGFzdCBub2RlIGRlZmluaXRpb24sIGRhdGEgcmVmZXJlbmNlKSA9PiBQcm9taXNlPHZhbHVlPlxuICAgICAqL1xuICAgIGRlY29kZXI6IGNyZWF0ZUxlYWYoXG4gICAgICBbXG4gICAgICAgIFwiL3ZpZXdzL3JlZmVyZW5jZURlY2xhcmF0aW9uc1wiLFxuICAgICAgICBcIi9jdXJyZW50L3N0YXRlXCIsXG4gICAgICAgIFwiL3ZpZXdzL21hcHBpbmdLZXlzXCIsXG4gICAgICAgIFwiL2luZm8vYWxsb2NhdGlvbnNcIlxuICAgICAgXSxcblxuICAgICAgKHJlZmVyZW5jZURlY2xhcmF0aW9ucywgc3RhdGUsIG1hcHBpbmdLZXlzLCBhbGxvY2F0aW9ucykgPT4gKFxuICAgICAgICBkZWZpbml0aW9uLFxuICAgICAgICByZWZcbiAgICAgICkgPT5cbiAgICAgICAgZm9yRXZtU3RhdGUoZGVmaW5pdGlvbiwgcmVmLCB7XG4gICAgICAgICAgcmVmZXJlbmNlRGVjbGFyYXRpb25zLFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIG1hcHBpbmdLZXlzLFxuICAgICAgICAgIHN0b3JhZ2VBbGxvY2F0aW9uczogYWxsb2NhdGlvbnMuc3RvcmFnZSxcbiAgICAgICAgICBtZW1vcnlBbGxvY2F0aW9uczogYWxsb2NhdGlvbnMubWVtb3J5LFxuICAgICAgICAgIGNhbGxkYXRhQWxsb2NhdGlvbnM6IGFsbG9jYXRpb25zLmNhbGxkYXRhXG4gICAgICAgIH0pXG4gICAgKSxcblxuICAgIC8qXG4gICAgICogZGF0YS52aWV3cy51c2VyRGVmaW5lZFR5cGVzXG4gICAgICovXG4gICAgdXNlckRlZmluZWRUeXBlczoge1xuICAgICAgLypcbiAgICAgICAqIGRhdGEudmlld3MudXNlckRlZmluZWRUeXBlcy5jb250cmFjdERlZmluaXRpb25zXG4gICAgICAgKiByZXN0cmljdCB0byBjb250cmFjdHMgb25seSwgYW5kIGdldCB0aGVpciBkZWZpbml0aW9uc1xuICAgICAgICovXG4gICAgICBjb250cmFjdERlZmluaXRpb25zOiBjcmVhdGVMZWFmKFxuICAgICAgICBbXCIvaW5mby91c2VyRGVmaW5lZFR5cGVzXCIsIFwiL3ZpZXdzL3Njb3Blcy9pbmxpbmVkXCJdLFxuICAgICAgICAodHlwZUlkcywgc2NvcGVzKSA9PlxuICAgICAgICAgIHR5cGVJZHNcbiAgICAgICAgICAgIC5tYXAoaWQgPT4gc2NvcGVzW2lkXS5kZWZpbml0aW9uKVxuICAgICAgICAgICAgLmZpbHRlcihub2RlID0+IG5vZGUubm9kZVR5cGUgPT09IFwiQ29udHJhY3REZWZpbml0aW9uXCIpXG4gICAgICApXG4gICAgfSxcblxuICAgIC8qXG4gICAgICogZGF0YS52aWV3cy5yZWZlcmVuY2VEZWNsYXJhdGlvbnNcbiAgICAgKi9cbiAgICByZWZlcmVuY2VEZWNsYXJhdGlvbnM6IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIuL3Njb3Blcy9pbmxpbmVkXCIsIFwiL2luZm8vdXNlckRlZmluZWRUeXBlc1wiXSxcbiAgICAgIChzY29wZXMsIHVzZXJEZWZpbmVkVHlwZXMpID0+XG4gICAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge30sXG4gICAgICAgICAgLi4udXNlckRlZmluZWRUeXBlcy5tYXAoaWQgPT4gKHsgW2lkXTogc2NvcGVzW2lkXS5kZWZpbml0aW9uIH0pKVxuICAgICAgICApXG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIGRhdGEudmlld3MubWFwcGluZ0tleXNcbiAgICAgKi9cbiAgICBtYXBwaW5nS2V5czogY3JlYXRlTGVhZihcbiAgICAgIFtcIi9wcm9jL21hcHBlZFBhdGhzXCIsIFwiL2N1cnJlbnQvYWRkcmVzc1wiXSxcbiAgICAgIChtYXBwZWRQYXRocywgYWRkcmVzcykgPT5cbiAgICAgICAgW11cbiAgICAgICAgICAuY29uY2F0KFxuICAgICAgICAgICAgLi4uT2JqZWN0LnZhbHVlcyhcbiAgICAgICAgICAgICAgKG1hcHBlZFBhdGhzLmJ5QWRkcmVzc1thZGRyZXNzXSB8fCB7IGJ5VHlwZToge30gfSkuYnlUeXBlXG4gICAgICAgICAgICApLm1hcCgoeyBieVNsb3RBZGRyZXNzIH0pID0+IE9iamVjdC52YWx1ZXMoYnlTbG90QWRkcmVzcykpXG4gICAgICAgICAgKVxuICAgICAgICAgIC5maWx0ZXIoc2xvdCA9PiBzbG90LmtleSAhPT0gdW5kZWZpbmVkKVxuICAgIClcbiAgfSxcblxuICAvKipcbiAgICogZGF0YS5pbmZvXG4gICAqL1xuICBpbmZvOiB7XG4gICAgLyoqXG4gICAgICogZGF0YS5pbmZvLnNjb3BlcyAobmFtZXNwYWNlKVxuICAgICAqL1xuICAgIHNjb3Blczoge1xuICAgICAgLyoqXG4gICAgICAgKiBkYXRhLmluZm8uc2NvcGVzIChzZWxlY3RvcilcbiAgICAgICAqIHRoZSByYXcgdmVyc2lvbiBpcyBiZWxvdzsgdGhpcyB2ZXJzaW9uIGFjY291bnRzIGZvciBpbmhlcml0YW5jZVxuICAgICAgICogTk9URTogZG9lc24ndCB0aGlzIHNlbGVjdG9yIHJlYWxseSBiZWxvbmcgaW4gZGF0YS52aWV3cz8gIFllcy5cbiAgICAgICAqIEJ1dCwgc2luY2UgaXQncyByZXBsYWNpbmcgdGhlIG9sZCBkYXRhLmluZm8uc2NvcGVzICh3aGljaCBpcyBub3dcbiAgICAgICAqIGRhdGEuaW5mby5zY29wZXMucmF3KSwgSSBkaWRuJ3Qgd2FudCB0byBtb3ZlIGl0LlxuICAgICAgICovXG4gICAgICBfOiBjcmVhdGVMZWFmKFtcIi4vcmF3XCIsIFwiL3ZpZXdzL3Njb3Blcy9pbmxpbmVkL3Jhd1wiXSwgKHNjb3BlcywgaW5saW5lZCkgPT5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7fSxcbiAgICAgICAgICAuLi5PYmplY3QuZW50cmllcyhzY29wZXMpLm1hcCgoW2lkLCBzY29wZV0pID0+IHtcbiAgICAgICAgICAgIGxldCBkZWZpbml0aW9uID0gaW5saW5lZFtpZF0uZGVmaW5pdGlvbjtcbiAgICAgICAgICAgIGlmIChkZWZpbml0aW9uLm5vZGVUeXBlICE9PSBcIkNvbnRyYWN0RGVmaW5pdGlvblwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7IFtpZF06IHNjb3BlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2lmIHdlJ3ZlIHJlYWNoZWQgdGhpcyBwb2ludCwgd2Ugc2hvdWxkIGJlIGRlYWxpbmcgd2l0aCBhXG4gICAgICAgICAgICAvL2NvbnRyYWN0LCBhbmQgc3BlY2lmaWNhbGx5IGEgY29udHJhY3QgLS0gbm90IGFuIGludGVyZmFjZSBvclxuICAgICAgICAgICAgLy9saWJyYXJ5ICh0aG9zZSBkb24ndCBnZXQgXCJ2YXJpYWJsZXNcIiBlbnRyaWVzIGluIHRoZWlyIHNjb3BlcylcbiAgICAgICAgICAgIGRlYnVnKFwiY29udHJhY3QgaWQgJWRcIiwgaWQpO1xuICAgICAgICAgICAgbGV0IG5ld1Njb3BlID0geyAuLi5zY29wZSB9O1xuICAgICAgICAgICAgLy9ub3RlIHRoYXQgU29saWRpdHkgZ2l2ZXMgdXMgdGhlIGxpbmVhcml6YXRpb24gaW4gb3JkZXIgZnJvbSBtb3N0XG4gICAgICAgICAgICAvL2Rlcml2ZWQgdG8gbW9zdCBiYXNlLCBidXQgd2Ugd2FudCBtb3N0IGJhc2UgdG8gbW9zdCBkZXJpdmVkO1xuICAgICAgICAgICAgLy9hbm5veWluZ2x5LCByZXZlcnNlKCkgaXMgaW4tcGxhY2UsIHNvIHdlIGNsb25lIHdpdGggc2xpY2UoKSBmaXJzdFxuICAgICAgICAgICAgbGV0IGxpbmVhcml6ZWRCYXNlQ29udHJhY3RzRnJvbUJhc2UgPSBkZWZpbml0aW9uLmxpbmVhcml6ZWRCYXNlQ29udHJhY3RzXG4gICAgICAgICAgICAgIC5zbGljZSgpXG4gICAgICAgICAgICAgIC5yZXZlcnNlKCk7XG4gICAgICAgICAgICAvL25vdywgd2UgcHV0IGl0IGFsbCB0b2dldGhlclxuICAgICAgICAgICAgbmV3U2NvcGUudmFyaWFibGVzID0gW11cbiAgICAgICAgICAgICAgLmNvbmNhdChcbiAgICAgICAgICAgICAgICAuLi5saW5lYXJpemVkQmFzZUNvbnRyYWN0c0Zyb21CYXNlLm1hcChcbiAgICAgICAgICAgICAgICAgIGNvbnRyYWN0SWQgPT4gc2NvcGVzW2NvbnRyYWN0SWRdLnZhcmlhYmxlcyB8fCBbXVxuICAgICAgICAgICAgICAgICAgLy93ZSBuZWVkIHRoZSB8fCBbXSBiZWNhdXNlIGNvbnRyYWN0cyB3aXRoIG5vIHN0YXRlIHZhcmlhYmxlc1xuICAgICAgICAgICAgICAgICAgLy9oYXZlIHZhcmlhYmxlcyB1bmRlZmluZWQgcmF0aGVyIHRoYW4gZW1wdHkgbGlrZSB5b3UnZCBleHBlY3RcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgLmZpbHRlcih2YXJpYWJsZSA9PiB7XG4gICAgICAgICAgICAgICAgLy8uLi5leGNlcHQsIEhBQ0ssIGxldCdzIGZpbHRlciBvdXQgdGhvc2UgY29uc3RhbnRzIHdlIGRvbid0IGtub3dcbiAgICAgICAgICAgICAgICAvL2hvdyB0byByZWFkLiAgdGhleSdsbCBqdXN0IGNsdXR0ZXIgdGhpbmdzIHVwLlxuICAgICAgICAgICAgICAgIGRlYnVnKFwidmFyaWFibGUgJU9cIiwgdmFyaWFibGUpO1xuICAgICAgICAgICAgICAgIGxldCBkZWZpbml0aW9uID0gaW5saW5lZFt2YXJpYWJsZS5pZF0uZGVmaW5pdGlvbjtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgIWRlZmluaXRpb24uY29uc3RhbnQgfHxcbiAgICAgICAgICAgICAgICAgIERlY29kZVV0aWxzLkRlZmluaXRpb24uaXNTaW1wbGVDb25zdGFudChkZWZpbml0aW9uLnZhbHVlKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4geyBbaWRdOiBuZXdTY29wZSB9O1xuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICksXG5cbiAgICAgIC8qXG4gICAgICAgKiBkYXRhLmluZm8uc2NvcGVzLnJhd1xuICAgICAgICovXG4gICAgICByYXc6IGNyZWF0ZUxlYWYoW1wiL3N0YXRlXCJdLCBzdGF0ZSA9PiBzdGF0ZS5pbmZvLnNjb3Blcy5ieUlkKVxuICAgIH0sXG5cbiAgICAvKlxuICAgICAqIGRhdGEuaW5mby5hbGxvY2F0aW9uc1xuICAgICAqL1xuICAgIGFsbG9jYXRpb25zOiB7XG4gICAgICAvKlxuICAgICAgICogZGF0YS5pbmZvLmFsbG9jYXRpb25zLnN0b3JhZ2VcbiAgICAgICAqL1xuICAgICAgc3RvcmFnZTogY3JlYXRlTGVhZihbXCIvc3RhdGVcIl0sIHN0YXRlID0+IHN0YXRlLmluZm8uYWxsb2NhdGlvbnMuc3RvcmFnZSksXG5cbiAgICAgIC8qXG4gICAgICAgKiBkYXRhLmluZm8uYWxsb2NhdGlvbnMubWVtb3J5XG4gICAgICAgKi9cbiAgICAgIG1lbW9yeTogY3JlYXRlTGVhZihbXCIvc3RhdGVcIl0sIHN0YXRlID0+IHN0YXRlLmluZm8uYWxsb2NhdGlvbnMubWVtb3J5KSxcblxuICAgICAgLypcbiAgICAgICAqIGRhdGEuaW5mby5hbGxvY2F0aW9ucy5jYWxsZGF0YVxuICAgICAgICovXG4gICAgICBjYWxsZGF0YTogY3JlYXRlTGVhZihbXCIvc3RhdGVcIl0sIHN0YXRlID0+IHN0YXRlLmluZm8uYWxsb2NhdGlvbnMuY2FsbGRhdGEpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGRhdGEuaW5mby51c2VyRGVmaW5lZFR5cGVzXG4gICAgICovXG4gICAgdXNlckRlZmluZWRUeXBlczogY3JlYXRlTGVhZihcbiAgICAgIFtcIi9zdGF0ZVwiXSxcbiAgICAgIHN0YXRlID0+IHN0YXRlLmluZm8udXNlckRlZmluZWRUeXBlc1xuICAgIClcbiAgfSxcblxuICAvKipcbiAgICogZGF0YS5wcm9jXG4gICAqL1xuICBwcm9jOiB7XG4gICAgLyoqXG4gICAgICogZGF0YS5wcm9jLmFzc2lnbm1lbnRzXG4gICAgICovXG4gICAgYXNzaWdubWVudHM6IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIvc3RhdGVcIl0sXG4gICAgICBzdGF0ZSA9PiBzdGF0ZS5wcm9jLmFzc2lnbm1lbnRzXG4gICAgICAvL25vdGU6IHRoaXMgbm8gbG9uZ2VyIGZldGNoZXMganVzdCB0aGUgYnlJZCwgYnV0IHJhdGhlciB0aGUgd2hvbGVcbiAgICAgIC8vYXNzaWdubWVudHMgb2JqZWN0XG4gICAgKSxcblxuICAgIC8qXG4gICAgICogZGF0YS5wcm9jLm1hcHBlZFBhdGhzXG4gICAgICovXG4gICAgbWFwcGVkUGF0aHM6IGNyZWF0ZUxlYWYoW1wiL3N0YXRlXCJdLCBzdGF0ZSA9PiBzdGF0ZS5wcm9jLm1hcHBlZFBhdGhzKSxcblxuICAgIC8qKlxuICAgICAqIGRhdGEucHJvYy5kZWNvZGluZ0tleXNcbiAgICAgKlxuICAgICAqIG51bWJlciBvZiBrZXlzIHRoYXQgYXJlIHN0aWxsIGRlY29kaW5nXG4gICAgICovXG4gICAgZGVjb2RpbmdLZXlzOiBjcmVhdGVMZWFmKFxuICAgICAgW1wiLi9tYXBwZWRQYXRoc1wiXSxcbiAgICAgIG1hcHBlZFBhdGhzID0+IG1hcHBlZFBhdGhzLmRlY29kaW5nU3RhcnRlZFxuICAgIClcbiAgfSxcblxuICAvKipcbiAgICogZGF0YS5jdXJyZW50XG4gICAqL1xuICBjdXJyZW50OiB7XG4gICAgLyoqXG4gICAgICogZGF0YS5jdXJyZW50LnN0YXRlXG4gICAgICovXG4gICAgc3RhdGU6IHtcbiAgICAgIC8qKlxuICAgICAgICogZGF0YS5jdXJyZW50LnN0YXRlLnN0YWNrXG4gICAgICAgKi9cbiAgICAgIHN0YWNrOiBjcmVhdGVMZWFmKFxuICAgICAgICBbZXZtLmN1cnJlbnQuc3RhdGUuc3RhY2tdLFxuXG4gICAgICAgIHdvcmRzID0+ICh3b3JkcyB8fCBbXSkubWFwKHdvcmQgPT4gRGVjb2RlVXRpbHMuQ29udmVyc2lvbi50b0J5dGVzKHdvcmQpKVxuICAgICAgKSxcblxuICAgICAgLyoqXG4gICAgICAgKiBkYXRhLmN1cnJlbnQuc3RhdGUubWVtb3J5XG4gICAgICAgKi9cbiAgICAgIG1lbW9yeTogY3JlYXRlTGVhZihcbiAgICAgICAgW2V2bS5jdXJyZW50LnN0YXRlLm1lbW9yeV0sXG5cbiAgICAgICAgd29yZHMgPT4gRGVjb2RlVXRpbHMuQ29udmVyc2lvbi50b0J5dGVzKHdvcmRzLmpvaW4oXCJcIikpXG4gICAgICApLFxuXG4gICAgICAvKipcbiAgICAgICAqIGRhdGEuY3VycmVudC5zdGF0ZS5jYWxsZGF0YVxuICAgICAgICovXG4gICAgICBjYWxsZGF0YTogY3JlYXRlTGVhZihcbiAgICAgICAgW2V2bS5jdXJyZW50LmNhbGxdLFxuXG4gICAgICAgICh7IGRhdGEgfSkgPT4gRGVjb2RlVXRpbHMuQ29udmVyc2lvbi50b0J5dGVzKGRhdGEpXG4gICAgICApLFxuXG4gICAgICAvKipcbiAgICAgICAqIGRhdGEuY3VycmVudC5zdGF0ZS5zdG9yYWdlXG4gICAgICAgKi9cbiAgICAgIHN0b3JhZ2U6IGNyZWF0ZUxlYWYoXG4gICAgICAgIFtldm0uY3VycmVudC5jb2RleC5zdG9yYWdlXSxcblxuICAgICAgICBtYXBwaW5nID0+XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgLi4uT2JqZWN0LmVudHJpZXMobWFwcGluZykubWFwKChbYWRkcmVzcywgd29yZF0pID0+ICh7XG4gICAgICAgICAgICAgIFtgMHgke2FkZHJlc3N9YF06IERlY29kZVV0aWxzLkNvbnZlcnNpb24udG9CeXRlcyh3b3JkKVxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgKVxuICAgICAgKSxcblxuICAgICAgLypcbiAgICAgICAqIGRhdGEuY3VycmVudC5zdGF0ZS5zcGVjaWFsc1xuICAgICAgICogSSd2ZSBuYW1lZCB0aGVzZSBhZnRlciB0aGUgc29saWRpdHkgdmFyaWFibGVzIHRoZXkgY29ycmVzcG9uZCB0byxcbiAgICAgICAqIHdoaWNoIGFyZSAqbW9zdGx5KiB0aGUgc2FtZSBhcyB0aGUgY29ycmVzcG9uZGluZyBFVk0gb3Bjb2Rlc1xuICAgICAgICogKEZXSVc6IHRoaXMgPSBBRERSRVNTLCBzZW5kZXIgPSBDQUxMRVIsIHZhbHVlID0gQ0FMTFZBTFVFKVxuICAgICAgICovXG4gICAgICBzcGVjaWFsczogY3JlYXRlTGVhZihcbiAgICAgICAgW1wiL2N1cnJlbnQvYWRkcmVzc1wiLCBldm0uY3VycmVudC5jYWxsLCBldm0uaW5mby5nbG9iYWxzXSxcbiAgICAgICAgKGFkZHJlc3MsIHsgc2VuZGVyLCB2YWx1ZSB9LCB7IHR4LCBibG9jayB9KSA9PiAoe1xuICAgICAgICAgIHRoaXM6IERlY29kZVV0aWxzLkNvbnZlcnNpb24udG9CeXRlcyhhZGRyZXNzKSxcblxuICAgICAgICAgIHNlbmRlcjogRGVjb2RlVXRpbHMuQ29udmVyc2lvbi50b0J5dGVzKHNlbmRlciksXG5cbiAgICAgICAgICB2YWx1ZTogRGVjb2RlVXRpbHMuQ29udmVyc2lvbi50b0J5dGVzKHZhbHVlKSxcblxuICAgICAgICAgIC8vbGV0J3MgY3JhY2sgb3BlbiB0aGF0IHR4IGFuZCBibG9jayFcbiAgICAgICAgICAuLi5PYmplY3QuYXNzaWduKFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICAuLi5PYmplY3QuZW50cmllcyh0eCkubWFwKChbdmFyaWFibGUsIHZhbHVlXSkgPT4gKHtcbiAgICAgICAgICAgICAgW3ZhcmlhYmxlXTogRGVjb2RlVXRpbHMuQ29udmVyc2lvbi50b0J5dGVzKHZhbHVlKVxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgKSxcblxuICAgICAgICAgIC4uLk9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIC4uLk9iamVjdC5lbnRyaWVzKGJsb2NrKS5tYXAoKFt2YXJpYWJsZSwgdmFsdWVdKSA9PiAoe1xuICAgICAgICAgICAgICBbdmFyaWFibGVdOiBEZWNvZGVVdGlscy5Db252ZXJzaW9uLnRvQnl0ZXModmFsdWUpXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICApXG4gICAgICAgIH0pXG4gICAgICApXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGRhdGEuY3VycmVudC5ub2RlXG4gICAgICovXG4gICAgbm9kZTogY3JlYXRlTGVhZihbc29saWRpdHkuY3VycmVudC5ub2RlXSwgaWRlbnRpdHkpLFxuXG4gICAgLyoqXG4gICAgICogZGF0YS5jdXJyZW50LnNjb3BlXG4gICAgICogb2xkIGFsaWFzIGZvciBkYXRhLmN1cnJlbnQubm9kZSAoZGVwcmVjYXRlZClcbiAgICAgKi9cbiAgICBzY29wZTogY3JlYXRlTGVhZihbXCIuL25vZGVcIl0sIGlkZW50aXR5KSxcblxuICAgIC8qKlxuICAgICAqIGRhdGEuY3VycmVudC5mdW5jdGlvbkRlcHRoXG4gICAgICovXG5cbiAgICBmdW5jdGlvbkRlcHRoOiBjcmVhdGVMZWFmKFtzb2xpZGl0eS5jdXJyZW50LmZ1bmN0aW9uRGVwdGhdLCBpZGVudGl0eSksXG5cbiAgICAvKipcbiAgICAgKiBkYXRhLmN1cnJlbnQuYWRkcmVzc1xuICAgICAqIE5PVEU6IHRoaXMgaXMgdGhlIFNUT1JBR0UgYWRkcmVzcyBmb3IgdGhlIGN1cnJlbnQgY2FsbCwgbm90IHRoZSBDT0RFXG4gICAgICogYWRkcmVzc1xuICAgICAqL1xuXG4gICAgYWRkcmVzczogY3JlYXRlTGVhZihbZXZtLmN1cnJlbnQuY2FsbF0sIGNhbGwgPT4gY2FsbC5zdG9yYWdlQWRkcmVzcyksXG5cbiAgICAvKlxuICAgICAqIGRhdGEuY3VycmVudC5hYm91dFRvTW9kaWZ5XG4gICAgICogSEFDS1xuICAgICAqIFRoaXMgc2VsZWN0b3IgaXMgdXNlZCB0byBjYXRjaCB0aG9zZSB0aW1lcyB3aGVuIHdlIGdvIHN0cmFpZ2h0IGZyb20gYVxuICAgICAqIG1vZGlmaWVyIGludm9jYXRpb24gaW50byB0aGUgbW9kaWZpZXIgaXRzZWxmLCBza2lwcGluZyBvdmVyIHRoZVxuICAgICAqIGRlZmluaXRpb24gbm9kZSAodGhpcyBpbmNsdWRlcyBiYXNlIGNvbnN0cnVjdG9yIGNhbGxzKS4gIFNvIGl0IHNob3VsZFxuICAgICAqIHJldHVybiB0cnVlIHdoZW46XG4gICAgICogMS4gd2UncmUgb24gdGhlIG5vZGUgY29ycmVzcG9uZGluZyB0byBhbiBhcmd1bWVudCB0byBhIG1vZGlmaWVyXG4gICAgICogaW52b2NhdGlvbiBvciBiYXNlIGNvbnN0cnVjdG9yIGNhbGwsIG9yLCBpZiBzYWlkIGFyZ3VtZW50IGlzIGEgdHlwZVxuICAgICAqIGNvbnZlcnNpb24sIGl0cyBhcmd1bWVudCAob3IgbmVzdGVkIGFyZ3VtZW50KVxuICAgICAqIDIuIHRoZSBuZXh0IG5vZGUgaXMgbm90IGEgRnVuY3Rpb25EZWZpbml0aW9uLCBNb2RpZmllckRlZmluaXRpb24sIG9yXG4gICAgICogaW4gdGhlIHNhbWUgbW9kaWZpZXIgLyBiYXNlIGNvbnN0cnVjdG9yIGludm9jYXRpb25cbiAgICAgKi9cbiAgICBhYm91dFRvTW9kaWZ5OiBjcmVhdGVMZWFmKFxuICAgICAgW1xuICAgICAgICBcIi4vbm9kZVwiLFxuICAgICAgICBcIi4vbW9kaWZpZXJJbnZvY2F0aW9uXCIsXG4gICAgICAgIFwiLi9tb2RpZmllckFyZ3VtZW50SW5kZXhcIixcbiAgICAgICAgXCIvbmV4dC9ub2RlXCIsXG4gICAgICAgIFwiL25leHQvbW9kaWZpZXJJbnZvY2F0aW9uXCIsXG4gICAgICAgIGV2bS5jdXJyZW50LnN0ZXAuaXNDb250ZXh0Q2hhbmdlXG4gICAgICBdLFxuICAgICAgKG5vZGUsIGludm9jYXRpb24sIGluZGV4LCBuZXh0LCBuZXh0SW52b2NhdGlvbiwgaXNDb250ZXh0Q2hhbmdlKSA9PiB7XG4gICAgICAgIC8vZW5zdXJlOiBjdXJyZW50IGluc3RydWN0aW9uIGlzIG5vdCBhIGNvbnRleHQgY2hhbmdlIChiZWNhdXNlIGlmIGl0IGlzXG4gICAgICAgIC8vd2UgY2Fubm90IHJlbHkgb24gdGhlIGRhdGEubmV4dCBzZWxlY3RvcnMsIGJ1dCBhbHNvIGlmIGl0IGlzIHdlIGtub3dcbiAgICAgICAgLy93ZSdyZSBub3QgYWJvdXQgdG8gY2FsbCBhIG1vZGlmaWVyIG9yIGJhc2UgY29uc3RydWN0b3IhKVxuICAgICAgICAvL3dlIGFsc28gd2FudCB0byByZXR1cm4gZmFsc2UgaWYgd2UgY2FuJ3QgZmluZCB0aGluZ3MgZm9yIHdoYXRldmVyXG4gICAgICAgIC8vcmVhc29uXG4gICAgICAgIGlmIChcbiAgICAgICAgICBpc0NvbnRleHRDaGFuZ2UgfHxcbiAgICAgICAgICAhbm9kZSB8fFxuICAgICAgICAgICFuZXh0IHx8XG4gICAgICAgICAgIWludm9jYXRpb24gfHxcbiAgICAgICAgICAhbmV4dEludm9jYXRpb25cbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9lbnN1cmU6IGN1cnJlbnQgcG9zaXRpb24gaXMgaW4gYSBNb2RpZmllckludm9jYXRpb24gb3JcbiAgICAgICAgLy9Jbmhlcml0YW5jZVNwZWNpZmllciAocmVjYWxsIHRoYXQgU291cmNlVW5pdCB3YXMgaW5jbHVkZWQgYXNcbiAgICAgICAgLy9mYWxsYmFjaylcbiAgICAgICAgaWYgKGludm9jYXRpb24ubm9kZVR5cGUgPT09IFwiU291cmNlVW5pdFwiKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9lbnN1cmU6IG5leHQgbm9kZSBpcyBub3QgYSBmdW5jdGlvbiBkZWZpbml0aW9uIG9yIG1vZGlmaWVyIGRlZmluaXRpb25cbiAgICAgICAgaWYgKFxuICAgICAgICAgIG5leHQubm9kZVR5cGUgPT09IFwiRnVuY3Rpb25EZWZpbml0aW9uXCIgfHxcbiAgICAgICAgICBuZXh0Lm5vZGVUeXBlID09PSBcIk1vZGlmaWVyRGVmaW5pdGlvblwiXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vZW5zdXJlOiBuZXh0IG5vZGUgaXMgbm90IGluIHRoZSBzYW1lIGludm9jYXRpb25cbiAgICAgICAgaWYgKFxuICAgICAgICAgIG5leHRJbnZvY2F0aW9uLm5vZGVUeXBlICE9PSBcIlNvdXJjZVVuaXRcIiAmJlxuICAgICAgICAgIG5leHRJbnZvY2F0aW9uLmlkID09PSBpbnZvY2F0aW9uLmlkXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vbm93OiBhcmUgd2Ugb24gdGhlIG5vZGUgY29ycmVzcG9uZGluZyB0byBhbiBhcmd1bWVudCwgb3IsIGlmXG4gICAgICAgIC8vaXQncyBhIHR5cGUgY29udmVyc2lvbiwgaXRzIG5lc3RlZCBhcmd1bWVudD9cbiAgICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFyZ3VtZW50ID0gaW52b2NhdGlvbi5hcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICB3aGlsZSAoYXJndW1lbnQua2luZCA9PT0gXCJ0eXBlQ29udmVyc2lvblwiKSB7XG4gICAgICAgICAgaWYgKG5vZGUuaWQgPT09IGFyZ3VtZW50LmlkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXJndW1lbnQgPSBhcmd1bWVudC5hcmd1bWVudHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUuaWQgPT09IGFyZ3VtZW50LmlkO1xuICAgICAgfVxuICAgICksXG5cbiAgICAvKlxuICAgICAqIGRhdGEuY3VycmVudC5tb2RpZmllckludm9jYXRpb25cbiAgICAgKi9cbiAgICBtb2RpZmllckludm9jYXRpb246IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIuL25vZGVcIiwgXCIvdmlld3Mvc2NvcGVzL2lubGluZWRcIl0sXG4gICAgICAobm9kZSwgc2NvcGVzKSA9PiB7XG4gICAgICAgIGNvbnN0IHR5cGVzID0gW1xuICAgICAgICAgIFwiTW9kaWZpZXJJbnZvY2F0aW9uXCIsXG4gICAgICAgICAgXCJJbmhlcml0YW5jZVNwZWNpZmllclwiLFxuICAgICAgICAgIFwiU291cmNlVW5pdFwiXG4gICAgICAgIF07XG4gICAgICAgIC8vYWdhaW4sIFNvdXJjZVVuaXQgaW5jbHVkZWQgYXMgZmFsbGJhY2tcbiAgICAgICAgcmV0dXJuIGZpbmRBbmNlc3Rvck9mVHlwZShub2RlLCB0eXBlcywgc2NvcGVzKTtcbiAgICAgIH1cbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogZGF0YS5jdXJyZW50Lm1vZGlmaWVyQXJndW1lbnRJbmRleFxuICAgICAqIGdldHMgdGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IG1vZGlmaWVyIGFyZ3VtZW50IHRoYXQgeW91J3JlIGluXG4gICAgICogKHVuZGVmaW5lZCB3aGVuIG5vdCBpbiBhIG1vZGlmaWVyIGFyZ3VtZW50KVxuICAgICAqL1xuICAgIG1vZGlmaWVyQXJndW1lbnRJbmRleDogY3JlYXRlTGVhZihcbiAgICAgIFtcIi9pbmZvL3Njb3Blc1wiLCBcIi4vbm9kZVwiLCBcIi4vbW9kaWZpZXJJbnZvY2F0aW9uXCJdLFxuICAgICAgKHNjb3Blcywgbm9kZSwgaW52b2NhdGlvbikgPT4ge1xuICAgICAgICBpZiAoaW52b2NhdGlvbi5ub2RlVHlwZSA9PT0gXCJTb3VyY2VVbml0XCIpIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHBvaW50ZXIgPSBzY29wZXNbbm9kZS5pZF0ucG9pbnRlcjtcbiAgICAgICAgbGV0IGludm9jYXRpb25Qb2ludGVyID0gc2NvcGVzW2ludm9jYXRpb24uaWRdLnBvaW50ZXI7XG5cbiAgICAgICAgLy9zbGljZSB0aGUgaW52b2NhdGlvbiBwb2ludGVyIG9mZiB0aGUgYmVnaW5uaW5nXG4gICAgICAgIGxldCBkaWZmZXJlbmNlID0gcG9pbnRlci5yZXBsYWNlKGludm9jYXRpb25Qb2ludGVyLCBcIlwiKTtcbiAgICAgICAgZGVidWcoXCJkaWZmZXJlbmNlICVzXCIsIGRpZmZlcmVuY2UpO1xuICAgICAgICBsZXQgcmF3SW5kZXggPSBkaWZmZXJlbmNlLm1hdGNoKC9eXFwvYXJndW1lbnRzXFwvKFxcZCspLyk7XG4gICAgICAgIC8vbm90ZSB0aGF0IHRoYXQgXFxkKyBpcyBncmVlZHlcbiAgICAgICAgZGVidWcoXCJyYXdJbmRleCAlb1wiLCByYXdJbmRleCk7XG4gICAgICAgIGlmIChyYXdJbmRleCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHJhd0luZGV4WzFdKTtcbiAgICAgIH1cbiAgICApLFxuXG4gICAgLypcbiAgICAgKiBkYXRhLmN1cnJlbnQubW9kaWZpZXJCZWluZ0ludm9rZWRcbiAgICAgKiBnZXRzIHRoZSBub2RlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIG1vZGlmaWVyIG9yIGJhc2UgY29uc3RydWN0b3JcbiAgICAgKiBiZWluZyBpbnZva2VkXG4gICAgICovXG4gICAgbW9kaWZpZXJCZWluZ0ludm9rZWQ6IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIuL21vZGlmaWVySW52b2NhdGlvblwiLCBcIi92aWV3cy9zY29wZXMvaW5saW5lZFwiXSxcbiAgICAgIChpbnZvY2F0aW9uLCBzY29wZXMpID0+IHtcbiAgICAgICAgaWYgKCFpbnZvY2F0aW9uIHx8IGludm9jYXRpb24ubm9kZVR5cGUgPT09IFwiU291cmNlVW5pdFwiKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtb2RpZmllckZvckludm9jYXRpb24oaW52b2NhdGlvbiwgc2NvcGVzKTtcbiAgICAgIH1cbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogZGF0YS5jdXJyZW50LmlkZW50aWZpZXJzIChuYW1lc3BhY2UpXG4gICAgICovXG4gICAgaWRlbnRpZmllcnM6IHtcbiAgICAgIC8qKlxuICAgICAgICogZGF0YS5jdXJyZW50LmlkZW50aWZpZXJzIChzZWxlY3RvcilcbiAgICAgICAqXG4gICAgICAgKiByZXR1cm5zIGlkZW50aWZlcnMgYW5kIGNvcnJlc3BvbmRpbmcgZGVmaW5pdGlvbiBub2RlIElEIG9yIGJ1aWx0aW4gbmFtZVxuICAgICAgICogKG9iamVjdCBlbnRyaWVzIGxvb2sgbGlrZSBbbmFtZV06IHthc3RJZDogaWR9IG9yIGxpa2UgW25hbWVdOiB7YnVpbHRpbjogbmFtZX1cbiAgICAgICAqL1xuICAgICAgXzogY3JlYXRlTGVhZihcbiAgICAgICAgW1wiL3ZpZXdzL3Njb3Blcy9pbmxpbmVkXCIsIFwiL2N1cnJlbnQvbm9kZVwiXSxcblxuICAgICAgICAoc2NvcGVzLCBzY29wZSkgPT4ge1xuICAgICAgICAgIGxldCB2YXJpYWJsZXMgPSB7fTtcbiAgICAgICAgICBpZiAoc2NvcGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IGN1ciA9IHNjb3BlLmlkO1xuXG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHZhcmlhYmxlcyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICAgICAgdmFyaWFibGVzLFxuICAgICAgICAgICAgICAgIC4uLihzY29wZXNbY3VyXS52YXJpYWJsZXMgfHwgW10pXG4gICAgICAgICAgICAgICAgICAuZmlsdGVyKHYgPT4gdi5uYW1lICE9PSBcIlwiKSAvL2V4Y2x1ZGUgYW5vbnltb3VzIG91dHB1dCBwYXJhbXNcbiAgICAgICAgICAgICAgICAgIC5maWx0ZXIodiA9PiB2YXJpYWJsZXNbdi5uYW1lXSA9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAubWFwKHYgPT4gKHsgW3YubmFtZV06IHsgYXN0SWQ6IHYuaWQgfSB9KSlcbiAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICBjdXIgPSBzY29wZXNbY3VyXS5wYXJlbnRJZDtcbiAgICAgICAgICAgIH0gd2hpbGUgKGN1ciAhPSBudWxsKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgYnVpbHRpbnMgPSB7XG4gICAgICAgICAgICBtc2c6IHsgYnVpbHRpbjogXCJtc2dcIiB9LFxuICAgICAgICAgICAgdHg6IHsgYnVpbHRpbjogXCJ0eFwiIH0sXG4gICAgICAgICAgICBibG9jazogeyBidWlsdGluOiBcImJsb2NrXCIgfSxcbiAgICAgICAgICAgIHRoaXM6IHsgYnVpbHRpbjogXCJ0aGlzXCIgfSxcbiAgICAgICAgICAgIG5vdzogeyBidWlsdGluOiBcIm5vd1wiIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcmV0dXJuIHsgLi4udmFyaWFibGVzLCAuLi5idWlsdGlucyB9O1xuICAgICAgICB9XG4gICAgICApLFxuXG4gICAgICAvKipcbiAgICAgICAqIGRhdGEuY3VycmVudC5pZGVudGlmaWVycy5kZWZpbml0aW9ucyAobmFtZXNwYWNlKVxuICAgICAgICovXG4gICAgICBkZWZpbml0aW9uczoge1xuICAgICAgICAvKiBkYXRhLmN1cnJlbnQuaWRlbnRpZmllcnMuZGVmaW5pdGlvbnMgKHNlbGVjdG9yKVxuICAgICAgICAgKiBkZWZpbml0aW9ucyBmb3IgY3VycmVudCB2YXJpYWJsZXMsIGJ5IGlkZW50aWZpZXJcbiAgICAgICAgICovXG4gICAgICAgIF86IGNyZWF0ZUxlYWYoXG4gICAgICAgICAgW1wiL3ZpZXdzL3Njb3Blcy9pbmxpbmVkXCIsIFwiLi4vX1wiLCBcIi4vdGhpc1wiXSxcblxuICAgICAgICAgIChzY29wZXMsIGlkZW50aWZpZXJzLCB0aGlzRGVmaW5pdGlvbikgPT4ge1xuICAgICAgICAgICAgbGV0IHZhcmlhYmxlcyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICAuLi5PYmplY3QuZW50cmllcyhpZGVudGlmaWVycykubWFwKChbaWRlbnRpZmllciwgeyBhc3RJZCB9XSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhc3RJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAvL3dpbGwgYmUgdW5kZWZpbmVkIGZvciBidWlsdGluc1xuICAgICAgICAgICAgICAgICAgbGV0IHsgZGVmaW5pdGlvbiB9ID0gc2NvcGVzW2FzdElkXTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7IFtpZGVudGlmaWVyXTogZGVmaW5pdGlvbiB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4ge307IC8vc2tpcCBvdmVyIGJ1aWx0aW5zOyB3ZSdsbCBoYW5kbGUgdGhvc2Ugc2VwYXJhdGVseVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsZXQgYnVpbHRpbnMgPSB7XG4gICAgICAgICAgICAgIG1zZzogRGVjb2RlVXRpbHMuRGVmaW5pdGlvbi5NU0dfREVGSU5JVElPTixcbiAgICAgICAgICAgICAgdHg6IERlY29kZVV0aWxzLkRlZmluaXRpb24uVFhfREVGSU5JVElPTixcbiAgICAgICAgICAgICAgYmxvY2s6IERlY29kZVV0aWxzLkRlZmluaXRpb24uQkxPQ0tfREVGSU5JVElPTixcbiAgICAgICAgICAgICAgdGhpczogdGhpc0RlZmluaXRpb24sXG4gICAgICAgICAgICAgIG5vdzogRGVjb2RlVXRpbHMuRGVmaW5pdGlvbi5zcG9vZlVpbnREZWZpbml0aW9uKFwibm93XCIpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHsgLi4udmFyaWFibGVzLCAuLi5idWlsdGlucyB9O1xuICAgICAgICAgIH1cbiAgICAgICAgKSxcblxuICAgICAgICAvKlxuICAgICAgICAgKiBkYXRhLmN1cnJlbnQuaWRlbnRpZmllcnMuZGVmaW5pdGlvbnMudGhpc1xuICAgICAgICAgKlxuICAgICAgICAgKiByZXR1cm5zIGEgc3Bvb2ZlZCBkZWZpbml0aW9uIGZvciB0aGUgdGhpcyB2YXJpYWJsZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpczogY3JlYXRlTGVhZihcbiAgICAgICAgICBbZXZtLmN1cnJlbnQuY29udGV4dF0sXG4gICAgICAgICAgKHsgY29udHJhY3ROYW1lLCBjb250cmFjdElkIH0pID0+XG4gICAgICAgICAgICBEZWNvZGVVdGlscy5EZWZpbml0aW9uLnNwb29mVGhpc0RlZmluaXRpb24oY29udHJhY3ROYW1lLCBjb250cmFjdElkKVxuICAgICAgICApXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIGRhdGEuY3VycmVudC5pZGVudGlmaWVycy5yZWZzXG4gICAgICAgKlxuICAgICAgICogY3VycmVudCB2YXJpYWJsZXMnIHZhbHVlIHJlZnNcbiAgICAgICAqL1xuICAgICAgcmVmczogY3JlYXRlTGVhZihcbiAgICAgICAgW1xuICAgICAgICAgIFwiL3Byb2MvYXNzaWdubWVudHNcIixcbiAgICAgICAgICBcIi4vX1wiLFxuICAgICAgICAgIFwiL2N1cnJlbnQvZnVuY3Rpb25EZXB0aFwiLCAvL2ZvciBwcnVuaW5nIHRoaW5ncyB0b28gZGVlcCBvbiBzdGFja1xuICAgICAgICAgIFwiL2N1cnJlbnQvYWRkcmVzc1wiIC8vZm9yIGNvbnRyYWN0IHZhcmlhYmxlc1xuICAgICAgICBdLFxuXG4gICAgICAgIChhc3NpZ25tZW50cywgaWRlbnRpZmllcnMsIGN1cnJlbnREZXB0aCwgYWRkcmVzcykgPT5cbiAgICAgICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICAuLi5PYmplY3QuZW50cmllcyhpZGVudGlmaWVycykubWFwKFxuICAgICAgICAgICAgICAoW2lkZW50aWZpZXIsIHsgYXN0SWQsIGJ1aWx0aW4gfV0pID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgaWQ7XG5cbiAgICAgICAgICAgICAgICAvL2lzIHRoaXMgYW4gb3JkaW5hcnkgdmFyaWFibGUgb3IgYSBidWlsdGluP1xuICAgICAgICAgICAgICAgIGlmIChhc3RJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAvL2lmIG5vdCBhIGJ1aWx0aW4sIGZpcnN0IGNoZWNrIGlmIGl0J3MgYSBjb250cmFjdCB2YXJcbiAgICAgICAgICAgICAgICAgIGxldCBtYXRjaElkcyA9IChhc3NpZ25tZW50cy5ieUFzdElkW2FzdElkXSB8fCBbXSkuZmlsdGVyKFxuICAgICAgICAgICAgICAgICAgICBpZEhhc2ggPT4gYXNzaWdubWVudHMuYnlJZFtpZEhhc2hdLmFkZHJlc3MgPT09IGFkZHJlc3NcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBpZiAobWF0Y2hJZHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZCA9IG1hdGNoSWRzWzBdOyAvL3RoZXJlIHNob3VsZCBvbmx5IGJlIG9uZSFcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgLy9pZiBub3QgY29udHJhY3QsIGl0J3MgbG9jYWwsIHNvIGZpbmQgdGhlIGlubmVybW9zdFxuICAgICAgICAgICAgICAgICAgLy8oYnV0IG5vdCBiZXlvbmQgY3VycmVudCBkZXB0aClcbiAgICAgICAgICAgICAgICAgIGlmIChpZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtYXRjaEZyYW1lcyA9IChhc3NpZ25tZW50cy5ieUFzdElkW2FzdElkXSB8fCBbXSlcbiAgICAgICAgICAgICAgICAgICAgICAubWFwKGlkID0+IGFzc2lnbm1lbnRzLmJ5SWRbaWRdLnN0YWNrZnJhbWUpXG4gICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihzdGFja2ZyYW1lID0+IHN0YWNrZnJhbWUgIT09IHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoRnJhbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAvL3RoaXMgY2hlY2sgaXNuJ3QgKnJlYWxseSpcbiAgICAgICAgICAgICAgICAgICAgICAvL25lY2Vzc2FyeSwgYnV0IG1heSBhcyB3ZWxsIHByZXZlbnQgc3R1cGlkIHN0dWZmXG4gICAgICAgICAgICAgICAgICAgICAgbGV0IG1heE1hdGNoID0gTWF0aC5taW4oXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGVwdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1heCguLi5tYXRjaEZyYW1lcylcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgIGlkID0gc3RhYmxlS2VjY2FrMjU2KHsgYXN0SWQsIHN0YWNrZnJhbWU6IG1heE1hdGNoIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vb3RoZXJ3aXNlLCBpdCdzIGEgYnVpbHRpblxuICAgICAgICAgICAgICAgICAgLy9OT1RFOiBmb3Igbm93IHdlIGFzc3VtZSB0aGVyZSBpcyBvbmx5IG9uZSBhc3NpZ25tZW50IHBlclxuICAgICAgICAgICAgICAgICAgLy9idWlsdGluLCBidXQgdGhpcyB3aWxsIGNoYW5nZSBpbiB0aGUgZnV0dXJlXG4gICAgICAgICAgICAgICAgICBpZCA9IGFzc2lnbm1lbnRzLmJ5QnVpbHRpbltidWlsdGluXVswXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL2lmIHdlIHN0aWxsIGRpZG4ndCBmaW5kIGl0LCBvaCB3ZWxsXG5cbiAgICAgICAgICAgICAgICBsZXQgeyByZWYgfSA9IGFzc2lnbm1lbnRzLmJ5SWRbaWRdIHx8IHt9O1xuICAgICAgICAgICAgICAgIGlmICghcmVmKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICBbaWRlbnRpZmllcl06IHJlZlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICApLFxuXG4gICAgICAvKipcbiAgICAgICAqIGRhdGEuY3VycmVudC5pZGVudGlmaWVycy5kZWNvZGVkXG4gICAgICAgKlxuICAgICAgICogUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB2YWx1ZXMgYXMgUHJvbWlzZXNcbiAgICAgICAqL1xuICAgICAgZGVjb2RlZDogY3JlYXRlTGVhZihcbiAgICAgICAgW1wiL3ZpZXdzL2RlY29kZXJcIiwgXCIuL2RlZmluaXRpb25zXCIsIFwiLi9yZWZzXCJdLFxuXG4gICAgICAgIGFzeW5jIChkZWNvZGUsIGRlZmluaXRpb25zLCByZWZzKSA9PiB7XG4gICAgICAgICAgZGVidWcoXCJzZXR0aW5nIHVwIGtleWVkUHJvbWlzZXNcIik7XG4gICAgICAgICAgY29uc3Qga2V5ZWRQcm9taXNlcyA9IE9iamVjdC5lbnRyaWVzKHJlZnMpLm1hcChcbiAgICAgICAgICAgIGFzeW5jIChbaWRlbnRpZmllciwgcmVmXSkgPT4gKHtcbiAgICAgICAgICAgICAgW2lkZW50aWZpZXJdOiBhd2FpdCBkZWNvZGUoZGVmaW5pdGlvbnNbaWRlbnRpZmllcl0sIHJlZilcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgICBkZWJ1ZyhcInNldCB1cCBrZXllZFByb21pc2VzXCIpO1xuICAgICAgICAgIGNvbnN0IGtleWVkUmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKGtleWVkUHJvbWlzZXMpO1xuICAgICAgICAgIGRlYnVnKFwiZ290IGtleWVkUmVzdWx0c1wiKTtcbiAgICAgICAgICByZXR1cm4gRGVjb2RlVXRpbHMuQ29udmVyc2lvbi5jbGVhbkNvbnRhaW5lcnMoXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LCAuLi5rZXllZFJlc3VsdHMpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgKVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogZGF0YS5uZXh0XG4gICAqL1xuICBuZXh0OiB7XG4gICAgLyoqXG4gICAgICogZGF0YS5uZXh0LnN0YXRlXG4gICAgICogWWVzLCBJJ20ganVzdCByZXBlYXRpbmcgdGhlIGNvZGUgZm9yIGRhdGEuY3VycmVudC5zdGF0ZS5zdGFjayBoZXJlO1xuICAgICAqIG5vdCB3b3J0aCB0aGUgdHJvdWJsZSB0byBmYWN0b3Igb3V0XG4gICAgICovXG4gICAgc3RhdGU6IHtcbiAgICAgIC8qKlxuICAgICAgICogZGF0YS5uZXh0LnN0YXRlLnN0YWNrXG4gICAgICAgKi9cbiAgICAgIHN0YWNrOiBjcmVhdGVMZWFmKFxuICAgICAgICBbZXZtLm5leHQuc3RhdGUuc3RhY2tdLFxuXG4gICAgICAgIHdvcmRzID0+ICh3b3JkcyB8fCBbXSkubWFwKHdvcmQgPT4gRGVjb2RlVXRpbHMuQ29udmVyc2lvbi50b0J5dGVzKHdvcmQpKVxuICAgICAgKVxuICAgIH0sXG5cbiAgICAvL0hBQ0sgV0FSTklOR1xuICAgIC8vdGhlIGZvbGxvd2luZyBzZWxlY3RvcnMgZGVwZW5kIG9uIHNvbGlkaXR5Lm5leHRcbiAgICAvL2RvIG5vdCB1c2UgdGhlbSB3aGVuIHRoZSBjdXJyZW50IGluc3RydWN0aW9uIGlzIGEgY29udGV4dCBjaGFuZ2UhXG5cbiAgICAvKipcbiAgICAgKiBkYXRhLm5leHQubm9kZVxuICAgICAqL1xuICAgIG5vZGU6IGNyZWF0ZUxlYWYoW3NvbGlkaXR5Lm5leHQubm9kZV0sIGlkZW50aXR5KSxcblxuICAgIC8qKlxuICAgICAqIGRhdGEubmV4dC5tb2RpZmllckludm9jYXRpb25cbiAgICAgKiBOb3RlOiB5ZXMsIEknbSBqdXN0IHJlcGVhdGluZyB0aGUgY29kZSBmcm9tIGRhdGEuY3VycmVudCBoZXJlIGJ1dCB3aXRoXG4gICAgICogaW52YWxpZCBhZGRlZFxuICAgICAqL1xuICAgIG1vZGlmaWVySW52b2NhdGlvbjogY3JlYXRlTGVhZihcbiAgICAgIFtcIi4vbm9kZVwiLCBcIi92aWV3cy9zY29wZXMvaW5saW5lZFwiLCBldm0uY3VycmVudC5zdGVwLmlzQ29udGV4dENoYW5nZV0sXG4gICAgICAobm9kZSwgc2NvcGVzLCBpbnZhbGlkKSA9PiB7XG4gICAgICAgIC8vZG9uJ3QgYXR0ZW1wdCB0aGlzIGF0IGEgY29udGV4dCBjaGFuZ2UhXG4gICAgICAgIC8vKGFsc28gZG9uJ3QgYXR0ZW1wdCB0aGlzIGlmIHdlIGNhbid0IGZpbmQgdGhlIG5vZGUgZm9yIHdoYXRldmVyXG4gICAgICAgIC8vcmVhc29uKVxuICAgICAgICBpZiAoaW52YWxpZCB8fCAhbm9kZSkge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHlwZXMgPSBbXG4gICAgICAgICAgXCJNb2RpZmllckludm9jYXRpb25cIixcbiAgICAgICAgICBcIkluaGVyaXRhbmNlU3BlY2lmaWVyXCIsXG4gICAgICAgICAgXCJTb3VyY2VVbml0XCJcbiAgICAgICAgXTtcbiAgICAgICAgLy9hZ2FpbiwgU291cmNlVW5pdCBpbmNsdWRlZCBhcyBmYWxsYmFja1xuICAgICAgICByZXR1cm4gZmluZEFuY2VzdG9yT2ZUeXBlKG5vZGUsIHR5cGVzLCBzY29wZXMpO1xuICAgICAgfVxuICAgICksXG5cbiAgICAvKlxuICAgICAqIGRhdGEubmV4dC5tb2RpZmllckJlaW5nSW52b2tlZFxuICAgICAqL1xuICAgIG1vZGlmaWVyQmVpbmdJbnZva2VkOiBjcmVhdGVMZWFmKFxuICAgICAgW1xuICAgICAgICBcIi4vbW9kaWZpZXJJbnZvY2F0aW9uXCIsXG4gICAgICAgIFwiL3ZpZXdzL3Njb3Blcy9pbmxpbmVkXCIsXG4gICAgICAgIGV2bS5jdXJyZW50LnN0ZXAuaXNDb250ZXh0Q2hhbmdlXG4gICAgICBdLFxuICAgICAgKGludm9jYXRpb24sIHNjb3BlcywgaW52YWxpZCkgPT4ge1xuICAgICAgICBpZiAoaW52YWxpZCB8fCAhaW52b2NhdGlvbiB8fCBpbnZvY2F0aW9uLm5vZGVUeXBlID09PSBcIlNvdXJjZVVuaXRcIikge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbW9kaWZpZXJGb3JJbnZvY2F0aW9uKGludm9jYXRpb24sIHNjb3Blcyk7XG4gICAgICB9XG4gICAgKVxuICAgIC8vRU5EIEhBQ0sgV0FSTklOR1xuICB9LFxuXG4gIC8qKlxuICAgKiBkYXRhLm5leHRNYXBwZWRcbiAgICovXG4gIG5leHRNYXBwZWQ6IHtcbiAgICAvKipcbiAgICAgKiBkYXRhLm5leHRNYXBwZWQuc3RhdGVcbiAgICAgKiBZZXMsIEknbSBqdXN0IHJlcGVhdGluZyB0aGUgY29kZSBmb3IgZGF0YS5jdXJyZW50LnN0YXRlLnN0YWNrIGhlcmU7XG4gICAgICogbm90IHdvcnRoIHRoZSB0cm91YmxlIHRvIGZhY3RvciBvdXRcbiAgICAgKiBIQUNLOiB0aGlzIGFzc3VtZXMgd2UncmUgbm90IGFib3V0IHRvIGNoYW5nZSBjb250ZXh0ISBkb24ndCB1c2UgdGhpcyBpZiB3ZVxuICAgICAqIGFyZSFcbiAgICAgKi9cbiAgICBzdGF0ZToge1xuICAgICAgLyoqXG4gICAgICAgKiBkYXRhLm5leHRNYXBwZWQuc3RhdGUuc3RhY2tcbiAgICAgICAqL1xuICAgICAgc3RhY2s6IGNyZWF0ZUxlYWYoXG4gICAgICAgIFtzb2xpZGl0eS5jdXJyZW50Lm5leHRNYXBwZWRdLFxuXG4gICAgICAgIHN0ZXAgPT5cbiAgICAgICAgICAoKHN0ZXAgfHwge30pLnN0YWNrIHx8IFtdKS5tYXAod29yZCA9PlxuICAgICAgICAgICAgRGVjb2RlVXRpbHMuQ29udmVyc2lvbi50b0J5dGVzKHdvcmQpXG4gICAgICAgICAgKVxuICAgICAgKVxuICAgIH1cbiAgfVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGRhdGE7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2RhdGEvc2VsZWN0b3JzL2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwianNvbi1wb2ludGVyXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwianNvbi1wb2ludGVyXCJcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qva2V5c1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qva2V5c1wiXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ0cnVmZmxlLWRlY29kZXJcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJ0cnVmZmxlLWRlY29kZXJcIlxuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOmNvbnRyb2xsZXI6c2VsZWN0b3JzXCIpOyAvL2VzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3JUcmVlLCBjcmVhdGVMZWFmIH0gZnJvbSBcInJlc2VsZWN0LXRyZWVcIjtcblxuaW1wb3J0IGV2bSBmcm9tIFwibGliL2V2bS9zZWxlY3RvcnNcIjtcbmltcG9ydCBzb2xpZGl0eSBmcm9tIFwibGliL3NvbGlkaXR5L3NlbGVjdG9yc1wiO1xuaW1wb3J0IHRyYWNlIGZyb20gXCJsaWIvdHJhY2Uvc2VsZWN0b3JzXCI7XG5cbmltcG9ydCB7IGFueU5vblNraXBwZWRJblJhbmdlIH0gZnJvbSBcImxpYi9hc3QvbWFwXCI7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgaWRlbnRpdHkgPSB4ID0+IHg7XG5cbi8qKlxuICogY29udHJvbGxlclxuICovXG5jb25zdCBjb250cm9sbGVyID0gY3JlYXRlU2VsZWN0b3JUcmVlKHtcbiAgLyoqXG4gICAqIGNvbnRyb2xsZXIuc3RhdGVcbiAgICovXG4gIHN0YXRlOiBzdGF0ZSA9PiBzdGF0ZS5jb250cm9sbGVyLFxuICAvKipcbiAgICogY29udHJvbGxlci5jdXJyZW50XG4gICAqL1xuICBjdXJyZW50OiB7XG4gICAgLyoqXG4gICAgICogY29udHJvbGxlci5jdXJyZW50LmZ1bmN0aW9uRGVwdGhcbiAgICAgKi9cbiAgICBmdW5jdGlvbkRlcHRoOiBjcmVhdGVMZWFmKFtzb2xpZGl0eS5jdXJyZW50LmZ1bmN0aW9uRGVwdGhdLCBpZGVudGl0eSksXG5cbiAgICAvKipcbiAgICAgKiBjb250cm9sbGVyLmN1cnJlbnQuZXhlY3V0aW9uQ29udGV4dFxuICAgICAqL1xuICAgIGV4ZWN1dGlvbkNvbnRleHQ6IGNyZWF0ZUxlYWYoW2V2bS5jdXJyZW50LmNhbGxdLCBpZGVudGl0eSksXG5cbiAgICAvKipcbiAgICAgKiBjb250cm9sbGVyLmN1cnJlbnQud2lsbEp1bXBcbiAgICAgKi9cbiAgICB3aWxsSnVtcDogY3JlYXRlTGVhZihbZXZtLmN1cnJlbnQuc3RlcC5pc0p1bXBdLCBpZGVudGl0eSksXG5cbiAgICAvKipcbiAgICAgKiBjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb25cbiAgICAgKi9cbiAgICBsb2NhdGlvbjoge1xuICAgICAgLyoqXG4gICAgICAgKiBjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb24uc291cmNlUmFuZ2VcbiAgICAgICAqL1xuICAgICAgc291cmNlUmFuZ2U6IGNyZWF0ZUxlYWYoW3NvbGlkaXR5LmN1cnJlbnQuc291cmNlUmFuZ2VdLCBpZGVudGl0eSksXG5cbiAgICAgIC8qKlxuICAgICAgICogY29udHJvbGxlci5jdXJyZW50LmxvY2F0aW9uLnNvdXJjZVxuICAgICAgICovXG4gICAgICBzb3VyY2U6IGNyZWF0ZUxlYWYoW3NvbGlkaXR5LmN1cnJlbnQuc291cmNlXSwgaWRlbnRpdHkpLFxuXG4gICAgICAvKipcbiAgICAgICAqIGNvbnRyb2xsZXIuY3VycmVudC5sb2NhdGlvbi5ub2RlXG4gICAgICAgKi9cbiAgICAgIG5vZGU6IGNyZWF0ZUxlYWYoW3NvbGlkaXR5LmN1cnJlbnQubm9kZV0sIGlkZW50aXR5KSxcblxuICAgICAgLyoqXG4gICAgICAgKiBjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb24uaXNNdWx0aWxpbmVcbiAgICAgICAqL1xuICAgICAgaXNNdWx0aWxpbmU6IGNyZWF0ZUxlYWYoW3NvbGlkaXR5LmN1cnJlbnQuaXNNdWx0aWxpbmVdLCBpZGVudGl0eSlcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY29udHJvbGxlci5jdXJyZW50LmZpbmlzaGVkXG4gICAgICovXG4gICAgZmluaXNoZWQ6IGNyZWF0ZUxlYWYoW3RyYWNlLmZpbmlzaGVkXSwgaWRlbnRpdHkpXG4gIH0sXG5cbiAgLyoqXG4gICAqIGNvbnRyb2xsZXIuYnJlYWtwb2ludHMgKG5hbWVzcGFjZSlcbiAgICovXG4gIGJyZWFrcG9pbnRzOiB7XG4gICAgLyoqXG4gICAgICogY29udHJvbGxlci5icmVha3BvaW50cyAoc2VsZWN0b3IpXG4gICAgICovXG4gICAgXzogY3JlYXRlTGVhZihbXCIvc3RhdGVcIl0sIHN0YXRlID0+IHN0YXRlLmJyZWFrcG9pbnRzKSxcblxuICAgIC8qKlxuICAgICAqIGNvbnRyb2xsZXIuYnJlYWtwb2ludHMucmVzb2x2ZXIgKHNlbGVjdG9yKVxuICAgICAqIHRoaXMgc2VsZWN0b3IgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgYWRqdXN0cyBhIGdpdmVuIGxpbmUtYmFzZWRcbiAgICAgKiBicmVha3BvaW50IChvbiBub2RlLWJhc2VkIGJyZWFrcG9pbnRzIGl0IHNpbXBseSByZXR1cm5zIHRoZSBpbnB1dCkgYnlcbiAgICAgKiByZXBlYXRlZGx5IG1vdmluZyBpdCBkb3duIGEgbGluZSB1bnRpbCBpdCBsYW5kcyBvbiBhIGxpbmUgd2hlcmUgdGhlcmUnc1xuICAgICAqIGFjdHVhbGx5IHNvbWV3aGVyZSB0byBicmVhay4gIGlmIG5vIHN1Y2ggbGluZSBleGlzdHMgYmV5b25kIHRoYXQgcG9pbnQsIGl0XG4gICAgICogcmV0dXJucyBudWxsIGluc3RlYWQuXG4gICAgICovXG4gICAgcmVzb2x2ZXI6IGNyZWF0ZUxlYWYoW3NvbGlkaXR5LmluZm8uc291cmNlc10sIHNvdXJjZXMgPT4gYnJlYWtwb2ludCA9PiB7XG4gICAgICBsZXQgYWRqdXN0ZWRCcmVha3BvaW50O1xuICAgICAgaWYgKGJyZWFrcG9pbnQubm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCBsaW5lID0gYnJlYWtwb2ludC5saW5lO1xuICAgICAgICBsZXQgeyBzb3VyY2UsIGFzdCB9ID0gc291cmNlc1ticmVha3BvaW50LnNvdXJjZUlkXTtcbiAgICAgICAgbGV0IGxpbmVMZW5ndGhzID0gc291cmNlLnNwbGl0KFwiXFxuXCIpLm1hcChsaW5lID0+IGxpbmUubGVuZ3RoKTtcbiAgICAgICAgLy93aHkgZG9lcyBuZWl0aGVyIEpTIG5vciBsb2Rhc2ggaGF2ZSBhIHNjYW4gZnVuY3Rpb24gbGlrZSBIYXNrZWxsPz9cbiAgICAgICAgLy9ndWVzcyB3ZSdsbCBoYXZlIHRvIGRvIG91ciBzY2FuIG1hbnVhbGx5XG4gICAgICAgIGxldCBsaW5lU3RhcnRzID0gWzBdO1xuICAgICAgICBmb3IgKGxldCBsZW5ndGggb2YgbGluZUxlbmd0aHMpIHtcbiAgICAgICAgICBsaW5lU3RhcnRzLnB1c2gobGluZVN0YXJ0c1tsaW5lU3RhcnRzLmxlbmd0aCAtIDFdICsgbGVuZ3RoICsgMSk7XG4gICAgICAgICAgLy8rMSBmb3IgdGhlIC9uIGl0c2VsZlxuICAgICAgICB9XG4gICAgICAgIGRlYnVnKFxuICAgICAgICAgIFwibGluZTogJXNcIixcbiAgICAgICAgICBzb3VyY2Uuc2xpY2UobGluZVN0YXJ0c1tsaW5lXSwgbGluZVN0YXJ0c1tsaW5lXSArIGxpbmVMZW5ndGhzW2xpbmVdKVxuICAgICAgICApO1xuICAgICAgICB3aGlsZSAoXG4gICAgICAgICAgbGluZSA8IGxpbmVMZW5ndGhzLmxlbmd0aCAmJlxuICAgICAgICAgICFhbnlOb25Ta2lwcGVkSW5SYW5nZShhc3QsIGxpbmVTdGFydHNbbGluZV0sIGxpbmVMZW5ndGhzW2xpbmVdKVxuICAgICAgICApIHtcbiAgICAgICAgICBkZWJ1ZyhcImluY3JlbWVudGluZ1wiKTtcbiAgICAgICAgICBsaW5lKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmUgPj0gbGluZUxlbmd0aHMubGVuZ3RoKSB7XG4gICAgICAgICAgYWRqdXN0ZWRCcmVha3BvaW50ID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGp1c3RlZEJyZWFrcG9pbnQgPSB7IC4uLmJyZWFrcG9pbnQsIGxpbmUgfTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVidWcoXCJub2RlLWJhc2VkIGJyZWFrcG9pbnRcIik7XG4gICAgICAgIGFkanVzdGVkQnJlYWtwb2ludCA9IGJyZWFrcG9pbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWRqdXN0ZWRCcmVha3BvaW50O1xuICAgIH0pXG4gIH0sXG5cbiAgLyoqXG4gICAqIGNvbnRyb2xsZXIuZmluaXNoZWRcbiAgICogZGVwcmVjYXRlZCBhbGlhcyBmb3IgY29udHJvbGxlci5jdXJyZW50LmZpbmlzaGVkXG4gICAqL1xuICBmaW5pc2hlZDogY3JlYXRlTGVhZihbXCIvY3VycmVudC9maW5pc2hlZFwiXSwgZmluaXNoZWQgPT4gZmluaXNoZWQpLFxuXG4gIC8qKlxuICAgKiBjb250cm9sbGVyLmlzU3RlcHBpbmdcbiAgICovXG4gIGlzU3RlcHBpbmc6IGNyZWF0ZUxlYWYoW1wiLi9zdGF0ZVwiXSwgc3RhdGUgPT4gc3RhdGUuaXNTdGVwcGluZylcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBjb250cm9sbGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9jb250cm9sbGVyL3NlbGVjdG9ycy9pbmRleC5qcyIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjpkYXRhOnNhZ2FzXCIpO1xuXG5pbXBvcnQgeyBwdXQsIHRha2VFdmVyeSwgc2VsZWN0LCBjYWxsIH0gZnJvbSBcInJlZHV4LXNhZ2EvZWZmZWN0c1wiO1xuXG5pbXBvcnQgeyBwcmVmaXhOYW1lLCBzdGFibGVLZWNjYWsyNTYsIG1ha2VBc3NpZ25tZW50IH0gZnJvbSBcImxpYi9oZWxwZXJzXCI7XG5cbmltcG9ydCB7IFRJQ0sgfSBmcm9tIFwibGliL3RyYWNlL2FjdGlvbnNcIjtcbmltcG9ydCAqIGFzIGFjdGlvbnMgZnJvbSBcIi4uL2FjdGlvbnNcIjtcbmltcG9ydCAqIGFzIHRyYWNlIGZyb20gXCJsaWIvdHJhY2Uvc2FnYXNcIjtcblxuaW1wb3J0IGRhdGEgZnJvbSBcIi4uL3NlbGVjdG9yc1wiO1xuXG5pbXBvcnQgc3VtIGZyb20gXCJsb2Rhc2guc3VtXCI7XG5cbmltcG9ydCAqIGFzIERlY29kZVV0aWxzIGZyb20gXCJ0cnVmZmxlLWRlY29kZS11dGlsc1wiO1xuaW1wb3J0IHtcbiAgZ2V0U3RvcmFnZUFsbG9jYXRpb25zLFxuICBnZXRNZW1vcnlBbGxvY2F0aW9ucyxcbiAgZ2V0Q2FsbGRhdGFBbGxvY2F0aW9ucyxcbiAgcmVhZFN0YWNrLFxuICBzdG9yYWdlU2l6ZVxufSBmcm9tIFwidHJ1ZmZsZS1kZWNvZGVyXCI7XG5pbXBvcnQgQk4gZnJvbSBcImJuLmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiogc2NvcGUobm9kZUlkLCBwb2ludGVyLCBwYXJlbnRJZCwgc291cmNlSWQpIHtcbiAgeWllbGQgcHV0KGFjdGlvbnMuc2NvcGUobm9kZUlkLCBwb2ludGVyLCBwYXJlbnRJZCwgc291cmNlSWQpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiBkZWNsYXJlKG5vZGUpIHtcbiAgeWllbGQgcHV0KGFjdGlvbnMuZGVjbGFyZShub2RlKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogZGVmaW5lVHlwZShub2RlKSB7XG4gIHlpZWxkIHB1dChhY3Rpb25zLmRlZmluZVR5cGUobm9kZSkpO1xufVxuXG5mdW5jdGlvbiogdGlja1NhZ2EoKSB7XG4gIGRlYnVnKFwiZ290IFRJQ0tcIik7XG5cbiAgeWllbGQqIHZhcmlhYmxlc0FuZE1hcHBpbmdzU2FnYSgpO1xuICB5aWVsZCogdHJhY2Uuc2lnbmFsVGlja1NhZ2FDb21wbGV0aW9uKCk7XG59XG5cbmZ1bmN0aW9uKiB2YXJpYWJsZXNBbmRNYXBwaW5nc1NhZ2EoKSB7XG4gIGxldCBub2RlID0geWllbGQgc2VsZWN0KGRhdGEuY3VycmVudC5ub2RlKTtcbiAgbGV0IGRlY29kZSA9IHlpZWxkIHNlbGVjdChkYXRhLnZpZXdzLmRlY29kZXIpO1xuICBsZXQgc2NvcGVzID0geWllbGQgc2VsZWN0KGRhdGEudmlld3Muc2NvcGVzLmlubGluZWQpO1xuICBsZXQgcmVmZXJlbmNlRGVjbGFyYXRpb25zID0geWllbGQgc2VsZWN0KGRhdGEudmlld3MucmVmZXJlbmNlRGVjbGFyYXRpb25zKTtcbiAgbGV0IGFsbG9jYXRpb25zID0geWllbGQgc2VsZWN0KGRhdGEuaW5mby5hbGxvY2F0aW9ucy5zdG9yYWdlKTtcbiAgbGV0IGN1cnJlbnRBc3NpZ25tZW50cyA9IHlpZWxkIHNlbGVjdChkYXRhLnByb2MuYXNzaWdubWVudHMpO1xuICBsZXQgbWFwcGVkUGF0aHMgPSB5aWVsZCBzZWxlY3QoZGF0YS5wcm9jLm1hcHBlZFBhdGhzKTtcbiAgbGV0IGN1cnJlbnREZXB0aCA9IHlpZWxkIHNlbGVjdChkYXRhLmN1cnJlbnQuZnVuY3Rpb25EZXB0aCk7XG4gIGxldCBhZGRyZXNzID0geWllbGQgc2VsZWN0KGRhdGEuY3VycmVudC5hZGRyZXNzKTtcbiAgLy9zdG9yYWdlIGFkZHJlc3MsIG5vdCBjb2RlIGFkZHJlc3NcblxuICBsZXQgc3RhY2sgPSB5aWVsZCBzZWxlY3QoZGF0YS5uZXh0LnN0YXRlLnN0YWNrKTsgLy9ub3RlIHRoZSB1c2Ugb2YgbmV4dCFcbiAgLy9pbiB0aGlzIHNhZ2Egd2UgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpyZXN1bHRzKiBvZiB0aGUgY3VycmVudCBpbnN0cnVjdGlvblxuICAvL25vdGUgdGhhdCB0aGUgZGVjb2RlciBpcyBzdGlsbCBiYXNlZCBvbiBkYXRhLmN1cnJlbnQuc3RhdGU7IHRoYXQncyBmaW5lXG4gIC8vdGhvdWdoLiAgVGhlcmUncyBhbHJlYWR5IGEgZGVsYXkgYmV0d2VlbiB3aGVuIHdlIHJlY29yZCB0aGluZ3Mgb2ZmIHRoZVxuICAvL3N0YWNrIGFuZCB3aGVuIHdlIGRlY29kZSB0aGVtLCBhZnRlciBhbGwuICBCYXNpY2FsbHksIG5vdGhpbmcgc2VyaW91c1xuICAvL3Nob3VsZCBoYXBwZW4gYWZ0ZXIgYW4gaW5kZXggbm9kZSBidXQgYmVmb3JlIHRoZSBpbmRleCBhY2Nlc3Mgbm9kZSB0aGF0XG4gIC8vd291bGQgY2F1c2Ugc3RvcmFnZSwgbWVtb3J5LCBvciBjYWxsZGF0YSB0byBjaGFuZ2UsIG1lYW5pbmcgdGhhdCBldmVuIGlmXG4gIC8vdGhlIGxpdGVyYWwgd2UgcmVjb3JkZWQgd2FzIGEgcG9pbnRlciwgaXQgd2lsbCBzdGlsbCBiZSB2YWxpZCBhdCB0aGUgdGltZVxuICAvL3dlIHVzZSBpdC4gIChUaGUgb3RoZXIgbGl0ZXJhbHMgd2UgbWFrZSB1c2Ugb2YsIGZvciB0aGUgYmFzZSBleHByZXNzaW9ucyxcbiAgLy9hcmUgbm90IGRlY29kZWQsIHNvIG5vIHBvdGVudGlhbCBtaXNtYXRjaCB0aGVyZSB3b3VsZCBiZSByZWxldmFudCBhbnl3YXkuKVxuXG4gIGxldCBhbHRlcm5hdGVTdGFjayA9IHlpZWxkIHNlbGVjdChkYXRhLm5leHRNYXBwZWQuc3RhdGUuc3RhY2spO1xuICAvL0hBQ0s6IHVuZm9ydHVuYXRlbHksIGluIHNvbWUgY2FzZXMsIGRhdGEubmV4dC5zdGF0ZS5zdGFjayBnZXRzIHRoZSB3cm9uZ1xuICAvL3Jlc3VsdHMgZHVlIHRvIHVubWFwcGVkIGluc3RydWN0aW9ucyBpbnRlcnZlbmluZy4gIFNvLCB3ZSBnZXQgdGhlIHN0YWNrIGF0XG4gIC8vdGhlIG5leHQgKm1hcHBlZCogc3RhY2sgaW5zdGVhZC4gIFRoaXMgaXMgc29tZXRoaW5nIG9mIGEgaGFjayBhbmQgd29uJ3RcbiAgLy93b3JrIGlmIHdlJ3JlIGFib3V0IHRvIGNoYW5nZSBjb250ZXh0LCBidXQgaXQgc2hvdWxkIHdvcmsgaW4gdGhlIGNhc2VzIHRoYXRcbiAgLy9uZWVkIGl0LlxuXG4gIGlmICghc3RhY2spIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgdG9wID0gc3RhY2subGVuZ3RoIC0gMTtcbiAgdmFyIGFzc2lnbm1lbnQsIGFzc2lnbm1lbnRzLCBwcmVhbWJsZUFzc2lnbm1lbnRzLCBiYXNlRXhwcmVzc2lvbiwgc2xvdCwgcGF0aDtcblxuICBpZiAoIW5vZGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBzdGFjayBpcyBvbmx5IHJlYWR5IGZvciBpbnRlcnByZXRhdGlvbiBhZnRlciB0aGUgbGFzdCBzdGVwIG9mIGVhY2hcbiAgLy8gc291cmNlIHJhbmdlXG4gIC8vXG4gIC8vIHRoZSBkYXRhIG1vZHVsZSBhbHdheXMgbG9va3MgYXQgdGhlIHJlc3VsdCBvZiBhIHBhcnRpY3VsYXIgb3Bjb2RlXG4gIC8vIChpLmUuLCB0aGUgZm9sbG93aW5nIHRyYWNlIHN0ZXAncyBzdGFjay9tZW1vcnkvc3RvcmFnZSksIHNvIHRoaXNcbiAgLy8gYXNzZXJ0cyB0aGF0IHRoZSBfY3VycmVudF8gb3BlcmF0aW9uIGlzIHRoZSBmaW5hbCBvbmUgYmVmb3JlXG4gIC8vIHByb2NlZWRpbmdcbiAgaWYgKCEoeWllbGQgc2VsZWN0KGRhdGEudmlld3MuYXRMYXN0SW5zdHJ1Y3Rpb25Gb3JTb3VyY2VSYW5nZSkpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy9IQUNLOiBtb2RpZmllciBwcmVhbWJsZVxuICAvL21vZGlmaWVyIGRlZmluaXRpb25zIGFyZSB0eXBpY2FsbHkgc2tpcHBlZCAodGhpcyBpbmNsdWRlcyBjb25zdHJ1Y3RvclxuICAvL2RlZmluaXRpb25zIHdoZW4gY2FsbGVkIGFzIGEgYmFzZSBjb25zdHJ1Y3Rvcik7IGFzIHN1Y2ggSSd2ZSBhZGRlZCB0aGlzXG4gIC8vXCJtb2RpZmllciBwcmVhbWJsZVwiIHRvIGNhdGNoIHRoZW1cbiAgaWYgKHlpZWxkIHNlbGVjdChkYXRhLmN1cnJlbnQuYWJvdXRUb01vZGlmeSkpIHtcbiAgICBsZXQgbW9kaWZpZXIgPSB5aWVsZCBzZWxlY3QoZGF0YS5jdXJyZW50Lm1vZGlmaWVyQmVpbmdJbnZva2VkKTtcbiAgICAvL21heSBiZSBlaXRoZXIgYSBtb2RpZmllciBvciBiYXNlIGNvbnN0cnVjdG9yXG4gICAgbGV0IGN1cnJlbnRJbmRleCA9IHlpZWxkIHNlbGVjdChkYXRhLmN1cnJlbnQubW9kaWZpZXJBcmd1bWVudEluZGV4KTtcbiAgICBkZWJ1ZyhcImN1cnJlbnRJbmRleCAlZFwiLCBjdXJyZW50SW5kZXgpO1xuICAgIGxldCBwYXJhbWV0ZXJzID0gbW9kaWZpZXIucGFyYW1ldGVycy5wYXJhbWV0ZXJzO1xuICAgIC8vbm93OiBsb29rIGF0IHRoZSBwYXJhbWV0ZXJzICphZnRlciogdGhlIGN1cnJlbnQgaW5kZXguICB3ZSdsbCBuZWVkIHRvXG4gICAgLy9hZGp1c3QgZm9yIHRob3NlLlxuICAgIGxldCBwYXJhbWV0ZXJzTGVmdCA9IHBhcmFtZXRlcnMuc2xpY2UoY3VycmVudEluZGV4ICsgMSk7XG4gICAgbGV0IGFkanVzdG1lbnQgPSBzdW0ocGFyYW1ldGVyc0xlZnQubWFwKERlY29kZVV0aWxzLkRlZmluaXRpb24uc3RhY2tTaXplKSk7XG4gICAgZGVidWcoXCJhZGp1c3RtZW50ICVkXCIsIGFkanVzdG1lbnQpO1xuICAgIHByZWFtYmxlQXNzaWdubWVudHMgPSBhc3NpZ25QYXJhbWV0ZXJzKFxuICAgICAgcGFyYW1ldGVycyxcbiAgICAgIHRvcCArIGFkanVzdG1lbnQsXG4gICAgICBjdXJyZW50RGVwdGhcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHByZWFtYmxlQXNzaWdubWVudHMgPSB7fTtcbiAgfVxuXG4gIHN3aXRjaCAobm9kZS5ub2RlVHlwZSkge1xuICAgIGNhc2UgXCJGdW5jdGlvbkRlZmluaXRpb25cIjpcbiAgICBjYXNlIFwiTW9kaWZpZXJEZWZpbml0aW9uXCI6XG4gICAgICAvL05PVEU6IHRoaXMgd2lsbCAqbm90KiBjYXRjaCBtb3N0IG1vZGlmaWVyIGRlZmluaXRpb25zIVxuICAgICAgLy90aGUgcmVzdCBob3BlZnVsbHkgd2lsbCBiZSBjYXVnaHQgYnkgdGhlIG1vZGlmaWVyIHByZWFtYmxlXG4gICAgICAvLyhpbiBmYWN0IHRoZXkgd29uJ3QgYWxsIGJlLCBidXQuLi4pXG5cbiAgICAgIC8vSEFDSzogZmlsdGVyIG91dCBzb21lIGdhcmJhZ2VcbiAgICAgIC8vdGhpcyBmaWx0ZXJzIG91dCB0aGUgY2FzZSB3aGVyZSB3ZSdyZSByZWFsbHkgaW4gYW4gaW52b2NhdGlvbiBvZiBhXG4gICAgICAvL21vZGlmaWVyIG9yIGJhc2UgY29uc3RydWN0b3IsIGJ1dCBoYXZlIHRlbXBvcmFyaWx5IGhpdCB0aGUgZGVmaW5pdGlvblxuICAgICAgLy9ub2RlIGZvciBzb21lIHJlYXNvbi4gIEhvd2V2ZXIgdGhpcyBvYnZpb3VzbHkgY2FuIGhhdmUgYSBmYWxzZSBwb3NpdGl2ZVxuICAgICAgLy9pbiB0aGUgY2FzZSB3aGVyZSBhIGZ1bmN0aW9uIGhhcyB0aGUgc2FtZSBtb2RpZmllciB0d2ljZS5cbiAgICAgIGxldCBuZXh0TW9kaWZpZXIgPSB5aWVsZCBzZWxlY3QoZGF0YS5uZXh0Lm1vZGlmaWVyQmVpbmdJbnZva2VkKTtcbiAgICAgIGlmIChuZXh0TW9kaWZpZXIgJiYgbmV4dE1vZGlmaWVyLmlkID09PSBub2RlLmlkKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBsZXQgcGFyYW1ldGVycyA9IG5vZGUucGFyYW1ldGVycy5wYXJhbWV0ZXJzO1xuICAgICAgLy9ub3RlIHRoYXQgd2UgZG8gKm5vdCogaW5jbHVkZSByZXR1cm4gcGFyYW1ldGVycywgc2luY2UgdGhvc2UgYXJlXG4gICAgICAvL2hhbmRsZWQgYnkgdGhlIFZhcmlhYmxlRGVjbGFyYXRpb24gY2FzZSAobm8sIEkgZG9uJ3Qga25vdyB3aHkgaXRcbiAgICAgIC8vd29ya3Mgb3V0IHRoYXQgd2F5KVxuXG4gICAgICAvL3dlIGNhbiBza2lwIHByZWFtYmxlQXNzaWdubWVudHMgaGVyZSwgdGhhdCBpc24ndCB1c2VkIGluIHRoaXMgY2FzZVxuICAgICAgYXNzaWdubWVudHMgPSBhc3NpZ25QYXJhbWV0ZXJzKHBhcmFtZXRlcnMsIHRvcCwgY3VycmVudERlcHRoKTtcblxuICAgICAgZGVidWcoXCJGdW5jdGlvbiBkZWZpbml0aW9uIGNhc2VcIik7XG4gICAgICBkZWJ1ZyhcImFzc2lnbm1lbnRzICVPXCIsIGFzc2lnbm1lbnRzKTtcblxuICAgICAgeWllbGQgcHV0KGFjdGlvbnMuYXNzaWduKGFzc2lnbm1lbnRzKSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJDb250cmFjdERlZmluaXRpb25cIjpcbiAgICAgIGxldCBhbGxvY2F0aW9uID0gYWxsb2NhdGlvbnNbbm9kZS5pZF07XG5cbiAgICAgIGRlYnVnKFwiQ29udHJhY3QgZGVmaW5pdGlvbiBjYXNlXCIpO1xuICAgICAgZGVidWcoXCJhbGxvY2F0aW9ucyAlT1wiLCBhbGxvY2F0aW9ucyk7XG4gICAgICBkZWJ1ZyhcImFsbG9jYXRpb24gJU9cIiwgYWxsb2NhdGlvbik7XG4gICAgICBhc3NpZ25tZW50cyA9IHt9O1xuICAgICAgZm9yIChsZXQgaWQgaW4gYWxsb2NhdGlvbi5tZW1iZXJzKSB7XG4gICAgICAgIGlkID0gTnVtYmVyKGlkKTsgLy9ub3Qgc3VyZSB3aHkgd2UncmUgZ2V0dGluZyB0aGVtIGFzIHN0cmluZ3MsIGJ1dC4uLlxuICAgICAgICBsZXQgaWRPYmogPSB7IGFzdElkOiBpZCwgYWRkcmVzcyB9O1xuICAgICAgICBsZXQgZnVsbElkID0gc3RhYmxlS2VjY2FrMjU2KGlkT2JqKTtcbiAgICAgICAgLy93ZSBkb24ndCB1c2UgbWFrZUFzc2lnbm1lbnQgaGVyZSBhcyB3ZSBoYWQgdG8gY29tcHV0ZSB0aGUgSUQgYW55d2F5XG4gICAgICAgIGFzc2lnbm1lbnQgPSB7XG4gICAgICAgICAgLi4uaWRPYmosXG4gICAgICAgICAgaWQ6IGZ1bGxJZCxcbiAgICAgICAgICByZWY6IHtcbiAgICAgICAgICAgIC4uLigoY3VycmVudEFzc2lnbm1lbnRzLmJ5SWRbZnVsbElkXSB8fCB7fSkucmVmIHx8IHt9KSxcbiAgICAgICAgICAgIC4uLmFsbG9jYXRpb24ubWVtYmVyc1tpZF0ucG9pbnRlclxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgYXNzaWdubWVudHNbZnVsbElkXSA9IGFzc2lnbm1lbnQ7XG4gICAgICB9XG4gICAgICBkZWJ1ZyhcImFzc2lnbm1lbnRzICVPXCIsIGFzc2lnbm1lbnRzKTtcblxuICAgICAgLy90aGlzIGNhc2UgZG9lc24ndCBuZWVkIHByZWFtYmxlQXNzaWdubWVudHMgZWl0aGVyXG4gICAgICB5aWVsZCBwdXQoYWN0aW9ucy5hc3NpZ24oYXNzaWdubWVudHMpKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIjpcbiAgICAgIGxldCB2YXJJZCA9IG5vZGUuaWQ7XG4gICAgICBkZWJ1ZyhcIlZhcmlhYmxlIGRlY2xhcmF0aW9uIGNhc2VcIik7XG4gICAgICBkZWJ1ZyhcImN1cnJlbnREZXB0aCAlZCB2YXJJZCAlZFwiLCBjdXJyZW50RGVwdGgsIHZhcklkKTtcblxuICAgICAgLy9OT1RFOiBXZSdyZSBnb2luZyB0byBtYWtlIHRoZSBhc3NpZ25tZW50IGNvbmRpdGlvbmFsIGhlcmU7IGhlcmUncyB3aHkuXG4gICAgICAvL1RoZXJlJ3MgYSBidWcgd2hlcmUgY2FsbGluZyB0aGUgYXV0b2dlbmVyYXRlZCBhY2Nlc3NvciBmb3IgYSBwdWJsaWNcbiAgICAgIC8vY29udHJhY3QgdmFyaWFibGUgY2F1c2VzIHRoZSBkZWJ1Z2dlciB0byBzZWUgdHdvIGFkZGl0aW9uYWxcbiAgICAgIC8vZGVjbGFyYXRpb25zIGZvciB0aGF0IHZhcmlhYmxlLi4uIHdoaWNoIHRoaXMgY29kZSByZWFkcyBhcyBsb2NhbFxuICAgICAgLy92YXJpYWJsZSBkZWNsYXJhdGlvbnMuICBSYXRoZXIgdGhhbiBwcmV2ZW50IHRoaXMgYXQgdGhlIHNvdXJjZSwgd2UncmVcbiAgICAgIC8vanVzdCBnb2luZyB0byBjaGVjayBmb3IgaXQgaGVyZSwgYnkgbm90IGFkZGluZyBhIGxvY2FsIHZhcmlhYmxlIGlmIHNhaWRcbiAgICAgIC8vdmFyaWFibGUgaXMgYWxyZWFkeSBhIGNvbnRyYWN0IHZhcmlhYmxlLlxuXG4gICAgICBpZiAoXG4gICAgICAgIGN1cnJlbnRBc3NpZ25tZW50cy5ieUFzdElkW3ZhcklkXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIGN1cnJlbnRBc3NpZ25tZW50cy5ieUFzdElkW3ZhcklkXS5zb21lKFxuICAgICAgICAgIGlkID0+IGN1cnJlbnRBc3NpZ25tZW50cy5ieUlkW2lkXS5hZGRyZXNzICE9PSB1bmRlZmluZWRcbiAgICAgICAgKVxuICAgICAgKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvL290aGVyd2lzZSwgZ28gYWhlYWQgYW5kIG1ha2UgdGhlIGFzc2lnbm1lbnRcbiAgICAgIGFzc2lnbm1lbnQgPSBtYWtlQXNzaWdubWVudChcbiAgICAgICAgeyBhc3RJZDogdmFySWQsIHN0YWNrZnJhbWU6IGN1cnJlbnREZXB0aCB9LFxuICAgICAgICB7XG4gICAgICAgICAgc3RhY2s6IHtcbiAgICAgICAgICAgIGZyb206IHRvcCAtIERlY29kZVV0aWxzLkRlZmluaXRpb24uc3RhY2tTaXplKG5vZGUpICsgMSxcbiAgICAgICAgICAgIHRvOiB0b3BcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBhc3NpZ25tZW50cyA9IHsgW2Fzc2lnbm1lbnQuaWRdOiBhc3NpZ25tZW50IH07XG4gICAgICAvL3RoaXMgY2FzZSBkb2Vzbid0IG5lZWQgcHJlYW1ibGVBc3NpZ25tZW50cyBlaXRoZXJcbiAgICAgIHlpZWxkIHB1dChhY3Rpb25zLmFzc2lnbihhc3NpZ25tZW50cykpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwiSW5kZXhBY2Nlc3NcIjpcbiAgICAgIC8vIHRvIHRyYWNrIGBtYXBwaW5nYCB0eXBlcyBrbm93biBpbmRpY2VzXG4gICAgICAvLyAoYW5kIGFsc28gKnNvbWUqIGtub3duIGluZGljZXMgZm9yIGFycmF5cylcblxuICAgICAgLy9IQUNLOiB3ZSB1c2UgdGhlIGFsdGVybmF0ZSBzdGFjayBpbiB0aGlzIGNhc2VcblxuICAgICAgZGVidWcoXCJJbmRleCBhY2Nlc3MgY2FzZVwiKTtcblxuICAgICAgLy93ZSdyZSBnb2luZyB0byBzdGFydCBieSBkb2luZyB0aGUgc2FtZSB0aGluZyBhcyBpbiB0aGUgZGVmYXVsdCBjYXNlXG4gICAgICAvLyhzZWUgYmVsb3cpIC0tIGdldHRpbmcgdGhpbmdzIHJlYWR5IGZvciBhbiBhc3NpZ25tZW50LiAgVGhlbiB3ZSdyZVxuICAgICAgLy9nb2luZyB0byBmb3JnZXQgdGhpcyBmb3IgYSBiaXQgd2hpbGUgd2UgaGFuZGxlIHRoZSByZXN0Li4uXG4gICAgICBhc3NpZ25tZW50cyA9IHtcbiAgICAgICAgLi4ucHJlYW1ibGVBc3NpZ25tZW50cyxcbiAgICAgICAgLi4ubGl0ZXJhbEFzc2lnbm1lbnRzKG5vZGUsIGFsdGVybmF0ZVN0YWNrLCBjdXJyZW50RGVwdGgpXG4gICAgICB9O1xuXG4gICAgICAvL3dlJ2xsIG5lZWQgdGhpc1xuICAgICAgYmFzZUV4cHJlc3Npb24gPSBub2RlLmJhc2VFeHByZXNzaW9uO1xuXG4gICAgICAvL2J1dCBmaXJzdCwgYSBkaXZlcnNpb24gLS0gaXMgdGhpcyBzb21ldGhpbmcgdGhhdCBjb3VsZCBub3QgKnBvc3NpYmx5KlxuICAgICAgLy9sZWFkIHRvIGEgbWFwcGluZz8gIGkuZS4sIGVpdGhlciBhIGJ5dGVzLCBvciBhbiBhcnJheSBvZiBub24tcmVmZXJlbmNlXG4gICAgICAvL3R5cGVzLCBvciBhIG5vbi1zdG9yYWdlIGFycmF5P1xuICAgICAgLy9pZiBzbywgd2UnbGwganVzdCBkbyB0aGUgYXNzaWduIGFuZCBxdWl0IG91dCBlYXJseVxuICAgICAgLy8obm90ZTogd2Ugd3JpdGUgaXQgdGhpcyB3YXkgYmVjYXVzZSBtYXBwaW5ncyBhcmVuJ3QgY2F1Z2h0IGJ5XG4gICAgICAvL2lzUmVmZXJlbmNlKVxuICAgICAgaWYgKFxuICAgICAgICBEZWNvZGVVdGlscy5EZWZpbml0aW9uLnR5cGVDbGFzcyhiYXNlRXhwcmVzc2lvbikgPT09IFwiYnl0ZXNcIiB8fFxuICAgICAgICAoRGVjb2RlVXRpbHMuRGVmaW5pdGlvbi50eXBlQ2xhc3MoYmFzZUV4cHJlc3Npb24pID09PSBcImFycmF5XCIgJiZcbiAgICAgICAgICAoRGVjb2RlVXRpbHMuRGVmaW5pdGlvbi5pc1JlZmVyZW5jZShub2RlKVxuICAgICAgICAgICAgPyBEZWNvZGVVdGlscy5EZWZpbml0aW9uLnJlZmVyZW5jZVR5cGUoYmFzZUV4cHJlc3Npb24pICE9PSBcInN0b3JhZ2VcIlxuICAgICAgICAgICAgOiAhRGVjb2RlVXRpbHMuRGVmaW5pdGlvbi5pc01hcHBpbmcobm9kZSkpKVxuICAgICAgKSB7XG4gICAgICAgIGRlYnVnKFwiSW5kZXggY2FzZSBiYWlsZWQgb3V0IGVhcmx5XCIpO1xuICAgICAgICBkZWJ1ZyhcInR5cGVDbGFzcyAlc1wiLCBEZWNvZGVVdGlscy5EZWZpbml0aW9uLnR5cGVDbGFzcyhiYXNlRXhwcmVzc2lvbikpO1xuICAgICAgICBkZWJ1ZyhcbiAgICAgICAgICBcInJlZmVyZW5jZVR5cGUgJXNcIixcbiAgICAgICAgICBEZWNvZGVVdGlscy5EZWZpbml0aW9uLnJlZmVyZW5jZVR5cGUoYmFzZUV4cHJlc3Npb24pXG4gICAgICAgICk7XG4gICAgICAgIGRlYnVnKFwiaXNSZWZlcmVuY2Uobm9kZSkgJW9cIiwgRGVjb2RlVXRpbHMuRGVmaW5pdGlvbi5pc1JlZmVyZW5jZShub2RlKSk7XG4gICAgICAgIHlpZWxkIHB1dChhY3Rpb25zLmFzc2lnbihhc3NpZ25tZW50cykpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgbGV0IGtleURlZmluaXRpb24gPSBEZWNvZGVVdGlscy5EZWZpbml0aW9uLmtleURlZmluaXRpb24oXG4gICAgICAgIGJhc2VFeHByZXNzaW9uLFxuICAgICAgICBzY29wZXNcbiAgICAgICk7XG4gICAgICAvL2lmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhbiBhcnJheSwgdGhpcyB3aWxsIGp1c3QgaGFjayB1cCBhIHVpbnQgZGVmaW5pdGlvblxuICAgICAgLy86KVxuXG4gICAgICAvL2JlZ2luIHN1YnNlY3Rpb246IGtleSBkZWNvZGluZ1xuICAgICAgLy8oSSB0cmllZCBmYWN0b3JpbmcgdGhpcyBvdXQgaW50byBpdHMgb3duIHNhZ2EgYnV0IGl0IGRpZG4ndCB3b3JrIHdoZW4gSVxuICAgICAgLy9kaWQgOlAgKVxuICAgICAgeWllbGQgcHV0KGFjdGlvbnMubWFwS2V5RGVjb2RpbmcodHJ1ZSkpO1xuXG4gICAgICBsZXQgaW5kZXhWYWx1ZTtcbiAgICAgIGxldCBpbmRleERlZmluaXRpb24gPSBub2RlLmluZGV4RXhwcmVzc2lvbjtcblxuICAgICAgLy93aHkgdGhlIGxvb3A/IHNlZSB0aGUgZW5kIG9mIHRoZSBibG9jayBpdCBoZWFkcyBmb3IgYW4gZXhwbGFuYXRvcnlcbiAgICAgIC8vY29tbWVudFxuICAgICAgd2hpbGUgKGluZGV4VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgaW5kZXhJZCA9IGluZGV4RGVmaW5pdGlvbi5pZDtcbiAgICAgICAgLy9pbmRpY2VzIG5lZWQgdG8gYmUgaWRlbnRpZmllZCBieSBzdGFja2ZyYW1lXG4gICAgICAgIGxldCBpbmRleElkT2JqID0geyBhc3RJZDogaW5kZXhJZCwgc3RhY2tmcmFtZTogY3VycmVudERlcHRoIH07XG4gICAgICAgIGxldCBmdWxsSW5kZXhJZCA9IHN0YWJsZUtlY2NhazI1NihpbmRleElkT2JqKTtcblxuICAgICAgICBjb25zdCBpbmRleFJlZmVyZW5jZSA9IChjdXJyZW50QXNzaWdubWVudHMuYnlJZFtmdWxsSW5kZXhJZF0gfHwge30pLnJlZjtcblxuICAgICAgICBpZiAoRGVjb2RlVXRpbHMuRGVmaW5pdGlvbi5pc1NpbXBsZUNvbnN0YW50KGluZGV4RGVmaW5pdGlvbikpIHtcbiAgICAgICAgICAvL3doaWxlIHRoZSBtYWluIGNhc2UgaXMgdGhlIG5leHQgb25lLCB3aGVyZSB3ZSBsb29rIGZvciBhIHByaW9yXG4gICAgICAgICAgLy9hc3NpZ25tZW50LCB3ZSBuZWVkIHRoaXMgY2FzZSAoYW5kIG5lZWQgaXQgZmlyc3QpIGZvciB0d28gcmVhc29uczpcbiAgICAgICAgICAvLzEuIHNvbWUgY29uc3RhbnQgZXhwcmVzc2lvbnMgKHNwZWNpZmljYWxseSwgc3RyaW5nIGFuZCBoZXggbGl0ZXJhbHMpXG4gICAgICAgICAgLy9hcmVuJ3Qgc291cmNlbWFwcGVkIHRvIGFuZCBzbyB3b24ndCBoYXZlIGEgcHJpb3IgYXNzaWdubWVudFxuICAgICAgICAgIC8vMi4gaWYgdGhlIGtleSB0eXBlIGlzIGJ5dGVzTiBidXQgdGhlIGV4cHJlc3Npb24gaXMgY29uc3RhbnQsIHRoZVxuICAgICAgICAgIC8vdmFsdWUgd2lsbCBnbyBvbiB0aGUgc3RhY2sgKmxlZnQqLXBhZGRlZCBpbnN0ZWFkIG9mIHJpZ2h0LXBhZGRlZCxcbiAgICAgICAgICAvL3NvIGxvb2tpbmcgZm9yIGEgcHJpb3IgYXNzaWdubWVudCB3aWxsIHJlYWQgdGhlIHdyb25nIHZhbHVlLlxuICAgICAgICAgIC8vc28gaW5zdGVhZCBpdCdzIHByZWZlcmFibGUgdG8gdXNlIHRoZSBjb25zdGFudCBkaXJlY3RseS5cbiAgICAgICAgICBpbmRleFZhbHVlID0geWllbGQgY2FsbChkZWNvZGUsIGtleURlZmluaXRpb24sIHtcbiAgICAgICAgICAgIGRlZmluaXRpb246IGluZGV4RGVmaW5pdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGluZGV4UmVmZXJlbmNlKSB7XG4gICAgICAgICAgLy9pZiBhIHByaW9yIGFzc2lnbm1lbnQgaXMgZm91bmRcbiAgICAgICAgICBsZXQgc3BsaWNlZERlZmluaXRpb247XG4gICAgICAgICAgLy9pbiBnZW5lcmFsLCB3ZSB3YW50IHRvIGRlY29kZSB1c2luZyB0aGUga2V5IGRlZmluaXRpb24sIG5vdCB0aGUgaW5kZXhcbiAgICAgICAgICAvL2RlZmluaXRpb24uIGhvd2V2ZXIsIHRoZSBrZXkgZGVmaW5pdGlvbiBtYXkgaGF2ZSB0aGUgd3JvbmcgbG9jYXRpb25cbiAgICAgICAgICAvL29uIGl0LiAgc28sIHdoZW4gYXBwbGljYWJsZSwgd2Ugc3BsaWNlIHRoZSBpbmRleCBkZWZpbml0aW9uIGxvY2F0aW9uXG4gICAgICAgICAgLy9vbnRvIHRoZSBrZXkgZGVmaW5pdGlvbiBsb2NhdGlvbi5cbiAgICAgICAgICBpZiAoRGVjb2RlVXRpbHMuRGVmaW5pdGlvbi5pc1JlZmVyZW5jZShpbmRleERlZmluaXRpb24pKSB7XG4gICAgICAgICAgICBzcGxpY2VkRGVmaW5pdGlvbiA9IERlY29kZVV0aWxzLkRlZmluaXRpb24uc3BsaWNlTG9jYXRpb24oXG4gICAgICAgICAgICAgIGtleURlZmluaXRpb24sXG4gICAgICAgICAgICAgIERlY29kZVV0aWxzLkRlZmluaXRpb24ucmVmZXJlbmNlVHlwZShpbmRleERlZmluaXRpb24pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgLy93ZSBjb3VsZCBwdXQgY29kZSBoZXJlIHRvIGFkZCBvbiB0aGUgXCJfcHRyXCIgZW5kaW5nIHdoZW4gYWJzZW50LFxuICAgICAgICAgICAgLy9idXQgd2UgcHJlc2VudGx5IGlnbm9yZSB0aGF0IGVuZGluZywgc28gd2UnbGwgc2tpcCB0aGF0XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNwbGljZWREZWZpbml0aW9uID0ga2V5RGVmaW5pdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5kZXhWYWx1ZSA9IHlpZWxkIGNhbGwoZGVjb2RlLCBzcGxpY2VkRGVmaW5pdGlvbiwgaW5kZXhSZWZlcmVuY2UpO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIGluZGV4RGVmaW5pdGlvbi5yZWZlcmVuY2VkRGVjbGFyYXRpb24gJiZcbiAgICAgICAgICBzY29wZXNbaW5kZXhEZWZpbml0aW9uLnJlZmVyZW5jZURlY2xhcmF0aW9uXVxuICAgICAgICApIHtcbiAgICAgICAgICAvL3RoZXJlJ3Mgb25lIG1vcmUgcmVhc29uIHdlIG1pZ2h0IGhhdmUgZmFpbGVkIHRvIGRlY29kZSBpdDogaXQgbWlnaHQgYmUgYVxuICAgICAgICAgIC8vY29uc3RhbnQgc3RhdGUgdmFyaWFibGUuICBVbmZvcnR1bmF0ZWx5LCB3ZSBkb24ndCBrbm93IGhvdyB0byBkZWNvZGUgYWxsXG4gICAgICAgICAgLy90aG9zZSBhdCB0aGUgbW9tZW50LCBidXQgd2UgY2FuIGhhbmRsZSB0aGUgb25lcyB3ZSBkbyBrbm93IGhvdyB0byBkZWNvZGUuXG4gICAgICAgICAgLy9JbiB0aGUgZnV0dXJlIGhvcGVmdWxseSB3ZSB3aWxsIGRlY29kZSBhbGwgb2YgdGhlbVxuICAgICAgICAgIGRlYnVnKFxuICAgICAgICAgICAgXCJyZWZlcmVuY2VkRGVjbGFyYXRpb24gJWRcIixcbiAgICAgICAgICAgIGluZGV4RGVmaW5pdGlvbi5yZWZlcmVuY2VkRGVjbGFyYXRpb25cbiAgICAgICAgICApO1xuICAgICAgICAgIGxldCBpbmRleENvbnN0YW50RGVjbGFyYXRpb24gPVxuICAgICAgICAgICAgc2NvcGVzW2luZGV4RGVmaW5pdGlvbi5yZWZlcmVuY2VkRGVjbGFyYXRpb25dLmRlZmluaXRpb247XG4gICAgICAgICAgZGVidWcoXCJpbmRleENvbnN0YW50RGVjbGFyYXRpb24gJU9cIiwgaW5kZXhDb25zdGFudERlY2xhcmF0aW9uKTtcbiAgICAgICAgICBpZiAoaW5kZXhDb25zdGFudERlY2xhcmF0aW9uLmNvbnN0YW50KSB7XG4gICAgICAgICAgICBsZXQgaW5kZXhDb25zdGFudERlZmluaXRpb24gPSBpbmRleENvbnN0YW50RGVjbGFyYXRpb24udmFsdWU7XG4gICAgICAgICAgICAvL25leHQgbGluZSBmaWx0ZXJzIG91dCBjb25zdGFudHMgd2UgZG9uJ3Qga25vdyBob3cgdG8gaGFuZGxlXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIERlY29kZVV0aWxzLkRlZmluaXRpb24uaXNTaW1wbGVDb25zdGFudChpbmRleENvbnN0YW50RGVmaW5pdGlvbilcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBpbmRleFZhbHVlID0geWllbGQgY2FsbChkZWNvZGUsIGtleURlZmluaXRpb24sIHtcbiAgICAgICAgICAgICAgICBkZWZpbml0aW9uOiBpbmRleENvbnN0YW50RGVjbGFyYXRpb24udmFsdWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vdGhlcmUncyBzdGlsbCBvbmUgbW9yZSByZWFzb24gd2UgbWlnaHQgaGF2ZSBmYWlsZWQgdG8gZGVjb2RlIGl0OlxuICAgICAgICAvL2NlcnRhaW4gKHNpbGVudCkgdHlwZSBjb252ZXJzaW9ucyBhcmVuJ3Qgc291cmNlbWFwcGVkIGVpdGhlci5cbiAgICAgICAgLy8odGhhbmtmdWxseSwgYW55IHR5cGUgY29udmVyc2lvbiB0aGF0IGFjdHVhbGx5ICpkb2VzKiBzb21ldGhpbmcgc2VlbXNcbiAgICAgICAgLy90byBiZSBzb3VyY2VtYXBwZWQuKSAgU28gaWYgd2UndmUgZmFpbGVkIHRvIGRlY29kZSBpdCwgd2UgdHJ5IGFnYWluXG4gICAgICAgIC8vd2l0aCB0aGUgYXJndW1lbnQgb2YgdGhlIHR5cGUgY29udmVyc2lvbiwgaWYgaXQgaXMgb25lOyB3ZSBsZWF2ZVxuICAgICAgICAvL2luZGV4VmFsdWUgdW5kZWZpbmVkIHNvIHRoZSBsb29wIHdpbGwgY29udGludWVcbiAgICAgICAgLy8obm90ZSB0aGF0IHRoaXMgY2FzZSBpcyBsYXN0IGZvciBhIHJlYXNvbjsgaWYgdGhpcyB3ZXJlIGVhcmxpZXIsIGl0XG4gICAgICAgIC8vd291bGQgY2F0Y2ggKm5vbiotc2lsZW50IHR5cGUgY29udmVyc2lvbnMsIHdoaWNoIHdlIHdhbnQgdG8ganVzdCByZWFkXG4gICAgICAgIC8vb2ZmIHRoZSBzdGFjaylcbiAgICAgICAgZWxzZSBpZiAoaW5kZXhEZWZpbml0aW9uLmtpbmQgPT09IFwidHlwZUNvbnZlcnNpb25cIikge1xuICAgICAgICAgIGluZGV4RGVmaW5pdGlvbiA9IGluZGV4RGVmaW5pdGlvbi5hcmd1bWVudHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgLy9vdGhlcndpc2UsIHdlJ3ZlIGp1c3QgdG90YWxseSBmYWlsZWQgdG8gZGVjb2RlIGl0LCBzbyB3ZSBtYXJrXG4gICAgICAgIC8vaW5kZXhWYWx1ZSBhcyBudWxsIChhcyBkaXN0aW5jdCBmcm9tIHVuZGVmaW5lZCkgdG8gaW5kaWNhdGUgdGhpcy4gIEluXG4gICAgICAgIC8vdGhlIGZ1dHVyZSwgd2Ugc2hvdWxkIGJlIGFibGUgdG8gZGVjb2RlIGFsbCBtYXBwaW5nIGtleXMsIGJ1dCB3ZSdyZVxuICAgICAgICAvL25vdCBxdWl0ZSB0aGVyZSB5ZXQsIHNvcnJ5IChiZWNhdXNlIHdlIGNhbid0IHlldCBoYW5kbGUgYWxsIGNvbnN0YW50XG4gICAgICAgIC8vc3RhdGUgdmFyaWFibGVzKVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpbmRleFZhbHVlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvL25vdywgYXMgbWVudGlvbmVkLCByZXRyeSBpbiB0aGUgdHlwZUNvbnZlcnNpb24gY2FzZVxuICAgICAgfVxuXG4gICAgICB5aWVsZCBwdXQoYWN0aW9ucy5tYXBLZXlEZWNvZGluZyhmYWxzZSkpO1xuICAgICAgLy9lbmQgc3Vic2VjdGlvbjoga2V5IGRlY29kaW5nXG5cbiAgICAgIGRlYnVnKFwiaW5kZXggdmFsdWUgJU9cIiwgaW5kZXhWYWx1ZSk7XG4gICAgICBkZWJ1ZyhcImtleURlZmluaXRpb24gJW9cIiwga2V5RGVmaW5pdGlvbik7XG5cbiAgICAgIC8vd2hldyEgQnV0IHdlJ3JlIG5vdCBkb25lIHlldCAtLSB3ZSBuZWVkIHRvIHR1cm4gdGhpcyBkZWNvZGVkIGtleSBpbnRvXG4gICAgICAvL2FuIGFjdHVhbCBwYXRoIChhc3N1bWluZyB3ZSAqZGlkKiBkZWNvZGUgaXQpXG4gICAgICAvL09LLCBub3QgYW4gYWN0dWFsIHBhdGggLS0gd2UncmUganVzdCBnb2luZyB0byB1c2UgYSBzaW1wbGUgb2Zmc2V0IGZvclxuICAgICAgLy90aGUgcGF0aC4gIEJ1dCB0aGF0J3MgT0ssIGJlY2F1c2UgdGhlIG1hcHBlZFBhdGhzIHJlZHVjZXIgd2lsbCB0dXJuXG4gICAgICAvL2l0IGludG8gYW4gYWN0dWFsIHBhdGguXG4gICAgICBpZiAoaW5kZXhWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICBwYXRoID0gZmV0Y2hCYXNlUGF0aChcbiAgICAgICAgICBiYXNlRXhwcmVzc2lvbixcbiAgICAgICAgICBtYXBwZWRQYXRocyxcbiAgICAgICAgICBjdXJyZW50QXNzaWdubWVudHMsXG4gICAgICAgICAgY3VycmVudERlcHRoXG4gICAgICAgICk7XG5cbiAgICAgICAgbGV0IHNsb3QgPSB7IHBhdGggfTtcblxuICAgICAgICAvL3dlIG5lZWQgdG8gZG8gdGhpbmdzIGRpZmZlcmVudGx5IGRlcGVuZGluZyBvbiB3aGV0aGVyIHdlJ3JlIGRlYWxpbmdcbiAgICAgICAgLy93aXRoIGFuIGFycmF5IG9yIG1hcHBpbmdcbiAgICAgICAgc3dpdGNoIChEZWNvZGVVdGlscy5EZWZpbml0aW9uLnR5cGVDbGFzcyhiYXNlRXhwcmVzc2lvbikpIHtcbiAgICAgICAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgICAgICAgIHNsb3QuaGFzaFBhdGggPSBEZWNvZGVVdGlscy5EZWZpbml0aW9uLmlzRHluYW1pY0FycmF5KFxuICAgICAgICAgICAgICBiYXNlRXhwcmVzc2lvblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHNsb3Qub2Zmc2V0ID0gaW5kZXhWYWx1ZS5tdWxuKFxuICAgICAgICAgICAgICBzdG9yYWdlU2l6ZShub2RlLCByZWZlcmVuY2VEZWNsYXJhdGlvbnMsIGFsbG9jYXRpb25zKS53b3Jkc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJtYXBwaW5nXCI6XG4gICAgICAgICAgICBzbG90LmtleSA9IGluZGV4VmFsdWU7XG4gICAgICAgICAgICBzbG90LmtleUVuY29kaW5nID0gRGVjb2RlVXRpbHMuRGVmaW5pdGlvbi5rZXlFbmNvZGluZyhcbiAgICAgICAgICAgICAga2V5RGVmaW5pdGlvblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHNsb3Qub2Zmc2V0ID0gbmV3IEJOKDApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGRlYnVnKFwidW5yZWNvZ25pemVkIGluZGV4IGFjY2VzcyFcIik7XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcoXCJzbG90ICVPXCIsIHNsb3QpO1xuXG4gICAgICAgIC8vbm93LCBtYXAgaXQhIChhbmQgZG8gdGhlIGFzc2lnbiBhcyB3ZWxsKVxuICAgICAgICB5aWVsZCBwdXQoXG4gICAgICAgICAgYWN0aW9ucy5tYXBQYXRoQW5kQXNzaWduKFxuICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgIHNsb3QsXG4gICAgICAgICAgICBhc3NpZ25tZW50cyxcbiAgICAgICAgICAgIERlY29kZVV0aWxzLkRlZmluaXRpb24udHlwZUlkZW50aWZpZXIobm9kZSksXG4gICAgICAgICAgICBEZWNvZGVVdGlscy5EZWZpbml0aW9uLnR5cGVJZGVudGlmaWVyKGJhc2VFeHByZXNzaW9uKVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vaWYgd2UgZmFpbGVkIHRvIGRlY29kZSwganVzdCBkbyB0aGUgYXNzaWduIGZyb20gYWJvdmVcbiAgICAgICAgZGVidWcoXCJmYWlsZWQgdG8gZGVjb2RlLCBqdXN0IGFzc2lnbmluZ1wiKTtcbiAgICAgICAgeWllbGQgcHV0KGFjdGlvbnMuYXNzaWduKGFzc2lnbm1lbnRzKSk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcIk1lbWJlckFjY2Vzc1wiOlxuICAgICAgLy9IQUNLOiB3ZSB1c2UgdGhlIGFsdGVybmF0ZSBzdGFjayBpbiB0aGlzIGNhc2VcblxuICAgICAgLy93ZSdyZSBnb2luZyB0byBzdGFydCBieSBkb2luZyB0aGUgc2FtZSB0aGluZyBhcyBpbiB0aGUgZGVmYXVsdCBjYXNlXG4gICAgICAvLyhzZWUgYmVsb3cpIC0tIGdldHRpbmcgdGhpbmdzIHJlYWR5IGZvciBhbiBhc3NpZ25tZW50LiAgVGhlbiB3ZSdyZVxuICAgICAgLy9nb2luZyB0byBmb3JnZXQgdGhpcyBmb3IgYSBiaXQgd2hpbGUgd2UgaGFuZGxlIHRoZSByZXN0Li4uXG4gICAgICBhc3NpZ25tZW50cyA9IHtcbiAgICAgICAgLi4ucHJlYW1ibGVBc3NpZ25tZW50cyxcbiAgICAgICAgLi4ubGl0ZXJhbEFzc2lnbm1lbnRzKG5vZGUsIGFsdGVybmF0ZVN0YWNrLCBjdXJyZW50RGVwdGgpXG4gICAgICB9O1xuXG4gICAgICBkZWJ1ZyhcIk1lbWJlciBhY2Nlc3MgY2FzZVwiKTtcblxuICAgICAgLy9NZW1iZXJBY2Nlc3MgdXNlcyBleHByZXNzaW9uLCBub3QgYmFzZUV4cHJlc3Npb25cbiAgICAgIGJhc2VFeHByZXNzaW9uID0gbm9kZS5leHByZXNzaW9uO1xuXG4gICAgICAvL2lmIHRoaXMgaXNuJ3QgYSBzdG9yYWdlIHN0cnVjdCwgb3IgdGhlIGVsZW1lbnQgaXNuJ3Qgb2YgcmVmZXJlbmNlIHR5cGUsXG4gICAgICAvL3dlJ2xsIGp1c3QgZG8gdGhlIGFzc2lnbm1lbnQgYW5kIHF1aXQgb3V0IChhZ2Fpbiwgbm90ZSB0aGF0IG1hcHBpbmdzXG4gICAgICAvL2FyZW4ndCBjYXVnaHQgYnkgaXNSZWZlcmVuY2UpXG4gICAgICBpZiAoXG4gICAgICAgIERlY29kZVV0aWxzLkRlZmluaXRpb24udHlwZUNsYXNzKGJhc2VFeHByZXNzaW9uKSAhPT0gXCJzdHJ1Y3RcIiB8fFxuICAgICAgICAoRGVjb2RlVXRpbHMuRGVmaW5pdGlvbi5pc1JlZmVyZW5jZShub2RlKVxuICAgICAgICAgID8gRGVjb2RlVXRpbHMuRGVmaW5pdGlvbi5yZWZlcmVuY2VUeXBlKGJhc2VFeHByZXNzaW9uKSAhPT0gXCJzdG9yYWdlXCJcbiAgICAgICAgICA6ICFEZWNvZGVVdGlscy5EZWZpbml0aW9uLmlzTWFwcGluZyhub2RlKSlcbiAgICAgICkge1xuICAgICAgICBkZWJ1ZyhcIk1lbWJlciBjYXNlIGJhaWxlZCBvdXQgZWFybHlcIik7XG4gICAgICAgIHlpZWxkIHB1dChhY3Rpb25zLmFzc2lnbihhc3NpZ25tZW50cykpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy9idXQgaWYgaXQgaXMgYSBzdG9yYWdlIHN0cnVjdCwgd2UgaGF2ZSB0byBtYXAgdGhlIHBhdGggYXMgd2VsbFxuICAgICAgcGF0aCA9IGZldGNoQmFzZVBhdGgoXG4gICAgICAgIGJhc2VFeHByZXNzaW9uLFxuICAgICAgICBtYXBwZWRQYXRocyxcbiAgICAgICAgY3VycmVudEFzc2lnbm1lbnRzLFxuICAgICAgICBjdXJyZW50RGVwdGhcbiAgICAgICk7XG5cbiAgICAgIHNsb3QgPSB7IHBhdGggfTtcblxuICAgICAgbGV0IHN0cnVjdElkID0gRGVjb2RlVXRpbHMuRGVmaW5pdGlvbi50eXBlSWQoYmFzZUV4cHJlc3Npb24pO1xuICAgICAgbGV0IG1lbWJlckFsbG9jYXRpb24gPVxuICAgICAgICBhbGxvY2F0aW9uc1tzdHJ1Y3RJZF0ubWVtYmVyc1tub2RlLnJlZmVyZW5jZWREZWNsYXJhdGlvbl07XG5cbiAgICAgIHNsb3Qub2Zmc2V0ID0gbWVtYmVyQWxsb2NhdGlvbi5wb2ludGVyLnN0b3JhZ2UuZnJvbS5zbG90Lm9mZnNldC5jbG9uZSgpO1xuXG4gICAgICBkZWJ1ZyhcInNsb3QgJW9cIiwgc2xvdCk7XG4gICAgICB5aWVsZCBwdXQoXG4gICAgICAgIGFjdGlvbnMubWFwUGF0aEFuZEFzc2lnbihcbiAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgIHNsb3QsXG4gICAgICAgICAgYXNzaWdubWVudHMsXG4gICAgICAgICAgRGVjb2RlVXRpbHMuRGVmaW5pdGlvbi50eXBlSWRlbnRpZmllcihub2RlKSxcbiAgICAgICAgICBEZWNvZGVVdGlscy5EZWZpbml0aW9uLnR5cGVJZGVudGlmaWVyKGJhc2VFeHByZXNzaW9uKVxuICAgICAgICApXG4gICAgICApO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmIChub2RlLnR5cGVEZXNjcmlwdGlvbnMgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBkZWJ1ZyhcImRlY29kaW5nIGV4cHJlc3Npb24gdmFsdWUgJU9cIiwgbm9kZS50eXBlRGVzY3JpcHRpb25zKTtcbiAgICAgIGRlYnVnKFwiZGVmYXVsdCBjYXNlXCIpO1xuICAgICAgZGVidWcoXCJjdXJyZW50RGVwdGggJWQgbm9kZS5pZCAlZFwiLCBjdXJyZW50RGVwdGgsIG5vZGUuaWQpO1xuXG4gICAgICBhc3NpZ25tZW50cyA9IHtcbiAgICAgICAgLi4ucHJlYW1ibGVBc3NpZ25tZW50cyxcbiAgICAgICAgLi4ubGl0ZXJhbEFzc2lnbm1lbnRzKG5vZGUsIHN0YWNrLCBjdXJyZW50RGVwdGgpXG4gICAgICB9O1xuICAgICAgeWllbGQgcHV0KGFjdGlvbnMuYXNzaWduKGFzc2lnbm1lbnRzKSk7XG4gICAgICBicmVhaztcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24qIHJlc2V0KCkge1xuICB5aWVsZCBwdXQoYWN0aW9ucy5yZXNldCgpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiByZWNvcmRBbGxvY2F0aW9ucygpIHtcbiAgY29uc3QgY29udHJhY3RzID0geWllbGQgc2VsZWN0KFxuICAgIGRhdGEudmlld3MudXNlckRlZmluZWRUeXBlcy5jb250cmFjdERlZmluaXRpb25zXG4gICk7XG4gIGRlYnVnKFwiY29udHJhY3RzICVPXCIsIGNvbnRyYWN0cyk7XG4gIGNvbnN0IHJlZmVyZW5jZURlY2xhcmF0aW9ucyA9IHlpZWxkIHNlbGVjdChkYXRhLnZpZXdzLnJlZmVyZW5jZURlY2xhcmF0aW9ucyk7XG4gIGRlYnVnKFwicmVmZXJlbmNlRGVjbGFyYXRpb25zICVPXCIsIHJlZmVyZW5jZURlY2xhcmF0aW9ucyk7XG4gIGNvbnN0IHN0b3JhZ2VBbGxvY2F0aW9ucyA9IGdldFN0b3JhZ2VBbGxvY2F0aW9ucyhcbiAgICByZWZlcmVuY2VEZWNsYXJhdGlvbnMsXG4gICAgY29udHJhY3RzXG4gICk7XG4gIGRlYnVnKFwic3RvcmFnZUFsbG9jYXRpb25zICVPXCIsIHN0b3JhZ2VBbGxvY2F0aW9ucyk7XG4gIGNvbnN0IG1lbW9yeUFsbG9jYXRpb25zID0gZ2V0TWVtb3J5QWxsb2NhdGlvbnMocmVmZXJlbmNlRGVjbGFyYXRpb25zKTtcbiAgY29uc3QgY2FsbGRhdGFBbGxvY2F0aW9ucyA9IGdldENhbGxkYXRhQWxsb2NhdGlvbnMocmVmZXJlbmNlRGVjbGFyYXRpb25zKTtcbiAgeWllbGQgcHV0KFxuICAgIGFjdGlvbnMuYWxsb2NhdGUoc3RvcmFnZUFsbG9jYXRpb25zLCBtZW1vcnlBbGxvY2F0aW9ucywgY2FsbGRhdGFBbGxvY2F0aW9ucylcbiAgKTtcbn1cblxuZnVuY3Rpb24gbGl0ZXJhbEFzc2lnbm1lbnRzKG5vZGUsIHN0YWNrLCBjdXJyZW50RGVwdGgpIHtcbiAgbGV0IHRvcCA9IHN0YWNrLmxlbmd0aCAtIDE7XG5cbiAgbGV0IGxpdGVyYWwgPSByZWFkU3RhY2soXG4gICAgc3RhY2ssXG4gICAgdG9wIC0gRGVjb2RlVXRpbHMuRGVmaW5pdGlvbi5zdGFja1NpemUobm9kZSkgKyAxLFxuICAgIHRvcFxuICApO1xuXG4gIGxldCBhc3NpZ25tZW50ID0gbWFrZUFzc2lnbm1lbnQoXG4gICAgeyBhc3RJZDogbm9kZS5pZCwgc3RhY2tmcmFtZTogY3VycmVudERlcHRoIH0sXG4gICAgeyBsaXRlcmFsIH1cbiAgKTtcblxuICByZXR1cm4geyBbYXNzaWdubWVudC5pZF06IGFzc2lnbm1lbnQgfTtcbn1cblxuLy90YWtlcyBhIHBhcmFtZXRlciBsaXN0IGFzIGdpdmVuIGluIHRoZSBBU1RcbmZ1bmN0aW9uIGFzc2lnblBhcmFtZXRlcnMocGFyYW1ldGVycywgdG9wLCBmdW5jdGlvbkRlcHRoKSB7XG4gIGxldCByZXZlcnNlUGFyYW1ldGVycyA9IHBhcmFtZXRlcnMuc2xpY2UoKS5yZXZlcnNlKCk7XG4gIC8vcmV2ZXJzZSBpcyBpbi1wbGFjZSwgc28gd2UgdXNlIHNsaWNlKCkgdG8gY2xvbmUgZmlyc3RcbiAgZGVidWcoXCJyZXZlcnNlUGFyYW1ldGVycyAlb1wiLCBwYXJhbWV0ZXJzKTtcblxuICBsZXQgY3VycmVudFBvc2l0aW9uID0gdG9wO1xuICBsZXQgYXNzaWdubWVudHMgPSB7fTtcblxuICBmb3IgKGxldCBwYXJhbWV0ZXIgb2YgcmV2ZXJzZVBhcmFtZXRlcnMpIHtcbiAgICBsZXQgd29yZHMgPSBEZWNvZGVVdGlscy5EZWZpbml0aW9uLnN0YWNrU2l6ZShwYXJhbWV0ZXIpO1xuICAgIGxldCBwb2ludGVyID0ge1xuICAgICAgc3RhY2s6IHtcbiAgICAgICAgZnJvbTogY3VycmVudFBvc2l0aW9uIC0gd29yZHMgKyAxLFxuICAgICAgICB0bzogY3VycmVudFBvc2l0aW9uXG4gICAgICB9XG4gICAgfTtcbiAgICBsZXQgYXNzaWdubWVudCA9IG1ha2VBc3NpZ25tZW50KFxuICAgICAgeyBhc3RJZDogcGFyYW1ldGVyLmlkLCBzdGFja2ZyYW1lOiBmdW5jdGlvbkRlcHRoIH0sXG4gICAgICBwb2ludGVyXG4gICAgKTtcbiAgICBhc3NpZ25tZW50c1thc3NpZ25tZW50LmlkXSA9IGFzc2lnbm1lbnQ7XG4gICAgY3VycmVudFBvc2l0aW9uIC09IHdvcmRzO1xuICB9XG4gIHJldHVybiBhc3NpZ25tZW50cztcbn1cblxuZnVuY3Rpb24gZmV0Y2hCYXNlUGF0aChcbiAgYmFzZU5vZGUsXG4gIG1hcHBlZFBhdGhzLFxuICBjdXJyZW50QXNzaWdubWVudHMsXG4gIGN1cnJlbnREZXB0aFxuKSB7XG4gIGxldCBmdWxsSWQgPSBzdGFibGVLZWNjYWsyNTYoe1xuICAgIGFzdElkOiBiYXNlTm9kZS5pZCxcbiAgICBzdGFja2ZyYW1lOiBjdXJyZW50RGVwdGhcbiAgfSk7XG4gIC8vYmFzZSBleHByZXNzaW9uIGlzIGFuIGV4cHJlc3Npb24sIGFuZCBzbyBoYXMgYSBsaXRlcmFsIGFzc2lnbmVkIHRvXG4gIC8vaXRcbiAgbGV0IG9mZnNldCA9IERlY29kZVV0aWxzLkNvbnZlcnNpb24udG9CTihcbiAgICBjdXJyZW50QXNzaWdubWVudHMuYnlJZFtmdWxsSWRdLnJlZi5saXRlcmFsXG4gICk7XG4gIHJldHVybiB7IG9mZnNldCB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24qIHNhZ2EoKSB7XG4gIHlpZWxkIHRha2VFdmVyeShUSUNLLCB0aWNrU2FnYSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHByZWZpeE5hbWUoXCJkYXRhXCIsIHNhZ2EpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9kYXRhL3NhZ2FzL2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL3NldFwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9zZXRcIlxuLy8gbW9kdWxlIGlkID0gMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL3Byb21pc2VcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvcHJvbWlzZVwiXG4vLyBtb2R1bGUgaWQgPSAyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6YXN0Om1hcFwiKTtcblxuaW1wb3J0IEludGVydmFsVHJlZSBmcm9tIFwibm9kZS1pbnRlcnZhbC10cmVlXCI7XG5pbXBvcnQganNvbnBvaW50ZXIgZnJvbSBcImpzb24tcG9pbnRlclwiO1xuaW1wb3J0IHsgaXNTa2lwcGVkTm9kZVR5cGUgfSBmcm9tIFwibGliL2hlbHBlcnNcIjtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmFuZ2Uobm9kZSkge1xuICAvLyBzcmM6IFwiPHN0YXJ0Pjo8bGVuZ3RoPjo8Xz5cIlxuICAvLyByZXR1cm5zIFtzdGFydCwgZW5kXVxuICBsZXQgW3N0YXJ0LCBsZW5ndGhdID0gbm9kZS5zcmNcbiAgICAuc3BsaXQoXCI6XCIpXG4gICAgLnNsaWNlKDAsIDIpXG4gICAgLm1hcChpID0+IHBhcnNlSW50KGkpKTtcblxuICByZXR1cm4gW3N0YXJ0LCBzdGFydCArIGxlbmd0aF07XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmdlTm9kZXMobm9kZSwgcG9pbnRlciA9IFwiXCIpIHtcbiAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIHJldHVybiBbXS5jb25jYXQoXG4gICAgICAuLi5ub2RlLm1hcCgoc3ViLCBpKSA9PiByYW5nZU5vZGVzKHN1YiwgYCR7cG9pbnRlcn0vJHtpfWApKVxuICAgICk7XG4gIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgIGxldCByZXN1bHRzID0gW107XG5cbiAgICBpZiAobm9kZS5zcmMpIHtcbiAgICAgIHJlc3VsdHMucHVzaCh7IHBvaW50ZXIsIHJhbmdlOiBnZXRSYW5nZShub2RlKSB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0cy5jb25jYXQoXG4gICAgICAuLi5PYmplY3Qua2V5cyhub2RlKS5tYXAoa2V5ID0+XG4gICAgICAgIHJhbmdlTm9kZXMobm9kZVtrZXldLCBgJHtwb2ludGVyfS8ke2tleX1gKVxuICAgICAgKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRPdmVybGFwcGluZ1JhbmdlKG5vZGUsIHNvdXJjZVN0YXJ0LCBzb3VyY2VMZW5ndGgpIHtcbiAgbGV0IHJhbmdlcyA9IHJhbmdlTm9kZXMobm9kZSk7XG4gIGxldCB0cmVlID0gbmV3IEludGVydmFsVHJlZSgpO1xuXG4gIHJhbmdlcy5mb3JFYWNoKCh7IHJhbmdlLCBwb2ludGVyIH0pID0+IHtcbiAgICBsZXQgW3N0YXJ0LCBlbmRdID0gcmFuZ2U7XG5cbiAgICB0cmVlLmluc2VydChzdGFydCwgZW5kLCB7IHJhbmdlLCBwb2ludGVyIH0pO1xuICB9KTtcblxuICBsZXQgc291cmNlRW5kID0gc291cmNlU3RhcnQgKyBzb3VyY2VMZW5ndGg7XG5cbiAgcmV0dXJuIHRyZWUuc2VhcmNoKHNvdXJjZVN0YXJ0LCBzb3VyY2VFbmQpO1xuICAvL3JldHVybnMgZXZlcnl0aGluZyBvdmVybGFwcGluZyB0aGUgZ2l2ZW4gcmFuZ2Vcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZFJhbmdlKG5vZGUsIHNvdXJjZVN0YXJ0LCBzb3VyY2VMZW5ndGgpIHtcbiAgLy8gZmluZCBub2RlcyB0aGF0IGZ1bGx5IGNvbnRhaW4gcmVxdWVzdGVkIHJhbmdlLFxuICAvLyByZXR1cm4gbG9uZ2VzdCBwb2ludGVyXG4gIGxldCBzb3VyY2VFbmQgPSBzb3VyY2VTdGFydCArIHNvdXJjZUxlbmd0aDtcbiAgcmV0dXJuIGZpbmRPdmVybGFwcGluZ1JhbmdlKG5vZGUsIHNvdXJjZVN0YXJ0LCBzb3VyY2VMZW5ndGgpXG4gICAgLmZpbHRlcigoeyByYW5nZSB9KSA9PiBzb3VyY2VTdGFydCA+PSByYW5nZVswXSAmJiBzb3VyY2VFbmQgPD0gcmFuZ2VbMV0pXG4gICAgLm1hcCgoeyBwb2ludGVyIH0pID0+IHBvaW50ZXIpXG4gICAgLnJlZHVjZSgoYSwgYikgPT4gKGEubGVuZ3RoID4gYi5sZW5ndGggPyBhIDogYiksIFwiXCIpO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbnlOb25Ta2lwcGVkSW5SYW5nZShub2RlLCBzb3VyY2VTdGFydCwgc291cmNlTGVuZ3RoKSB7XG4gIGxldCBzb3VyY2VFbmQgPSBzb3VyY2VTdGFydCArIHNvdXJjZUxlbmd0aDtcbiAgcmV0dXJuIGZpbmRPdmVybGFwcGluZ1JhbmdlKG5vZGUsIHNvdXJjZVN0YXJ0LCBzb3VyY2VMZW5ndGgpLnNvbWUoXG4gICAgKHsgcmFuZ2UsIHBvaW50ZXIgfSkgPT5cbiAgICAgIHNvdXJjZVN0YXJ0IDw9IHJhbmdlWzBdICYmIC8vd2Ugd2FudCB0byBnbyBieSBzdGFydGluZyBsaW5lXG4gICAgICByYW5nZVswXSA8IHNvdXJjZUVuZCAmJlxuICAgICAgIWlzU2tpcHBlZE5vZGVUeXBlKGpzb25wb2ludGVyLmdldChub2RlLCBwb2ludGVyKSlcbiAgICAvL05PVEU6IHRoaXMgZG9lc24ndCBhY3R1YWxseSBjYXRjaCBldmVyeXRoaW5nIHNraXBwZWQhICBCdXQgZG9pbmcgYmV0dGVyXG4gICAgLy9pcyBoYXJkXG4gICk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2FzdC9tYXAuanMiLCJleHBvcnQgY29uc3QgU0NPUEUgPSBcIlNDT1BFXCI7XG5leHBvcnQgZnVuY3Rpb24gc2NvcGUoaWQsIHBvaW50ZXIsIHBhcmVudElkLCBzb3VyY2VJZCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFNDT1BFLFxuICAgIGlkLFxuICAgIHBvaW50ZXIsXG4gICAgcGFyZW50SWQsXG4gICAgc291cmNlSWRcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IERFQ0xBUkUgPSBcIkRFQ0xBUkVfVkFSSUFCTEVcIjtcbmV4cG9ydCBmdW5jdGlvbiBkZWNsYXJlKG5vZGUpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBERUNMQVJFLFxuICAgIG5vZGVcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IEFTU0lHTiA9IFwiQVNTSUdOXCI7XG5leHBvcnQgZnVuY3Rpb24gYXNzaWduKGFzc2lnbm1lbnRzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQVNTSUdOLFxuICAgIGFzc2lnbm1lbnRzXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBNQVBfUEFUSF9BTkRfQVNTSUdOID0gXCJNQVBfUEFUSF9BTkRfQVNTSUdOXCI7XG5leHBvcnQgZnVuY3Rpb24gbWFwUGF0aEFuZEFzc2lnbihcbiAgYWRkcmVzcyxcbiAgc2xvdCxcbiAgYXNzaWdubWVudHMsXG4gIHR5cGVJZGVudGlmaWVyLFxuICBwYXJlbnRUeXBlXG4pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBNQVBfUEFUSF9BTkRfQVNTSUdOLFxuICAgIGFkZHJlc3MsXG4gICAgc2xvdCxcbiAgICBhc3NpZ25tZW50cyxcbiAgICB0eXBlSWRlbnRpZmllcixcbiAgICBwYXJlbnRUeXBlXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBNQVBfS0VZX0RFQ09ESU5HID0gXCJNQVBfS0VZX0RFQ09ESU5HXCI7XG5leHBvcnQgZnVuY3Rpb24gbWFwS2V5RGVjb2Rpbmcoc3RhcnRlZCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IE1BUF9LRVlfREVDT0RJTkcsXG4gICAgc3RhcnRlZFxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgUkVTRVQgPSBcIkRBVEFfUkVTRVRcIjtcbmV4cG9ydCBmdW5jdGlvbiByZXNldCgpIHtcbiAgcmV0dXJuIHsgdHlwZTogUkVTRVQgfTtcbn1cblxuZXhwb3J0IGNvbnN0IERFRklORV9UWVBFID0gXCJERUZJTkVfVFlQRVwiO1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmluZVR5cGUobm9kZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IERFRklORV9UWVBFLFxuICAgIG5vZGVcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IEFMTE9DQVRFID0gXCJBTExPQ0FURVwiO1xuZXhwb3J0IGZ1bmN0aW9uIGFsbG9jYXRlKHN0b3JhZ2UsIG1lbW9yeSwgY2FsbGRhdGEpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBBTExPQ0FURSxcbiAgICBzdG9yYWdlLFxuICAgIG1lbW9yeSxcbiAgICBjYWxsZGF0YVxuICB9O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9kYXRhL2FjdGlvbnMvaW5kZXguanMiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6YXN0OnNlbGVjdG9yc1wiKTtcblxuaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3JUcmVlLCBjcmVhdGVMZWFmIH0gZnJvbSBcInJlc2VsZWN0LXRyZWVcIjtcblxuaW1wb3J0IHNvbGlkaXR5IGZyb20gXCJsaWIvc29saWRpdHkvc2VsZWN0b3JzXCI7XG5cbi8qKlxuICogYXN0XG4gKi9cbmNvbnN0IGFzdCA9IGNyZWF0ZVNlbGVjdG9yVHJlZSh7XG4gIC8qKlxuICAgKiBhc3Qudmlld3NcbiAgICovXG4gIHZpZXdzOiB7XG4gICAgLyoqXG4gICAgICogYXN0LnZpZXdzLnNvdXJjZXNcbiAgICAgKi9cbiAgICBzb3VyY2VzOiBjcmVhdGVMZWFmKFtzb2xpZGl0eS5pbmZvLnNvdXJjZXNdLCBzb3VyY2VzID0+IHNvdXJjZXMpXG4gIH1cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBhc3Q7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2FzdC9zZWxlY3RvcnMvaW5kZXguanMiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6ZXZtOnNhZ2FzXCIpO1xuXG5pbXBvcnQgeyBwdXQsIHRha2VFdmVyeSwgc2VsZWN0IH0gZnJvbSBcInJlZHV4LXNhZ2EvZWZmZWN0c1wiO1xuaW1wb3J0IHsgcHJlZml4TmFtZSwga2VjY2FrMjU2IH0gZnJvbSBcImxpYi9oZWxwZXJzXCI7XG5cbmltcG9ydCB7IFRJQ0sgfSBmcm9tIFwibGliL3RyYWNlL2FjdGlvbnNcIjtcbmltcG9ydCAqIGFzIGFjdGlvbnMgZnJvbSBcIi4uL2FjdGlvbnNcIjtcblxuaW1wb3J0IGV2bSBmcm9tIFwiLi4vc2VsZWN0b3JzXCI7XG5cbmltcG9ydCAqIGFzIHRyYWNlIGZyb20gXCJsaWIvdHJhY2Uvc2FnYXNcIjtcblxuLyoqXG4gKiBBZGRzIEVWTSBieXRlY29kZSBjb250ZXh0XG4gKlxuICogQHJldHVybiB7c3RyaW5nfSBJRCAoMHgtcHJlZml4ZWQga2VjY2FrIG9mIGJpbmFyeSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uKiBhZGRDb250ZXh0KGNvbnRleHQpIHtcbiAgY29uc3QgY29udGV4dEhhc2ggPSBrZWNjYWsyNTYoeyB0eXBlOiBcInN0cmluZ1wiLCB2YWx1ZTogY29udGV4dC5iaW5hcnkgfSk7XG4gIC8vTk9URTogd2UgdGFrZSBoYXNoIGFzICpzdHJpbmcqLCBub3QgYXMgYnl0ZXMsIGJlY2F1c2UgdGhlIGJpbmFyeSBtYXlcbiAgLy9jb250YWluIGxpbmsgcmVmZXJlbmNlcyFcblxuICBkZWJ1ZyhcImNvbnRleHQgJU9cIiwgY29udGV4dCk7XG4gIHlpZWxkIHB1dChhY3Rpb25zLmFkZENvbnRleHQoY29udGV4dCkpO1xuXG4gIHJldHVybiBjb250ZXh0SGFzaDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiBub3JtYWxpemVDb250ZXh0cygpIHtcbiAgeWllbGQgcHV0KGFjdGlvbnMubm9ybWFsaXplQ29udGV4dHMoKSk7XG59XG5cbi8qKlxuICogQWRkcyBrbm93biBkZXBsb3llZCBpbnN0YW5jZSBvZiBiaW5hcnkgYXQgYWRkcmVzc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiaW5hcnkgLSBtYXkgYmUgdW5kZWZpbmVkIChlLmcuIHByZWNvbXBpbGVzKVxuICogQHJldHVybiB7c3RyaW5nfSBJRCAoMHgtcHJlZml4ZWQga2VjY2FrIG9mIGJpbmFyeSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uKiBhZGRJbnN0YW5jZShhZGRyZXNzLCBiaW5hcnkpIHtcbiAgbGV0IHNlYXJjaCA9IHlpZWxkIHNlbGVjdChldm0uaW5mby5iaW5hcmllcy5zZWFyY2gpO1xuICBsZXQgY29udGV4dCA9IHNlYXJjaChiaW5hcnkpO1xuXG4gIC8vIGluIGNhc2UgYmluYXJ5IGlzIHVua25vd24sIGFkZCBhIGNvbnRleHQgZm9yIGl0XG4gIGlmIChjb250ZXh0ID09PSBudWxsKSB7XG4gICAgY29udGV4dCA9IHlpZWxkKiBhZGRDb250ZXh0KHtcbiAgICAgIGJpbmFyeSxcbiAgICAgIGlzQ29uc3RydWN0b3I6IGZhbHNlXG4gICAgICAvL2FkZEluc3RhbmNlIGlzIG9ubHkgdXNlZCBmb3IgYWRkaW5nIGRlcGxveWVkIGluc3RhbmNlcywgc28gaXQgd2lsbFxuICAgICAgLy9uZXZlciBiZSBhIGNvbnN0cnVjdG9yXG4gICAgfSk7XG4gIH1cblxuICAvL25vdywgd2hldGhlciB3ZSBuZWVkZWQgYSBuZXcgY29udGV4dCBvciBub3QsIGFkZCB0aGUgaW5zdGFuY2VcbiAgeWllbGQgcHV0KGFjdGlvbnMuYWRkSW5zdGFuY2UoYWRkcmVzcywgY29udGV4dCwgYmluYXJ5KSk7XG5cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogYmVnaW4oe1xuICBhZGRyZXNzLFxuICBiaW5hcnksXG4gIGRhdGEsXG4gIHN0b3JhZ2VBZGRyZXNzLFxuICBzZW5kZXIsXG4gIHZhbHVlLFxuICBnYXNwcmljZSxcbiAgYmxvY2tcbn0pIHtcbiAgeWllbGQgcHV0KGFjdGlvbnMuc2F2ZUdsb2JhbHMoc2VuZGVyLCBnYXNwcmljZSwgYmxvY2spKTtcbiAgaWYgKGFkZHJlc3MpIHtcbiAgICB5aWVsZCBwdXQoYWN0aW9ucy5jYWxsKGFkZHJlc3MsIGRhdGEsIHN0b3JhZ2VBZGRyZXNzLCBzZW5kZXIsIHZhbHVlKSk7XG4gIH0gZWxzZSB7XG4gICAgeWllbGQgcHV0KGFjdGlvbnMuY3JlYXRlKGJpbmFyeSwgc3RvcmFnZUFkZHJlc3MsIHNlbmRlciwgdmFsdWUpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiogdGlja1NhZ2EoKSB7XG4gIGRlYnVnKFwiZ290IFRJQ0tcIik7XG5cbiAgeWllbGQqIGNhbGxzdGFja0FuZENvZGV4U2FnYSgpO1xuICB5aWVsZCogdHJhY2Uuc2lnbmFsVGlja1NhZ2FDb21wbGV0aW9uKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogY2FsbHN0YWNrQW5kQ29kZXhTYWdhKCkge1xuICBpZiAoeWllbGQgc2VsZWN0KGV2bS5jdXJyZW50LnN0ZXAuaXNFeGNlcHRpb25hbEhhbHRpbmcpKSB7XG4gICAgLy9sZXQncyBoYW5kbGUgdGhpcyBjYXNlIGZpcnN0IHNvIHdlIGNhbiBiZSBzdXJlIGV2ZXJ5dGhpbmcgZWxzZSBpcyAqbm90KlxuICAgIC8vYW4gZXhjZXB0aW9uYWwgaGFsdFxuICAgIGRlYnVnKFwiZXhjZXB0aW9uYWwgaGFsdCFcIik7XG5cbiAgICB5aWVsZCBwdXQoYWN0aW9ucy5mYWlsKCkpO1xuICB9IGVsc2UgaWYgKHlpZWxkIHNlbGVjdChldm0uY3VycmVudC5zdGVwLmlzQ2FsbCkpIHtcbiAgICBkZWJ1ZyhcImdvdCBjYWxsXCIpO1xuICAgIC8vIGlmIHRoZXJlIGlzIG5vIGJpbmFyeSAoZS5nLiBpbiB0aGUgY2FzZSBvZiBwcmVjb21waWxlZCBjb250cmFjdHMgb3JcbiAgICAvLyBleHRlcm5hbGx5IG93bmVkIGFjY291bnRzKSwgdGhlbiB0aGVyZSB3aWxsIGJlIG5vIHRyYWNlIHN0ZXBzIGZvciB0aGVcbiAgICAvLyBjYWxsZWQgY29kZSwgYW5kIHNvIHdlIHNob3VsZG4ndCB0ZWxsIHRoZSBkZWJ1Z2dlciB0aGF0IHdlJ3JlIGVudGVyaW5nXG4gICAgLy8gYW5vdGhlciBleGVjdXRpb24gY29udGV4dFxuICAgIGlmICh5aWVsZCBzZWxlY3QoZXZtLmN1cnJlbnQuc3RlcC5jYWxsc1ByZWNvbXBpbGVPckV4dGVybmFsKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBhZGRyZXNzID0geWllbGQgc2VsZWN0KGV2bS5jdXJyZW50LnN0ZXAuY2FsbEFkZHJlc3MpO1xuICAgIGxldCBkYXRhID0geWllbGQgc2VsZWN0KGV2bS5jdXJyZW50LnN0ZXAuY2FsbERhdGEpO1xuXG4gICAgZGVidWcoXCJjYWxsaW5nIGFkZHJlc3MgJXNcIiwgYWRkcmVzcyk7XG5cbiAgICBpZiAoeWllbGQgc2VsZWN0KGV2bS5jdXJyZW50LnN0ZXAuaXNEZWxlZ2F0ZUNhbGxTdHJpY3QpKSB7XG4gICAgICAvL2lmIGRlbGVnYXRpbmcsIGxlYXZlIHN0b3JhZ2VBZGRyZXNzLCBzZW5kZXIsIGFuZCB2YWx1ZSB0aGUgc2FtZVxuICAgICAgbGV0IHsgc3RvcmFnZUFkZHJlc3MsIHNlbmRlciwgdmFsdWUgfSA9IHlpZWxkIHNlbGVjdChldm0uY3VycmVudC5jYWxsKTtcbiAgICAgIHlpZWxkIHB1dChhY3Rpb25zLmNhbGwoYWRkcmVzcywgZGF0YSwgc3RvcmFnZUFkZHJlc3MsIHNlbmRlciwgdmFsdWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy90aGlzIGJyYW5jaCBjb3ZlcnMgQ0FMTCwgQ0FMTENPREUsIGFuZCBTVEFUSUNDQUxMXG4gICAgICBsZXQgY3VycmVudENhbGwgPSB5aWVsZCBzZWxlY3QoZXZtLmN1cnJlbnQuY2FsbCk7XG4gICAgICBsZXQgc3RvcmFnZUFkZHJlc3MgPSAoeWllbGQgc2VsZWN0KGV2bS5jdXJyZW50LnN0ZXAuaXNEZWxlZ2F0ZUNhbGxCcm9hZCkpXG4gICAgICAgID8gY3VycmVudENhbGwuc3RvcmFnZUFkZHJlc3MgLy9mb3IgQ0FMTENPREVcbiAgICAgICAgOiBhZGRyZXNzO1xuICAgICAgbGV0IHNlbmRlciA9IGN1cnJlbnRDYWxsLnN0b3JhZ2VBZGRyZXNzOyAvL25vdCB0aGUgY29kZSBhZGRyZXNzIVxuICAgICAgbGV0IHZhbHVlID0geWllbGQgc2VsZWN0KGV2bS5jdXJyZW50LnN0ZXAuY2FsbFZhbHVlKTsgLy8wIGlmIHN0YXRpY1xuICAgICAgeWllbGQgcHV0KGFjdGlvbnMuY2FsbChhZGRyZXNzLCBkYXRhLCBzdG9yYWdlQWRkcmVzcywgc2VuZGVyLCB2YWx1ZSkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh5aWVsZCBzZWxlY3QoZXZtLmN1cnJlbnQuc3RlcC5pc0NyZWF0ZSkpIHtcbiAgICBkZWJ1ZyhcImdvdCBjcmVhdGVcIik7XG4gICAgbGV0IGJpbmFyeSA9IHlpZWxkIHNlbGVjdChldm0uY3VycmVudC5zdGVwLmNyZWF0ZUJpbmFyeSk7XG4gICAgbGV0IGNyZWF0ZWRBZGRyZXNzID0geWllbGQgc2VsZWN0KGV2bS5jdXJyZW50LnN0ZXAuY3JlYXRlZEFkZHJlc3MpO1xuICAgIGxldCB2YWx1ZSA9IHlpZWxkIHNlbGVjdChldm0uY3VycmVudC5zdGVwLmNyZWF0ZVZhbHVlKTtcbiAgICBsZXQgc2VuZGVyID0gKHlpZWxkIHNlbGVjdChldm0uY3VycmVudC5jYWxsKSkuc3RvcmFnZUFkZHJlc3M7XG4gICAgLy9ub3QgdGhlIGNvZGUgYWRkcmVzcyFcblxuICAgIHlpZWxkIHB1dChhY3Rpb25zLmNyZWF0ZShiaW5hcnksIGNyZWF0ZWRBZGRyZXNzLCBzZW5kZXIsIHZhbHVlKSk7XG4gICAgLy9hcyBhYm92ZSwgc3RvcmFnZUFkZHJlc3MgaGFuZGxlcyB3aGVuIGNhbGxpbmcgZnJvbSBhIGNyZWF0aW9uIGNhbGxcbiAgfSBlbHNlIGlmICh5aWVsZCBzZWxlY3QoZXZtLmN1cnJlbnQuc3RlcC5pc0hhbHRpbmcpKSB7XG4gICAgZGVidWcoXCJnb3QgcmV0dXJuXCIpO1xuXG4gICAgeWllbGQgcHV0KGFjdGlvbnMucmV0dXJuQ2FsbCgpKTtcbiAgfSBlbHNlIGlmICh5aWVsZCBzZWxlY3QoZXZtLmN1cnJlbnQuc3RlcC50b3VjaGVzU3RvcmFnZSkpIHtcbiAgICBsZXQgc3RvcmFnZUFkZHJlc3MgPSAoeWllbGQgc2VsZWN0KGV2bS5jdXJyZW50LmNhbGwpKS5zdG9yYWdlQWRkcmVzcztcbiAgICBsZXQgc2xvdCA9IHlpZWxkIHNlbGVjdChldm0uY3VycmVudC5zdGVwLnN0b3JhZ2VBZmZlY3RlZCk7XG4gICAgLy9ub3RlIHdlIGdldCBuZXh0IHN0b3JhZ2UsIHNpbmNlIHdlJ3JlIHVwZGF0aW5nIHRvIHRoYXRcbiAgICBsZXQgc3RvcmFnZSA9IHlpZWxkIHNlbGVjdChldm0ubmV4dC5zdGF0ZS5zdG9yYWdlKTtcbiAgICAvL25vcm1hbGx5IHdlJ2QgbmVlZCBhIDAgZmFsbGJhY2sgZm9yIHRoaXMgbmV4dCBsaW5lLCBidXQgaW4gdGhpcyBjYXNlIHdlXG4gICAgLy9jYW4gYmUgc3VyZSB0aGUgdmFsdWUgd2lsbCBiZSB0aGVyZSwgc2luY2Ugd2UncmUgdG91Y2hpbmcgdGhhdCBzdG9yYWdlXG4gICAgaWYgKHlpZWxkIHNlbGVjdChldm0uY3VycmVudC5zdGVwLmlzU3RvcmUpKSB7XG4gICAgICB5aWVsZCBwdXQoYWN0aW9ucy5zdG9yZShzdG9yYWdlQWRkcmVzcywgc2xvdCwgc3RvcmFnZVtzbG90XSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvL290aGVyd2lzZSwgaXQncyBhIGxvYWRcbiAgICAgIHlpZWxkIHB1dChhY3Rpb25zLmxvYWQoc3RvcmFnZUFkZHJlc3MsIHNsb3QsIHN0b3JhZ2Vbc2xvdF0pKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiByZXNldCgpIHtcbiAgbGV0IGluaXRpYWxBZGRyZXNzID0gKHlpZWxkIHNlbGVjdChldm0uY3VycmVudC5jYWxsc3RhY2spKVswXS5zdG9yYWdlQWRkcmVzcztcbiAgeWllbGQgcHV0KGFjdGlvbnMucmVzZXQoaW5pdGlhbEFkZHJlc3MpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiBzYWdhKCkge1xuICB5aWVsZCB0YWtlRXZlcnkoVElDSywgdGlja1NhZ2EpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBwcmVmaXhOYW1lKFwiZXZtXCIsIHNhZ2EpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9ldm0vc2FnYXMvaW5kZXguanMiLCJleHBvcnQgY29uc3QgQUREX0NPTlRFWFQgPSBcIkVWTV9BRERfQ09OVEVYVFwiO1xuZXhwb3J0IGZ1bmN0aW9uIGFkZENvbnRleHQoe1xuICBjb250cmFjdE5hbWUsXG4gIGJpbmFyeSxcbiAgc291cmNlTWFwLFxuICBjb21waWxlcixcbiAgYWJpLFxuICBjb250cmFjdElkLFxuICBjb250cmFjdEtpbmQsXG4gIGlzQ29uc3RydWN0b3Jcbn0pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBBRERfQ09OVEVYVCxcbiAgICBjb250cmFjdE5hbWUsXG4gICAgYmluYXJ5LFxuICAgIHNvdXJjZU1hcCxcbiAgICBjb21waWxlcixcbiAgICBhYmksXG4gICAgY29udHJhY3RJZCxcbiAgICBjb250cmFjdEtpbmQsXG4gICAgaXNDb25zdHJ1Y3RvclxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgTk9STUFMSVpFX0NPTlRFWFRTID0gXCJFVk1fTk9STUFMSVpFX0NPTlRFWFRTXCI7XG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplQ29udGV4dHMoKSB7XG4gIHJldHVybiB7IHR5cGU6IE5PUk1BTElaRV9DT05URVhUUyB9O1xufVxuXG5leHBvcnQgY29uc3QgQUREX0lOU1RBTkNFID0gXCJFVk1fQUREX0lOU1RBTkNFXCI7XG5leHBvcnQgZnVuY3Rpb24gYWRkSW5zdGFuY2UoYWRkcmVzcywgY29udGV4dCwgYmluYXJ5KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQUREX0lOU1RBTkNFLFxuICAgIGFkZHJlc3MsXG4gICAgY29udGV4dCxcbiAgICBiaW5hcnlcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IFNBVkVfR0xPQkFMUyA9IFwiU0FWRV9HTE9CQUxTXCI7XG5leHBvcnQgZnVuY3Rpb24gc2F2ZUdsb2JhbHMob3JpZ2luLCBnYXNwcmljZSwgYmxvY2spIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBTQVZFX0dMT0JBTFMsXG4gICAgb3JpZ2luLFxuICAgIGdhc3ByaWNlLFxuICAgIGJsb2NrXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBDQUxMID0gXCJDQUxMXCI7XG5leHBvcnQgZnVuY3Rpb24gY2FsbChhZGRyZXNzLCBkYXRhLCBzdG9yYWdlQWRkcmVzcywgc2VuZGVyLCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IENBTEwsXG4gICAgYWRkcmVzcyxcbiAgICBkYXRhLFxuICAgIHN0b3JhZ2VBZGRyZXNzLFxuICAgIHNlbmRlcixcbiAgICB2YWx1ZVxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgQ1JFQVRFID0gXCJDUkVBVEVcIjtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoYmluYXJ5LCBzdG9yYWdlQWRkcmVzcywgc2VuZGVyLCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IENSRUFURSxcbiAgICBiaW5hcnksXG4gICAgc3RvcmFnZUFkZHJlc3MsXG4gICAgc2VuZGVyLFxuICAgIHZhbHVlXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBSRVRVUk4gPSBcIlJFVFVSTlwiO1xuZXhwb3J0IGZ1bmN0aW9uIHJldHVybkNhbGwoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogUkVUVVJOXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBGQUlMID0gXCJGQUlMXCI7XG5leHBvcnQgZnVuY3Rpb24gZmFpbCgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBGQUlMXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBTVE9SRSA9IFwiU1RPUkVcIjtcbmV4cG9ydCBmdW5jdGlvbiBzdG9yZShhZGRyZXNzLCBzbG90LCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFNUT1JFLFxuICAgIGFkZHJlc3MsXG4gICAgc2xvdCxcbiAgICB2YWx1ZVxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgTE9BRCA9IFwiTE9BRFwiO1xuZXhwb3J0IGZ1bmN0aW9uIGxvYWQoYWRkcmVzcywgc2xvdCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBMT0FELFxuICAgIGFkZHJlc3MsXG4gICAgc2xvdCxcbiAgICB2YWx1ZVxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgUkVTRVQgPSBcIkVWTV9SRVNFVFwiO1xuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0KHN0b3JhZ2VBZGRyZXNzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogUkVTRVQsXG4gICAgc3RvcmFnZUFkZHJlc3NcbiAgfTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvZXZtL2FjdGlvbnMvaW5kZXguanMiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6c29saWRpdHk6c2FnYXNcIik7XG5cbmltcG9ydCB7IHB1dCwgdGFrZUV2ZXJ5LCBzZWxlY3QgfSBmcm9tIFwicmVkdXgtc2FnYS9lZmZlY3RzXCI7XG5pbXBvcnQgeyBwcmVmaXhOYW1lIH0gZnJvbSBcImxpYi9oZWxwZXJzXCI7XG5cbmltcG9ydCAqIGFzIGFjdGlvbnMgZnJvbSBcIi4uL2FjdGlvbnNcIjtcbmltcG9ydCB7IFRJQ0sgfSBmcm9tIFwibGliL3RyYWNlL2FjdGlvbnNcIjtcbmltcG9ydCAqIGFzIHRyYWNlIGZyb20gXCJsaWIvdHJhY2Uvc2FnYXNcIjtcblxuaW1wb3J0IHNvbGlkaXR5IGZyb20gXCIuLi9zZWxlY3RvcnNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uKiBhZGRTb3VyY2Uoc291cmNlLCBzb3VyY2VQYXRoLCBhc3QsIGNvbXBpbGVyKSB7XG4gIHlpZWxkIHB1dChhY3Rpb25zLmFkZFNvdXJjZShzb3VyY2UsIHNvdXJjZVBhdGgsIGFzdCwgY29tcGlsZXIpKTtcbn1cblxuZnVuY3Rpb24qIHRpY2tTYWdhKCkge1xuICBkZWJ1ZyhcImdvdCBUSUNLXCIpO1xuXG4gIHlpZWxkKiBmdW5jdGlvbkRlcHRoU2FnYSgpO1xuICB5aWVsZCogdHJhY2Uuc2lnbmFsVGlja1NhZ2FDb21wbGV0aW9uKCk7XG59XG5cbmZ1bmN0aW9uKiBmdW5jdGlvbkRlcHRoU2FnYSgpIHtcbiAgaWYgKHlpZWxkIHNlbGVjdChzb2xpZGl0eS5jdXJyZW50LndpbGxGYWlsKSkge1xuICAgIC8vd2UgZG8gdGhpcyBjYXNlIGZpcnN0IHNvIHdlIGNhbiBiZSBzdXJlIHdlJ3JlIG5vdCBmYWlsaW5nIGluIGFueSBvZiB0aGVcbiAgICAvL290aGVyIGNhc2VzIGJlbG93IVxuICAgIHlpZWxkIHB1dChhY3Rpb25zLmV4dGVybmFsUmV0dXJuKCkpO1xuICB9IGVsc2UgaWYgKHlpZWxkIHNlbGVjdChzb2xpZGl0eS5jdXJyZW50LndpbGxKdW1wKSkge1xuICAgIGxldCBqdW1wRGlyZWN0aW9uID0geWllbGQgc2VsZWN0KHNvbGlkaXR5LmN1cnJlbnQuanVtcERpcmVjdGlvbik7XG4gICAgeWllbGQgcHV0KGFjdGlvbnMuanVtcChqdW1wRGlyZWN0aW9uKSk7XG4gIH0gZWxzZSBpZiAoeWllbGQgc2VsZWN0KHNvbGlkaXR5LmN1cnJlbnQud2lsbENhbGwpKSB7XG4gICAgZGVidWcoXCJhYm91dCB0byBjYWxsXCIpO1xuICAgIGlmICh5aWVsZCBzZWxlY3Qoc29saWRpdHkuY3VycmVudC5jYWxsc1ByZWNvbXBpbGVPckV4dGVybmFsKSkge1xuICAgICAgLy9jYWxsIHRvIHByZWNvbXBpbGUgb3IgZXh0ZXJuYWxseS1vd25lZCBhY2NvdW50OyBkbyBub3RoaW5nXG4gICAgfSBlbHNlIHtcbiAgICAgIHlpZWxkIHB1dChhY3Rpb25zLmV4dGVybmFsQ2FsbCgpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoeWllbGQgc2VsZWN0KHNvbGlkaXR5LmN1cnJlbnQud2lsbENyZWF0ZSkpIHtcbiAgICB5aWVsZCBwdXQoYWN0aW9ucy5leHRlcm5hbENhbGwoKSk7XG4gIH0gZWxzZSBpZiAoeWllbGQgc2VsZWN0KHNvbGlkaXR5LmN1cnJlbnQud2lsbFJldHVybikpIHtcbiAgICB5aWVsZCBwdXQoYWN0aW9ucy5leHRlcm5hbFJldHVybigpKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24qIHJlc2V0KCkge1xuICB5aWVsZCBwdXQoYWN0aW9ucy5yZXNldCgpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiBzYWdhKCkge1xuICB5aWVsZCB0YWtlRXZlcnkoVElDSywgdGlja1NhZ2EpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBwcmVmaXhOYW1lKFwic29saWRpdHlcIiwgc2FnYSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3NvbGlkaXR5L3NhZ2FzL2luZGV4LmpzIiwiZXhwb3J0IGNvbnN0IEFERF9TT1VSQ0UgPSBcIlNPTElESVRZX0FERF9TT1VSQ0VcIjtcbmV4cG9ydCBmdW5jdGlvbiBhZGRTb3VyY2Uoc291cmNlLCBzb3VyY2VQYXRoLCBhc3QsIGNvbXBpbGVyKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQUREX1NPVVJDRSxcbiAgICBzb3VyY2UsXG4gICAgc291cmNlUGF0aCxcbiAgICBhc3QsXG4gICAgY29tcGlsZXJcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IEpVTVAgPSBcIkpVTVBcIjtcbmV4cG9ydCBmdW5jdGlvbiBqdW1wKGp1bXBEaXJlY3Rpb24pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBKVU1QLFxuICAgIGp1bXBEaXJlY3Rpb25cbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IEVYVEVSTkFMX0NBTEwgPSBcIkVYVEVSTkFMX0NBTExcIjtcbmV4cG9ydCBmdW5jdGlvbiBleHRlcm5hbENhbGwoKSB7XG4gIHJldHVybiB7IHR5cGU6IEVYVEVSTkFMX0NBTEwgfTtcbn1cblxuZXhwb3J0IGNvbnN0IEVYVEVSTkFMX1JFVFVSTiA9IFwiRVhURVJOQUxfUkVUVVJOXCI7XG5leHBvcnQgZnVuY3Rpb24gZXh0ZXJuYWxSZXR1cm4oKSB7XG4gIHJldHVybiB7IHR5cGU6IEVYVEVSTkFMX1JFVFVSTiB9O1xufVxuXG5leHBvcnQgY29uc3QgUkVTRVQgPSBcIlNPTElESVRZX1JFU0VUXCI7XG5leHBvcnQgZnVuY3Rpb24gcmVzZXQoKSB7XG4gIHJldHVybiB7IHR5cGU6IFJFU0VUIH07XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3NvbGlkaXR5L2FjdGlvbnMvaW5kZXguanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ3ZWIzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwid2ViM1wiXG4vLyBtb2R1bGUgaWQgPSAzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRGVidWdnZXIgPSByZXF1aXJlKFwiLi9saWIvZGVidWdnZXJcIikuZGVmYXVsdDtcblxubW9kdWxlLmV4cG9ydHMgPSBEZWJ1Z2dlcjtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kZWJ1Z2dlci5qc1xuLy8gbW9kdWxlIGlkID0gMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gJ2RlYnVnJztcbmltcG9ydCBleHBlY3QgZnJvbSBcInRydWZmbGUtZXhwZWN0XCI7XG5cbmltcG9ydCBTZXNzaW9uIGZyb20gXCIuL3Nlc3Npb25cIjtcblxuaW1wb3J0IHsgY3JlYXRlTmVzdGVkU2VsZWN0b3IgfSBmcm9tIFwicmVzZWxlY3QtdHJlZVwiO1xuXG5pbXBvcnQgZGF0YVNlbGVjdG9yIGZyb20gXCIuL2RhdGEvc2VsZWN0b3JzXCI7XG5pbXBvcnQgYXN0U2VsZWN0b3IgZnJvbSBcIi4vYXN0L3NlbGVjdG9yc1wiO1xuaW1wb3J0IHRyYWNlU2VsZWN0b3IgZnJvbSBcIi4vdHJhY2Uvc2VsZWN0b3JzXCI7XG5pbXBvcnQgZXZtU2VsZWN0b3IgZnJvbSBcIi4vZXZtL3NlbGVjdG9yc1wiO1xuaW1wb3J0IHNvbGlkaXR5U2VsZWN0b3IgZnJvbSBcIi4vc29saWRpdHkvc2VsZWN0b3JzXCI7XG5pbXBvcnQgc2Vzc2lvblNlbGVjdG9yIGZyb20gXCIuL3Nlc3Npb24vc2VsZWN0b3JzXCI7XG5pbXBvcnQgY29udHJvbGxlclNlbGVjdG9yIGZyb20gXCIuL2NvbnRyb2xsZXIvc2VsZWN0b3JzXCI7XG5cbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlclwiKTtcblxuLyoqXG4gKiBAZXhhbXBsZVxuICogbGV0IHNlc3Npb24gPSBEZWJ1Z2dlclxuICogICAuZm9yVHgoPHR4SGFzaD4sIHtcbiAqICAgICBjb250cmFjdHM6IFs8Y29udHJhY3Qgb2JqPiwgLi4uXSxcbiAqICAgICBwcm92aWRlcjogPHByb3ZpZGVyIGluc3RhbmNlPlxuICogICB9KVxuICogICAuY29ubmVjdCgpO1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZWJ1Z2dlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1Nlc3Npb259IHNlc3Npb24gLSBkZWJ1Z2dlciBzZXNzaW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihzZXNzaW9uKSB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9zZXNzaW9uID0gc2Vzc2lvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnN0YW50aWF0ZXMgYSBEZWJ1Z2dlciBmb3IgYSBnaXZlbiB0cmFuc2FjdGlvbiBoYXNoLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHhIYXNoIC0gdHJhbnNhY3Rpb24gaGFzaCB3aXRoIGxlYWRpbmcgXCIweFwiXG4gICAqIEBwYXJhbSB7e2NvbnRyYWN0czogQXJyYXk8Q29udHJhY3Q+LCBmaWxlczogQXJyYXk8U3RyaW5nPiwgcHJvdmlkZXI6IFdlYjNQcm92aWRlcn19IG9wdGlvbnMgLVxuICAgKiBAcmV0dXJuIHtEZWJ1Z2dlcn0gaW5zdGFuY2VcbiAgICovXG4gIHN0YXRpYyBhc3luYyBmb3JUeCh0eEhhc2gsIG9wdGlvbnMgPSB7fSkge1xuICAgIGV4cGVjdC5vcHRpb25zKG9wdGlvbnMsIFtcbiAgICAgIFwiY29udHJhY3RzXCIsXG4gICAgICBcInByb3ZpZGVyXCJcbiAgICBdKTtcblxuICAgIGxldCBzZXNzaW9uID0gbmV3IFNlc3Npb24oXG4gICAgICBvcHRpb25zLmNvbnRyYWN0cywgb3B0aW9ucy5maWxlcyxcbiAgICAgIHR4SGFzaCwgb3B0aW9ucy5wcm92aWRlclxuICAgICk7XG5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgc2Vzc2lvbi5yZWFkeSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyB0aGlzKHNlc3Npb24pO1xuICB9XG5cblxuICAvKipcbiAgICogQ29ubmVjdHMgdG8gdGhlIGluc3RhbnRpYXRlZCBEZWJ1Z2dlci5cbiAgICpcbiAgICogQHJldHVybiB7U2Vzc2lvbn0gc2Vzc2lvbiBpbnN0YW5jZVxuICAgKi9cbiAgY29ubmVjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2Vzc2lvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBvcnRlZCBzZWxlY3RvcnNcbiAgICpcbiAgICogU2VlIGluZGl2aWR1YWwgc2VsZWN0b3IgZG9jcyBmb3IgZnVsbCBsaXN0aW5nXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIERlYnVnZ2VyLnNlbGVjdG9ycy5hc3QuY3VycmVudC50cmVlXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIERlYnVnZ2VyLnNlbGVjdG9ycy5zb2xpZGl0eS5jdXJyZW50Lmluc3RydWN0aW9uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIERlYnVnZ2VyLnNlbGVjdG9ycy50cmFjZS5zdGVwc1xuICAgKi9cbiAgc3RhdGljIGdldCBzZWxlY3RvcnMoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZU5lc3RlZFNlbGVjdG9yKHtcbiAgICAgIGFzdDogYXN0U2VsZWN0b3IsXG4gICAgICBkYXRhOiBkYXRhU2VsZWN0b3IsXG4gICAgICB0cmFjZTogdHJhY2VTZWxlY3RvcixcbiAgICAgIGV2bTogZXZtU2VsZWN0b3IsXG4gICAgICBzb2xpZGl0eTogc29saWRpdHlTZWxlY3RvcixcbiAgICAgIHNlc3Npb246IHNlc3Npb25TZWxlY3RvcixcbiAgICAgIGNvbnRyb2xsZXI6IGNvbnRyb2xsZXJTZWxlY3RvcixcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IENvbnRyYWN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gY29udHJhY3ROYW1lIGNvbnRyYWN0IG5hbWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzb3VyY2Ugc29saWRpdHkgc291cmNlIGNvZGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzb3VyY2VQYXRoIHBhdGggdG8gc291cmNlIGZpbGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBiaW5hcnkgMHgtcHJlZml4ZWQgaGV4IHN0cmluZyB3aXRoIGNyZWF0ZSBieXRlY29kZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNvdXJjZU1hcCBzb2xpZGl0eSBzb3VyY2UgbWFwIGZvciBjcmVhdGUgYnl0ZWNvZGVcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBhc3QgQWJzdHJhY3QgU3ludGF4IFRyZWUgZnJvbSBTb2xpZGl0eVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGRlcGxveWVkQmluYXJ5IDB4LXByZWZpeGVkIGNvbXBpbGVkIGJpbmFyeSAob24gY2hhaW4pXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZGVwbG95ZWRTb3VyY2VNYXAgc29saWRpdHkgc291cmNlIG1hcCBmb3Igb24tY2hhaW4gYnl0ZWNvZGVcbiAqL1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9kZWJ1Z2dlci5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInRydWZmbGUtZXhwZWN0XCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwidHJ1ZmZsZS1leHBlY3RcIlxuLy8gbW9kdWxlIGlkID0gMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOnNlc3Npb25cIik7XG5cbmltcG9ydCBjb25maWd1cmVTdG9yZSBmcm9tIFwibGliL3N0b3JlXCI7XG5cbmltcG9ydCAqIGFzIGNvbnRyb2xsZXIgZnJvbSBcImxpYi9jb250cm9sbGVyL2FjdGlvbnNcIjtcbmltcG9ydCAqIGFzIGFjdGlvbnMgZnJvbSBcIi4vYWN0aW9uc1wiO1xuaW1wb3J0IGRhdGEgZnJvbSBcImxpYi9kYXRhL3NlbGVjdG9yc1wiO1xuaW1wb3J0IGNvbnRyb2xsZXJTZWxlY3RvciBmcm9tIFwibGliL2NvbnRyb2xsZXIvc2VsZWN0b3JzXCI7XG5cbmltcG9ydCByb290U2FnYSBmcm9tIFwiLi9zYWdhc1wiO1xuaW1wb3J0IHJlZHVjZXIgZnJvbSBcIi4vcmVkdWNlcnNcIjtcblxuLyoqXG4gKiBEZWJ1Z2dlciBTZXNzaW9uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlc3Npb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxDb250cmFjdD59IGNvbnRyYWN0cyAtIGNvbnRyYWN0IGRlZmluaXRpb25zXG4gICAqIEBwYXJhbSB7QXJyYXk8U3RyaW5nPn0gZmlsZXMgLSBhcnJheSBvZiBmaWxlbmFtZXMgZm9yIHNvdXJjZU1hcCBpbmRleGVzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eEhhc2ggLSB0cmFuc2FjdGlvbiBoYXNoXG4gICAqIEBwYXJhbSB7V2ViM1Byb3ZpZGVyfSBwcm92aWRlciAtIHdlYjMgcHJvdmlkZXJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbnRyYWN0cywgZmlsZXMsIHR4SGFzaCwgcHJvdmlkZXIpIHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3N0b3JlID0gY29uZmlndXJlU3RvcmUocmVkdWNlciwgcm9vdFNhZ2EpO1xuXG4gICAgbGV0IHsgY29udGV4dHMsIHNvdXJjZXMgfSA9IFNlc3Npb24ubm9ybWFsaXplKGNvbnRyYWN0cywgZmlsZXMpO1xuXG4gICAgLy8gcmVjb3JkIGNvbnRyYWN0c1xuICAgIHRoaXMuX3N0b3JlLmRpc3BhdGNoKGFjdGlvbnMucmVjb3JkQ29udHJhY3RzKGNvbnRleHRzLCBzb3VyY2VzKSk7XG5cbiAgICB0aGlzLl9zdG9yZS5kaXNwYXRjaChhY3Rpb25zLnN0YXJ0KHR4SGFzaCwgcHJvdmlkZXIpKTtcbiAgfVxuXG4gIGFzeW5jIHJlYWR5KCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgoYWNjZXB0LCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuX3N0b3JlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnNlc3Npb24uc3RhdHVzID09IFwiQUNUSVZFXCIpIHtcbiAgICAgICAgICBhY2NlcHQoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5zdGF0ZS5zZXNzaW9uLnN0YXR1cyA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgcmVqZWN0KHRoaXMuc3RhdGUuc2Vzc2lvbi5zdGF0dXMuZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdCB1cCBhcnRpZmFjdHMgaW50byBcImNvbnRleHRzXCIgYW5kIFwic291cmNlc1wiLCBkaXZpZGluZyBhcnRpZmFjdFxuICAgKiBkYXRhIGludG8gYXBwcm9wcmlhdGUgYnVja2V0cy5cbiAgICpcbiAgICogTXVsdGlwbGUgY29udHJhY3RzIGNhbiBiZSBkZWZpbmVkIGluIHRoZSBzYW1lIHNvdXJjZSBmaWxlLCBidXQgaGF2ZVxuICAgKiBkaWZmZXJlbnQgYnl0ZWNvZGVzLlxuICAgKlxuICAgKiBUaGlzIGl0ZXJhdGVzIG92ZXIgdGhlIGNvbnRyYWN0cyBhbmQgY29sbGVjdHMgYmluYXJpZXMgc2VwYXJhdGVseVxuICAgKiBmcm9tIHNvdXJjZXMsIHVzaW5nIHRoZSBvcHRpb25hbCBgZmlsZXNgIGFyZ3VtZW50IHRvIGZvcmNlXG4gICAqIHNvdXJjZSBvcmRlcmluZy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXRpYyBub3JtYWxpemUoY29udHJhY3RzLCBmaWxlcyA9IG51bGwpIHtcbiAgICBsZXQgc291cmNlc0J5UGF0aCA9IHt9O1xuICAgIGxldCBjb250ZXh0cyA9IFtdO1xuICAgIGxldCBzb3VyY2VzO1xuXG4gICAgZm9yIChsZXQgY29udHJhY3Qgb2YgY29udHJhY3RzKSB7XG4gICAgICBsZXQge1xuICAgICAgICBjb250cmFjdE5hbWUsXG4gICAgICAgIGJpbmFyeSxcbiAgICAgICAgc291cmNlTWFwLFxuICAgICAgICBkZXBsb3llZEJpbmFyeSxcbiAgICAgICAgZGVwbG95ZWRTb3VyY2VNYXAsXG4gICAgICAgIHNvdXJjZVBhdGgsXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgYXN0LFxuICAgICAgICBhYmksXG4gICAgICAgIGNvbXBpbGVyXG4gICAgICB9ID0gY29udHJhY3Q7XG5cbiAgICAgIGxldCBjb250cmFjdE5vZGUgPSBhc3Qubm9kZXMuZmluZChcbiAgICAgICAgbm9kZSA9PlxuICAgICAgICAgIG5vZGUubm9kZVR5cGUgPT09IFwiQ29udHJhY3REZWZpbml0aW9uXCIgJiYgbm9kZS5uYW1lID09PSBjb250cmFjdE5hbWVcbiAgICAgICk7IC8vaWRlYWxseSB3ZSdkIGhvbGQgdGhpcyBvZmYgdGlsbCBsYXRlciwgYnV0IHRoYXQgd291bGQgYnJlYWsgdGhlXG4gICAgICAvL2RpcmVjdGlvbiBvZiB0aGUgZXZtL3NvbGlkaXR5IGRlcGVuZGVuY2UsIHNvIHdlIGRvIGl0IG5vd1xuXG4gICAgICBsZXQgY29udHJhY3RJZCA9IGNvbnRyYWN0Tm9kZS5pZDtcbiAgICAgIGxldCBjb250cmFjdEtpbmQgPSBjb250cmFjdE5vZGUuY29udHJhY3RLaW5kO1xuXG4gICAgICBkZWJ1ZyhcImNvbnRyYWN0TmFtZSAlc1wiLCBjb250cmFjdE5hbWUpO1xuICAgICAgZGVidWcoXCJzb3VyY2VNYXAgJW9cIiwgc291cmNlTWFwKTtcbiAgICAgIGRlYnVnKFwiY29tcGlsZXIgJW9cIiwgY29tcGlsZXIpO1xuICAgICAgZGVidWcoXCJhYmkgJU9cIiwgYWJpKTtcblxuICAgICAgc291cmNlc0J5UGF0aFtzb3VyY2VQYXRoXSA9IHsgc291cmNlUGF0aCwgc291cmNlLCBhc3QsIGNvbXBpbGVyIH07XG5cbiAgICAgIGlmIChiaW5hcnkgJiYgYmluYXJ5ICE9IFwiMHhcIikge1xuICAgICAgICBjb250ZXh0cy5wdXNoKHtcbiAgICAgICAgICBjb250cmFjdE5hbWUsXG4gICAgICAgICAgYmluYXJ5LFxuICAgICAgICAgIHNvdXJjZU1hcCxcbiAgICAgICAgICBhYmksXG4gICAgICAgICAgY29tcGlsZXIsXG4gICAgICAgICAgY29udHJhY3RJZCxcbiAgICAgICAgICBjb250cmFjdEtpbmQsXG4gICAgICAgICAgaXNDb25zdHJ1Y3RvcjogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlcGxveWVkQmluYXJ5ICYmIGRlcGxveWVkQmluYXJ5ICE9IFwiMHhcIikge1xuICAgICAgICBjb250ZXh0cy5wdXNoKHtcbiAgICAgICAgICBjb250cmFjdE5hbWUsXG4gICAgICAgICAgYmluYXJ5OiBkZXBsb3llZEJpbmFyeSxcbiAgICAgICAgICBzb3VyY2VNYXA6IGRlcGxveWVkU291cmNlTWFwLFxuICAgICAgICAgIGFiaSxcbiAgICAgICAgICBjb21waWxlcixcbiAgICAgICAgICBjb250cmFjdElkLFxuICAgICAgICAgIGNvbnRyYWN0S2luZCxcbiAgICAgICAgICBpc0NvbnN0cnVjdG9yOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWZpbGVzKSB7XG4gICAgICBzb3VyY2VzID0gT2JqZWN0LnZhbHVlcyhzb3VyY2VzQnlQYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc291cmNlcyA9IGZpbGVzLm1hcChmaWxlID0+IHNvdXJjZXNCeVBhdGhbZmlsZV0pO1xuICAgIH1cblxuICAgIHJldHVybiB7IGNvbnRleHRzLCBzb3VyY2VzIH07XG4gIH1cblxuICBnZXQgc3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0b3JlLmdldFN0YXRlKCk7XG4gIH1cblxuICB2aWV3KHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHNlbGVjdG9yKHRoaXMuc3RhdGUpO1xuICB9XG5cbiAgYXN5bmMgZGlzcGF0Y2goYWN0aW9uKSB7XG4gICAgdGhpcy5fc3RvcmUuZGlzcGF0Y2goYWN0aW9uKTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgYXN5bmMgaW50ZXJydXB0KCkge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKGNvbnRyb2xsZXIuaW50ZXJydXB0KCkpO1xuICB9XG5cbiAgYXN5bmMgZG9uZVN0ZXBwaW5nKHN0ZXBwZXJBY3Rpb24pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBsZXQgaGFzU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgbGV0IGhhc1Jlc29sdmVkID0gZmFsc2U7XG4gICAgICBjb25zdCB1bnN1YnNjcmliZSA9IHRoaXMuX3N0b3JlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzU3RlcHBpbmcgPSB0aGlzLnZpZXcoY29udHJvbGxlclNlbGVjdG9yLmlzU3RlcHBpbmcpO1xuXG4gICAgICAgIGlmIChpc1N0ZXBwaW5nICYmICFoYXNTdGFydGVkKSB7XG4gICAgICAgICAgaGFzU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgZGVidWcoXCJoZWFyZCBzdGVwIHN0YXJ0XCIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNTdGVwcGluZyAmJiBoYXNTdGFydGVkICYmICFoYXNSZXNvbHZlZCkge1xuICAgICAgICAgIGhhc1Jlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICBkZWJ1ZyhcImhlYXJkIHN0ZXAgc3RvcFwiKTtcbiAgICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5kaXNwYXRjaChzdGVwcGVyQWN0aW9uKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vTm90ZTogY291bnQgaXMgYW4gb3B0aW9uYWwgYXJndW1lbnQ7IGRlZmF1bHQgYmVoYXZpb3IgaXMgdG8gYWR2YW5jZSAxXG4gIGFzeW5jIGFkdmFuY2UoY291bnQpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5kb25lU3RlcHBpbmcoY29udHJvbGxlci5hZHZhbmNlKGNvdW50KSk7XG4gIH1cblxuICBhc3luYyBzdGVwTmV4dCgpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5kb25lU3RlcHBpbmcoY29udHJvbGxlci5zdGVwTmV4dCgpKTtcbiAgfVxuXG4gIGFzeW5jIHN0ZXBPdmVyKCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmRvbmVTdGVwcGluZyhjb250cm9sbGVyLnN0ZXBPdmVyKCkpO1xuICB9XG5cbiAgYXN5bmMgc3RlcEludG8oKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZG9uZVN0ZXBwaW5nKGNvbnRyb2xsZXIuc3RlcEludG8oKSk7XG4gIH1cblxuICBhc3luYyBzdGVwT3V0KCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmRvbmVTdGVwcGluZyhjb250cm9sbGVyLnN0ZXBPdXQoKSk7XG4gIH1cblxuICBhc3luYyByZXNldCgpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5kb25lU3RlcHBpbmcoY29udHJvbGxlci5yZXNldCgpKTtcbiAgfVxuXG4gIC8vTk9URTogYnJlYWtwb2ludHMgaXMgYW4gT1BUSU9OQUwgYXJndW1lbnQgZm9yIGlmIHlvdSB3YW50IHRvIHN1cHBseSB5b3VyXG4gIC8vb3duIGxpc3Qgb2YgYnJlYWtwb2ludHM7IGxlYXZlIGl0IG91dCB0byB1c2UgdGhlIGludGVybmFsIG9uZSAoYXNcbiAgLy9jb250cm9sbGVkIGJ5IHRoZSBmdW5jdGlvbnMgYmVsb3cpXG4gIGFzeW5jIGNvbnRpbnVlVW50aWxCcmVha3BvaW50KGJyZWFrcG9pbnRzKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZG9uZVN0ZXBwaW5nKFxuICAgICAgY29udHJvbGxlci5jb250aW51ZVVudGlsQnJlYWtwb2ludChicmVha3BvaW50cylcbiAgICApO1xuICB9XG5cbiAgYXN5bmMgYWRkQnJlYWtwb2ludChicmVha3BvaW50KSB7XG4gICAgdGhpcy5kaXNwYXRjaChjb250cm9sbGVyLmFkZEJyZWFrcG9pbnQoYnJlYWtwb2ludCkpO1xuICB9XG5cbiAgYXN5bmMgcmVtb3ZlQnJlYWtwb2ludChicmVha3BvaW50KSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goY29udHJvbGxlci5yZW1vdmVCcmVha3BvaW50KGJyZWFrcG9pbnQpKTtcbiAgfVxuXG4gIGFzeW5jIHJlbW92ZUFsbEJyZWFrcG9pbnRzKCkge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKGNvbnRyb2xsZXIucmVtb3ZlQWxsQnJlYWtwb2ludHMoKSk7XG4gIH1cblxuICBhc3luYyBkZWNvZGVSZWFkeSgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBsZXQgaGF2ZVJlc29sdmVkID0gZmFsc2U7XG4gICAgICBjb25zdCB1bnN1YnNjcmliZSA9IHRoaXMuX3N0b3JlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbkRlY29kaW5nU3RhcnRlZCA9IHRoaXMudmlldyhkYXRhLnByb2MuZGVjb2RpbmdLZXlzKTtcblxuICAgICAgICBkZWJ1ZyhcImZvbGxvd2luZyBkZWNvZGluZyBzdGFydGVkOiAlZFwiLCBzdWJzY3JpcHRpb25EZWNvZGluZ1N0YXJ0ZWQpO1xuXG4gICAgICAgIGlmIChzdWJzY3JpcHRpb25EZWNvZGluZ1N0YXJ0ZWQgPD0gMCAmJiAhaGF2ZVJlc29sdmVkKSB7XG4gICAgICAgICAgaGF2ZVJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGRlY29kaW5nU3RhcnRlZCA9IHRoaXMudmlldyhkYXRhLnByb2MuZGVjb2RpbmdLZXlzKTtcblxuICAgICAgZGVidWcoXCJpbml0aWFsIGRlY29kaW5nIHN0YXJ0ZWQ6ICVkXCIsIGRlY29kaW5nU3RhcnRlZCk7XG5cbiAgICAgIGlmIChkZWNvZGluZ1N0YXJ0ZWQgPD0gMCkge1xuICAgICAgICBoYXZlUmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBhc3luYyB2YXJpYWJsZShuYW1lKSB7XG4gICAgYXdhaXQgdGhpcy5kZWNvZGVSZWFkeSgpO1xuXG4gICAgY29uc3QgZGVmaW5pdGlvbnMgPSB0aGlzLnZpZXcoZGF0YS5jdXJyZW50LmlkZW50aWZpZXJzLmRlZmluaXRpb25zKTtcbiAgICBjb25zdCByZWZzID0gdGhpcy52aWV3KGRhdGEuY3VycmVudC5pZGVudGlmaWVycy5yZWZzKTtcblxuICAgIGNvbnN0IGRlY29kZSA9IHRoaXMudmlldyhkYXRhLnZpZXdzLmRlY29kZXIpO1xuICAgIHJldHVybiBhd2FpdCBkZWNvZGUoZGVmaW5pdGlvbnNbbmFtZV0sIHJlZnNbbmFtZV0pO1xuICB9XG5cbiAgYXN5bmMgdmFyaWFibGVzKCkge1xuICAgIGRlYnVnKFwiYXdhaXRpbmcgZGVjb2RlUmVhZHlcIik7XG4gICAgYXdhaXQgdGhpcy5kZWNvZGVSZWFkeSgpO1xuICAgIGRlYnVnKFwiZGVjb2RlIG5vdyByZWFkeVwiKTtcblxuICAgIHJldHVybiBhd2FpdCB0aGlzLnZpZXcoZGF0YS5jdXJyZW50LmlkZW50aWZpZXJzLmRlY29kZWQpO1xuICAgIGRlYnVnKFwiZ290IHZhcmlhYmxlc1wiKTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9zZXNzaW9uL2luZGV4LmpzIiwiaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3Byb2R1Y3Rpb25cIik7XG59IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInRlc3RcIikge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3Rlc3RcIik7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2RldmVsb3BtZW50XCIpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9zdG9yZS9pbmRleC5qcyIsImltcG9ydCBjb25maWd1cmVTdG9yZSBmcm9tIFwiLi9jb21tb25cIjtcbmV4cG9ydCBkZWZhdWx0IGNvbmZpZ3VyZVN0b3JlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9zdG9yZS9wcm9kdWN0aW9uLmpzIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOnN0b3JlOmNvbW1vblwiKTtcbmNvbnN0IHJlZHV4RGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOnJlZHV4XCIpO1xuXG5pbXBvcnQgeyBjb21wb3NlLCBjcmVhdGVTdG9yZSwgYXBwbHlNaWRkbGV3YXJlIH0gZnJvbSBcInJlZHV4XCI7XG5pbXBvcnQgY3JlYXRlU2FnYU1pZGRsZXdhcmUgZnJvbSBcInJlZHV4LXNhZ2FcIjtcbmltcG9ydCBjcmVhdGVMb2dnZXIgZnJvbSBcInJlZHV4LWNsaS1sb2dnZXJcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGFiYnJldmlhdGVWYWx1ZXModmFsdWUsIG9wdGlvbnMgPSB7fSwgZGVwdGggPSAwKSB7XG4gIG9wdGlvbnMuc3RyaW5nTGltaXQgPSBvcHRpb25zLnN0cmluZ0xpbWl0IHx8IDY2O1xuICBvcHRpb25zLmFycmF5TGltaXQgPSBvcHRpb25zLmFycmF5TGltaXQgfHwgODtcbiAgb3B0aW9ucy5yZWN1cnNlTGltaXQgPSBvcHRpb25zLnJlY3Vyc2VMaW1pdCB8fCA0O1xuXG4gIGlmIChkZXB0aCA+IG9wdGlvbnMucmVjdXJzZUxpbWl0KSB7XG4gICAgcmV0dXJuIFwiLi4uXCI7XG4gIH1cblxuICBjb25zdCByZWN1cnNlID0gKGNoaWxkKSA9PiBhYmJyZXZpYXRlVmFsdWVzKGNoaWxkLCBvcHRpb25zLCBkZXB0aCArIDEpO1xuXG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgaWYgKHZhbHVlLmxlbmd0aCA+IG9wdGlvbnMuYXJyYXlMaW1pdCkge1xuICAgICAgdmFsdWUgPSBbXG4gICAgICAgIC4uLnZhbHVlLnNsaWNlKDAsIG9wdGlvbnMuYXJyYXlMaW1pdCAvIDIpLFxuICAgICAgICBcIi4uLlwiLFxuICAgICAgICAuLi52YWx1ZS5zbGljZSh2YWx1ZS5sZW5ndGggLSBvcHRpb25zLmFycmF5TGltaXQgLyAyICsgMSlcbiAgICAgIF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlLm1hcChyZWN1cnNlKTtcblxuICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sXG4gICAgICAuLi5PYmplY3QuZW50cmllcyh2YWx1ZSkubWFwKFxuICAgICAgICAoW2ssIHZdKSA9PiAoeyBbcmVjdXJzZShrKV06IHJlY3Vyc2UodikgfSlcbiAgICAgIClcbiAgICApO1xuXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlLmxlbmd0aCA+IG9wdGlvbnMuc3RyaW5nTGltaXQpIHtcbiAgICBsZXQgaW5uZXIgPSBcIi4uLlwiO1xuICAgIGxldCBleHRyYWN0QW1vdW50ID0gKG9wdGlvbnMuc3RyaW5nTGltaXQgLSBpbm5lci5sZW5ndGgpIC8gMjtcbiAgICBsZXQgbGVhZGluZyA9IHZhbHVlLnNsaWNlKDAsIE1hdGguY2VpbChleHRyYWN0QW1vdW50KSk7XG4gICAgbGV0IHRyYWlsaW5nID0gdmFsdWUuc2xpY2UodmFsdWUubGVuZ3RoIC0gTWF0aC5mbG9vcihleHRyYWN0QW1vdW50KSk7XG4gICAgcmV0dXJuIGAke2xlYWRpbmd9JHtpbm5lcn0ke3RyYWlsaW5nfWA7XG5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29uZmlndXJlU3RvcmUgKHJlZHVjZXIsIHNhZ2EsIGluaXRpYWxTdGF0ZSwgY29tcG9zZUVuaGFuY2Vycykge1xuICBjb25zdCBzYWdhTWlkZGxld2FyZSA9IGNyZWF0ZVNhZ2FNaWRkbGV3YXJlKCk7XG5cbiAgaWYgKCFjb21wb3NlRW5oYW5jZXJzKSB7XG4gICAgY29tcG9zZUVuaGFuY2VycyA9IGNvbXBvc2U7XG4gIH1cblxuICBjb25zdCBsb2dnZXJNaWRkbGV3YXJlID0gY3JlYXRlTG9nZ2VyKHtcbiAgICBsb2c6IHJlZHV4RGVidWcsXG4gICAgc3RhdGVUcmFuc2Zvcm1lcjogKHN0YXRlKSA9PiBhYmJyZXZpYXRlVmFsdWVzKHN0YXRlLCB7XG4gICAgICBhcnJheUxpbWl0OiA0LFxuICAgICAgcmVjdXJzZUxpbWl0OiAzXG4gICAgfSksXG4gICAgYWN0aW9uVHJhbnNmb3JtZXI6IGFiYnJldmlhdGVWYWx1ZXMsXG4gIH0pO1xuXG4gIGxldCBzdG9yZSA9IGNyZWF0ZVN0b3JlKFxuICAgIHJlZHVjZXIsIGluaXRpYWxTdGF0ZSxcblxuICAgIGNvbXBvc2VFbmhhbmNlcnMoXG4gICAgICBhcHBseU1pZGRsZXdhcmUoXG4gICAgICAgIHNhZ2FNaWRkbGV3YXJlLFxuICAgICAgICBsb2dnZXJNaWRkbGV3YXJlXG4gICAgICApXG4gICAgKVxuICApO1xuXG4gIHNhZ2FNaWRkbGV3YXJlLnJ1bihzYWdhKTtcblxuICByZXR1cm4gc3RvcmU7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3N0b3JlL2NvbW1vbi5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlZHV4LXNhZ2FcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJyZWR1eC1zYWdhXCJcbi8vIG1vZHVsZSBpZCA9IDQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlZHV4LWNsaS1sb2dnZXJcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJyZWR1eC1jbGktbG9nZ2VyXCJcbi8vIG1vZHVsZSBpZCA9IDQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBqc29uID0gdHlwZW9mIEpTT04gIT09ICd1bmRlZmluZWQnID8gSlNPTiA6IHJlcXVpcmUoJ2pzb25pZnknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqLCBvcHRzKSB7XG4gICAgaWYgKCFvcHRzKSBvcHRzID0ge307XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSBvcHRzID0geyBjbXA6IG9wdHMgfTtcbiAgICB2YXIgc3BhY2UgPSBvcHRzLnNwYWNlIHx8ICcnO1xuICAgIGlmICh0eXBlb2Ygc3BhY2UgPT09ICdudW1iZXInKSBzcGFjZSA9IEFycmF5KHNwYWNlKzEpLmpvaW4oJyAnKTtcbiAgICB2YXIgY3ljbGVzID0gKHR5cGVvZiBvcHRzLmN5Y2xlcyA9PT0gJ2Jvb2xlYW4nKSA/IG9wdHMuY3ljbGVzIDogZmFsc2U7XG4gICAgdmFyIHJlcGxhY2VyID0gb3B0cy5yZXBsYWNlciB8fCBmdW5jdGlvbihrZXksIHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcblxuICAgIHZhciBjbXAgPSBvcHRzLmNtcCAmJiAoZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYW9iaiA9IHsga2V5OiBhLCB2YWx1ZTogbm9kZVthXSB9O1xuICAgICAgICAgICAgICAgIHZhciBib2JqID0geyBrZXk6IGIsIHZhbHVlOiBub2RlW2JdIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGYoYW9iaiwgYm9iaik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH0pKG9wdHMuY21wKTtcblxuICAgIHZhciBzZWVuID0gW107XG4gICAgcmV0dXJuIChmdW5jdGlvbiBzdHJpbmdpZnkgKHBhcmVudCwga2V5LCBub2RlLCBsZXZlbCkge1xuICAgICAgICB2YXIgaW5kZW50ID0gc3BhY2UgPyAoJ1xcbicgKyBuZXcgQXJyYXkobGV2ZWwgKyAxKS5qb2luKHNwYWNlKSkgOiAnJztcbiAgICAgICAgdmFyIGNvbG9uU2VwYXJhdG9yID0gc3BhY2UgPyAnOiAnIDogJzonO1xuXG4gICAgICAgIGlmIChub2RlICYmIG5vZGUudG9KU09OICYmIHR5cGVvZiBub2RlLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUudG9KU09OKCk7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gcmVwbGFjZXIuY2FsbChwYXJlbnQsIGtleSwgbm9kZSk7XG5cbiAgICAgICAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcgfHwgbm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGpzb24uc3RyaW5naWZ5KG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FycmF5KG5vZGUpKSB7XG4gICAgICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHN0cmluZ2lmeShub2RlLCBpLCBub2RlW2ldLCBsZXZlbCsxKSB8fCBqc29uLnN0cmluZ2lmeShudWxsKTtcbiAgICAgICAgICAgICAgICBvdXQucHVzaChpbmRlbnQgKyBzcGFjZSArIGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICdbJyArIG91dC5qb2luKCcsJykgKyBpbmRlbnQgKyAnXSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoc2Vlbi5pbmRleE9mKG5vZGUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChjeWNsZXMpIHJldHVybiBqc29uLnN0cmluZ2lmeSgnX19jeWNsZV9fJyk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ29udmVydGluZyBjaXJjdWxhciBzdHJ1Y3R1cmUgdG8gSlNPTicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBzZWVuLnB1c2gobm9kZSk7XG5cbiAgICAgICAgICAgIHZhciBrZXlzID0gb2JqZWN0S2V5cyhub2RlKS5zb3J0KGNtcCAmJiBjbXAobm9kZSkpO1xuICAgICAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gc3RyaW5naWZ5KG5vZGUsIGtleSwgbm9kZVtrZXldLCBsZXZlbCsxKTtcblxuICAgICAgICAgICAgICAgIGlmKCF2YWx1ZSkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICB2YXIga2V5VmFsdWUgPSBqc29uLnN0cmluZ2lmeShrZXkpXG4gICAgICAgICAgICAgICAgICAgICsgY29sb25TZXBhcmF0b3JcbiAgICAgICAgICAgICAgICAgICAgKyB2YWx1ZTtcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgb3V0LnB1c2goaW5kZW50ICsgc3BhY2UgKyBrZXlWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWVuLnNwbGljZShzZWVuLmluZGV4T2Yobm9kZSksIDEpO1xuICAgICAgICAgICAgcmV0dXJuICd7JyArIG91dC5qb2luKCcsJykgKyBpbmRlbnQgKyAnfSc7XG4gICAgICAgIH1cbiAgICB9KSh7ICcnOiBvYmogfSwgJycsIG9iaiwgMCk7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4ge30udG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5IHx8IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWUgfTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKGhhcy5jYWxsKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9Vc2Vycy9mYWluYXNoYWx0cy90cnVmZmxlLWRldi90cnVmZmxlL25vZGVfbW9kdWxlcy9qc29uLXN0YWJsZS1zdHJpbmdpZnkvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2xpYi9wYXJzZScpO1xuZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2xpYi9zdHJpbmdpZnknKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9Vc2Vycy9mYWluYXNoYWx0cy90cnVmZmxlLWRldi90cnVmZmxlL25vZGVfbW9kdWxlcy9qc29uaWZ5L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYXQsIC8vIFRoZSBpbmRleCBvZiB0aGUgY3VycmVudCBjaGFyYWN0ZXJcbiAgICBjaCwgLy8gVGhlIGN1cnJlbnQgY2hhcmFjdGVyXG4gICAgZXNjYXBlZSA9IHtcbiAgICAgICAgJ1wiJzogICdcIicsXG4gICAgICAgICdcXFxcJzogJ1xcXFwnLFxuICAgICAgICAnLyc6ICAnLycsXG4gICAgICAgIGI6ICAgICdcXGInLFxuICAgICAgICBmOiAgICAnXFxmJyxcbiAgICAgICAgbjogICAgJ1xcbicsXG4gICAgICAgIHI6ICAgICdcXHInLFxuICAgICAgICB0OiAgICAnXFx0J1xuICAgIH0sXG4gICAgdGV4dCxcblxuICAgIGVycm9yID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgLy8gQ2FsbCBlcnJvciB3aGVuIHNvbWV0aGluZyBpcyB3cm9uZy5cbiAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgbmFtZTogICAgJ1N5bnRheEVycm9yJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IG0sXG4gICAgICAgICAgICBhdDogICAgICBhdCxcbiAgICAgICAgICAgIHRleHQ6ICAgIHRleHRcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIFxuICAgIG5leHQgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICAvLyBJZiBhIGMgcGFyYW1ldGVyIGlzIHByb3ZpZGVkLCB2ZXJpZnkgdGhhdCBpdCBtYXRjaGVzIHRoZSBjdXJyZW50IGNoYXJhY3Rlci5cbiAgICAgICAgaWYgKGMgJiYgYyAhPT0gY2gpIHtcbiAgICAgICAgICAgIGVycm9yKFwiRXhwZWN0ZWQgJ1wiICsgYyArIFwiJyBpbnN0ZWFkIG9mICdcIiArIGNoICsgXCInXCIpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBHZXQgdGhlIG5leHQgY2hhcmFjdGVyLiBXaGVuIHRoZXJlIGFyZSBubyBtb3JlIGNoYXJhY3RlcnMsXG4gICAgICAgIC8vIHJldHVybiB0aGUgZW1wdHkgc3RyaW5nLlxuICAgICAgICBcbiAgICAgICAgY2ggPSB0ZXh0LmNoYXJBdChhdCk7XG4gICAgICAgIGF0ICs9IDE7XG4gICAgICAgIHJldHVybiBjaDtcbiAgICB9LFxuICAgIFxuICAgIG51bWJlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUGFyc2UgYSBudW1iZXIgdmFsdWUuXG4gICAgICAgIHZhciBudW1iZXIsXG4gICAgICAgICAgICBzdHJpbmcgPSAnJztcbiAgICAgICAgXG4gICAgICAgIGlmIChjaCA9PT0gJy0nKSB7XG4gICAgICAgICAgICBzdHJpbmcgPSAnLSc7XG4gICAgICAgICAgICBuZXh0KCctJyk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGNoID49ICcwJyAmJiBjaCA8PSAnOScpIHtcbiAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ggPT09ICcuJykge1xuICAgICAgICAgICAgc3RyaW5nICs9ICcuJztcbiAgICAgICAgICAgIHdoaWxlIChuZXh0KCkgJiYgY2ggPj0gJzAnICYmIGNoIDw9ICc5Jykge1xuICAgICAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ggPT09ICdlJyB8fCBjaCA9PT0gJ0UnKSB7XG4gICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICBpZiAoY2ggPT09ICctJyB8fCBjaCA9PT0gJysnKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjaCA+PSAnMCcgJiYgY2ggPD0gJzknKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBudW1iZXIgPSArc3RyaW5nO1xuICAgICAgICBpZiAoIWlzRmluaXRlKG51bWJlcikpIHtcbiAgICAgICAgICAgIGVycm9yKFwiQmFkIG51bWJlclwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudW1iZXI7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIHN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUGFyc2UgYSBzdHJpbmcgdmFsdWUuXG4gICAgICAgIHZhciBoZXgsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgc3RyaW5nID0gJycsXG4gICAgICAgICAgICB1ZmZmZjtcbiAgICAgICAgXG4gICAgICAgIC8vIFdoZW4gcGFyc2luZyBmb3Igc3RyaW5nIHZhbHVlcywgd2UgbXVzdCBsb29rIGZvciBcIiBhbmQgXFwgY2hhcmFjdGVycy5cbiAgICAgICAgaWYgKGNoID09PSAnXCInKSB7XG4gICAgICAgICAgICB3aGlsZSAobmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICd1Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdWZmZmYgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDQ7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhleCA9IHBhcnNlSW50KG5leHQoKSwgMTYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNGaW5pdGUoaGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdWZmZmYgPSB1ZmZmZiAqIDE2ICsgaGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodWZmZmYpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlc2NhcGVlW2NoXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBlc2NhcGVlW2NoXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlcnJvcihcIkJhZCBzdHJpbmdcIik7XG4gICAgfSxcblxuICAgIHdoaXRlID0gZnVuY3Rpb24gKCkge1xuXG4vLyBTa2lwIHdoaXRlc3BhY2UuXG5cbiAgICAgICAgd2hpbGUgKGNoICYmIGNoIDw9ICcgJykge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHdvcmQgPSBmdW5jdGlvbiAoKSB7XG5cbi8vIHRydWUsIGZhbHNlLCBvciBudWxsLlxuXG4gICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICBuZXh0KCd0Jyk7XG4gICAgICAgICAgICBuZXh0KCdyJyk7XG4gICAgICAgICAgICBuZXh0KCd1Jyk7XG4gICAgICAgICAgICBuZXh0KCdlJyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICBuZXh0KCdmJyk7XG4gICAgICAgICAgICBuZXh0KCdhJyk7XG4gICAgICAgICAgICBuZXh0KCdsJyk7XG4gICAgICAgICAgICBuZXh0KCdzJyk7XG4gICAgICAgICAgICBuZXh0KCdlJyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNhc2UgJ24nOlxuICAgICAgICAgICAgbmV4dCgnbicpO1xuICAgICAgICAgICAgbmV4dCgndScpO1xuICAgICAgICAgICAgbmV4dCgnbCcpO1xuICAgICAgICAgICAgbmV4dCgnbCcpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3IoXCJVbmV4cGVjdGVkICdcIiArIGNoICsgXCInXCIpO1xuICAgIH0sXG5cbiAgICB2YWx1ZSwgIC8vIFBsYWNlIGhvbGRlciBmb3IgdGhlIHZhbHVlIGZ1bmN0aW9uLlxuXG4gICAgYXJyYXkgPSBmdW5jdGlvbiAoKSB7XG5cbi8vIFBhcnNlIGFuIGFycmF5IHZhbHVlLlxuXG4gICAgICAgIHZhciBhcnJheSA9IFtdO1xuXG4gICAgICAgIGlmIChjaCA9PT0gJ1snKSB7XG4gICAgICAgICAgICBuZXh0KCdbJyk7XG4gICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnXScpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCddJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5OyAgIC8vIGVtcHR5IGFycmF5XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY2gpIHtcbiAgICAgICAgICAgICAgICBhcnJheS5wdXNoKHZhbHVlKCkpO1xuICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXScpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnXScpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHQoJywnKTtcbiAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVycm9yKFwiQmFkIGFycmF5XCIpO1xuICAgIH0sXG5cbiAgICBvYmplY3QgPSBmdW5jdGlvbiAoKSB7XG5cbi8vIFBhcnNlIGFuIG9iamVjdCB2YWx1ZS5cblxuICAgICAgICB2YXIga2V5LFxuICAgICAgICAgICAgb2JqZWN0ID0ge307XG5cbiAgICAgICAgaWYgKGNoID09PSAneycpIHtcbiAgICAgICAgICAgIG5leHQoJ3snKTtcbiAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICBpZiAoY2ggPT09ICd9Jykge1xuICAgICAgICAgICAgICAgIG5leHQoJ30nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0OyAgIC8vIGVtcHR5IG9iamVjdFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGNoKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICBuZXh0KCc6Jyk7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcignRHVwbGljYXRlIGtleSBcIicgKyBrZXkgKyAnXCInKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2JqZWN0W2tleV0gPSB2YWx1ZSgpO1xuICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnfScpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnfScpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0KCcsJyk7XG4gICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlcnJvcihcIkJhZCBvYmplY3RcIik7XG4gICAgfTtcblxudmFsdWUgPSBmdW5jdGlvbiAoKSB7XG5cbi8vIFBhcnNlIGEgSlNPTiB2YWx1ZS4gSXQgY291bGQgYmUgYW4gb2JqZWN0LCBhbiBhcnJheSwgYSBzdHJpbmcsIGEgbnVtYmVyLFxuLy8gb3IgYSB3b3JkLlxuXG4gICAgd2hpdGUoKTtcbiAgICBzd2l0Y2ggKGNoKSB7XG4gICAgY2FzZSAneyc6XG4gICAgICAgIHJldHVybiBvYmplY3QoKTtcbiAgICBjYXNlICdbJzpcbiAgICAgICAgcmV0dXJuIGFycmF5KCk7XG4gICAgY2FzZSAnXCInOlxuICAgICAgICByZXR1cm4gc3RyaW5nKCk7XG4gICAgY2FzZSAnLSc6XG4gICAgICAgIHJldHVybiBudW1iZXIoKTtcbiAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gY2ggPj0gJzAnICYmIGNoIDw9ICc5JyA/IG51bWJlcigpIDogd29yZCgpO1xuICAgIH1cbn07XG5cbi8vIFJldHVybiB0aGUganNvbl9wYXJzZSBmdW5jdGlvbi4gSXQgd2lsbCBoYXZlIGFjY2VzcyB0byBhbGwgb2YgdGhlIGFib3ZlXG4vLyBmdW5jdGlvbnMgYW5kIHZhcmlhYmxlcy5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc291cmNlLCByZXZpdmVyKSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBcbiAgICB0ZXh0ID0gc291cmNlO1xuICAgIGF0ID0gMDtcbiAgICBjaCA9ICcgJztcbiAgICByZXN1bHQgPSB2YWx1ZSgpO1xuICAgIHdoaXRlKCk7XG4gICAgaWYgKGNoKSB7XG4gICAgICAgIGVycm9yKFwiU3ludGF4IGVycm9yXCIpO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGlzIGEgcmV2aXZlciBmdW5jdGlvbiwgd2UgcmVjdXJzaXZlbHkgd2FsayB0aGUgbmV3IHN0cnVjdHVyZSxcbiAgICAvLyBwYXNzaW5nIGVhY2ggbmFtZS92YWx1ZSBwYWlyIHRvIHRoZSByZXZpdmVyIGZ1bmN0aW9uIGZvciBwb3NzaWJsZVxuICAgIC8vIHRyYW5zZm9ybWF0aW9uLCBzdGFydGluZyB3aXRoIGEgdGVtcG9yYXJ5IHJvb3Qgb2JqZWN0IHRoYXQgaG9sZHMgdGhlIHJlc3VsdFxuICAgIC8vIGluIGFuIGVtcHR5IGtleS4gSWYgdGhlcmUgaXMgbm90IGEgcmV2aXZlciBmdW5jdGlvbiwgd2Ugc2ltcGx5IHJldHVybiB0aGVcbiAgICAvLyByZXN1bHQuXG5cbiAgICByZXR1cm4gdHlwZW9mIHJldml2ZXIgPT09ICdmdW5jdGlvbicgPyAoZnVuY3Rpb24gd2Fsayhob2xkZXIsIGtleSkge1xuICAgICAgICB2YXIgaywgdiwgdmFsdWUgPSBob2xkZXJba2V5XTtcbiAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGZvciAoayBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGspKSB7XG4gICAgICAgICAgICAgICAgICAgIHYgPSB3YWxrKHZhbHVlLCBrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVba10gPSB2O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHZhbHVlW2tdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXZpdmVyLmNhbGwoaG9sZGVyLCBrZXksIHZhbHVlKTtcbiAgICB9KHsnJzogcmVzdWx0fSwgJycpKSA6IHJlc3VsdDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvVXNlcnMvZmFpbmFzaGFsdHMvdHJ1ZmZsZS1kZXYvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvanNvbmlmeS9saWIvcGFyc2UuanNcbi8vIG1vZHVsZSBpZCA9IDQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjeCA9IC9bXFx1MDAwMFxcdTAwYWRcXHUwNjAwLVxcdTA2MDRcXHUwNzBmXFx1MTdiNFxcdTE3YjVcXHUyMDBjLVxcdTIwMGZcXHUyMDI4LVxcdTIwMmZcXHUyMDYwLVxcdTIwNmZcXHVmZWZmXFx1ZmZmMC1cXHVmZmZmXS9nLFxuICAgIGVzY2FwYWJsZSA9IC9bXFxcXFxcXCJcXHgwMC1cXHgxZlxceDdmLVxceDlmXFx1MDBhZFxcdTA2MDAtXFx1MDYwNFxcdTA3MGZcXHUxN2I0XFx1MTdiNVxcdTIwMGMtXFx1MjAwZlxcdTIwMjgtXFx1MjAyZlxcdTIwNjAtXFx1MjA2ZlxcdWZlZmZcXHVmZmYwLVxcdWZmZmZdL2csXG4gICAgZ2FwLFxuICAgIGluZGVudCxcbiAgICBtZXRhID0geyAgICAvLyB0YWJsZSBvZiBjaGFyYWN0ZXIgc3Vic3RpdHV0aW9uc1xuICAgICAgICAnXFxiJzogJ1xcXFxiJyxcbiAgICAgICAgJ1xcdCc6ICdcXFxcdCcsXG4gICAgICAgICdcXG4nOiAnXFxcXG4nLFxuICAgICAgICAnXFxmJzogJ1xcXFxmJyxcbiAgICAgICAgJ1xccic6ICdcXFxccicsXG4gICAgICAgICdcIicgOiAnXFxcXFwiJyxcbiAgICAgICAgJ1xcXFwnOiAnXFxcXFxcXFwnXG4gICAgfSxcbiAgICByZXA7XG5cbmZ1bmN0aW9uIHF1b3RlKHN0cmluZykge1xuICAgIC8vIElmIHRoZSBzdHJpbmcgY29udGFpbnMgbm8gY29udHJvbCBjaGFyYWN0ZXJzLCBubyBxdW90ZSBjaGFyYWN0ZXJzLCBhbmQgbm9cbiAgICAvLyBiYWNrc2xhc2ggY2hhcmFjdGVycywgdGhlbiB3ZSBjYW4gc2FmZWx5IHNsYXAgc29tZSBxdW90ZXMgYXJvdW5kIGl0LlxuICAgIC8vIE90aGVyd2lzZSB3ZSBtdXN0IGFsc28gcmVwbGFjZSB0aGUgb2ZmZW5kaW5nIGNoYXJhY3RlcnMgd2l0aCBzYWZlIGVzY2FwZVxuICAgIC8vIHNlcXVlbmNlcy5cbiAgICBcbiAgICBlc2NhcGFibGUubGFzdEluZGV4ID0gMDtcbiAgICByZXR1cm4gZXNjYXBhYmxlLnRlc3Qoc3RyaW5nKSA/ICdcIicgKyBzdHJpbmcucmVwbGFjZShlc2NhcGFibGUsIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBjID0gbWV0YVthXTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBjID09PSAnc3RyaW5nJyA/IGMgOlxuICAgICAgICAgICAgJ1xcXFx1JyArICgnMDAwMCcgKyBhLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCk7XG4gICAgfSkgKyAnXCInIDogJ1wiJyArIHN0cmluZyArICdcIic7XG59XG5cbmZ1bmN0aW9uIHN0cihrZXksIGhvbGRlcikge1xuICAgIC8vIFByb2R1Y2UgYSBzdHJpbmcgZnJvbSBob2xkZXJba2V5XS5cbiAgICB2YXIgaSwgICAgICAgICAgLy8gVGhlIGxvb3AgY291bnRlci5cbiAgICAgICAgaywgICAgICAgICAgLy8gVGhlIG1lbWJlciBrZXkuXG4gICAgICAgIHYsICAgICAgICAgIC8vIFRoZSBtZW1iZXIgdmFsdWUuXG4gICAgICAgIGxlbmd0aCxcbiAgICAgICAgbWluZCA9IGdhcCxcbiAgICAgICAgcGFydGlhbCxcbiAgICAgICAgdmFsdWUgPSBob2xkZXJba2V5XTtcbiAgICBcbiAgICAvLyBJZiB0aGUgdmFsdWUgaGFzIGEgdG9KU09OIG1ldGhvZCwgY2FsbCBpdCB0byBvYnRhaW4gYSByZXBsYWNlbWVudCB2YWx1ZS5cbiAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTihrZXkpO1xuICAgIH1cbiAgICBcbiAgICAvLyBJZiB3ZSB3ZXJlIGNhbGxlZCB3aXRoIGEgcmVwbGFjZXIgZnVuY3Rpb24sIHRoZW4gY2FsbCB0aGUgcmVwbGFjZXIgdG9cbiAgICAvLyBvYnRhaW4gYSByZXBsYWNlbWVudCB2YWx1ZS5cbiAgICBpZiAodHlwZW9mIHJlcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YWx1ZSA9IHJlcC5jYWxsKGhvbGRlciwga2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIFxuICAgIC8vIFdoYXQgaGFwcGVucyBuZXh0IGRlcGVuZHMgb24gdGhlIHZhbHVlJ3MgdHlwZS5cbiAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgcmV0dXJuIHF1b3RlKHZhbHVlKTtcbiAgICAgICAgXG4gICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAvLyBKU09OIG51bWJlcnMgbXVzdCBiZSBmaW5pdGUuIEVuY29kZSBub24tZmluaXRlIG51bWJlcnMgYXMgbnVsbC5cbiAgICAgICAgICAgIHJldHVybiBpc0Zpbml0ZSh2YWx1ZSkgPyBTdHJpbmcodmFsdWUpIDogJ251bGwnO1xuICAgICAgICBcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIGNhc2UgJ251bGwnOlxuICAgICAgICAgICAgLy8gSWYgdGhlIHZhbHVlIGlzIGEgYm9vbGVhbiBvciBudWxsLCBjb252ZXJ0IGl0IHRvIGEgc3RyaW5nLiBOb3RlOlxuICAgICAgICAgICAgLy8gdHlwZW9mIG51bGwgZG9lcyBub3QgcHJvZHVjZSAnbnVsbCcuIFRoZSBjYXNlIGlzIGluY2x1ZGVkIGhlcmUgaW5cbiAgICAgICAgICAgIC8vIHRoZSByZW1vdGUgY2hhbmNlIHRoYXQgdGhpcyBnZXRzIGZpeGVkIHNvbWVkYXkuXG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgIFxuICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgaWYgKCF2YWx1ZSkgcmV0dXJuICdudWxsJztcbiAgICAgICAgICAgIGdhcCArPSBpbmRlbnQ7XG4gICAgICAgICAgICBwYXJ0aWFsID0gW107XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEFycmF5LmlzQXJyYXlcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydGlhbFtpXSA9IHN0cihpLCB2YWx1ZSkgfHwgJ251bGwnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBKb2luIGFsbCBvZiB0aGUgZWxlbWVudHMgdG9nZXRoZXIsIHNlcGFyYXRlZCB3aXRoIGNvbW1hcywgYW5kXG4gICAgICAgICAgICAgICAgLy8gd3JhcCB0aGVtIGluIGJyYWNrZXRzLlxuICAgICAgICAgICAgICAgIHYgPSBwYXJ0aWFsLmxlbmd0aCA9PT0gMCA/ICdbXScgOiBnYXAgP1xuICAgICAgICAgICAgICAgICAgICAnW1xcbicgKyBnYXAgKyBwYXJ0aWFsLmpvaW4oJyxcXG4nICsgZ2FwKSArICdcXG4nICsgbWluZCArICddJyA6XG4gICAgICAgICAgICAgICAgICAgICdbJyArIHBhcnRpYWwuam9pbignLCcpICsgJ10nO1xuICAgICAgICAgICAgICAgIGdhcCA9IG1pbmQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIElmIHRoZSByZXBsYWNlciBpcyBhbiBhcnJheSwgdXNlIGl0IHRvIHNlbGVjdCB0aGUgbWVtYmVycyB0byBiZVxuICAgICAgICAgICAgLy8gc3RyaW5naWZpZWQuXG4gICAgICAgICAgICBpZiAocmVwICYmIHR5cGVvZiByZXAgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gcmVwLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgayA9IHJlcFtpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHN0cihrLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWwucHVzaChxdW90ZShrKSArIChnYXAgPyAnOiAnIDogJzonKSArIHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBpdGVyYXRlIHRocm91Z2ggYWxsIG9mIHRoZSBrZXlzIGluIHRoZSBvYmplY3QuXG4gICAgICAgICAgICAgICAgZm9yIChrIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gc3RyKGssIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbC5wdXNoKHF1b3RlKGspICsgKGdhcCA/ICc6ICcgOiAnOicpICsgdik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgLy8gSm9pbiBhbGwgb2YgdGhlIG1lbWJlciB0ZXh0cyB0b2dldGhlciwgc2VwYXJhdGVkIHdpdGggY29tbWFzLFxuICAgICAgICAvLyBhbmQgd3JhcCB0aGVtIGluIGJyYWNlcy5cblxuICAgICAgICB2ID0gcGFydGlhbC5sZW5ndGggPT09IDAgPyAne30nIDogZ2FwID9cbiAgICAgICAgICAgICd7XFxuJyArIGdhcCArIHBhcnRpYWwuam9pbignLFxcbicgKyBnYXApICsgJ1xcbicgKyBtaW5kICsgJ30nIDpcbiAgICAgICAgICAgICd7JyArIHBhcnRpYWwuam9pbignLCcpICsgJ30nO1xuICAgICAgICBnYXAgPSBtaW5kO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlLCByZXBsYWNlciwgc3BhY2UpIHtcbiAgICB2YXIgaTtcbiAgICBnYXAgPSAnJztcbiAgICBpbmRlbnQgPSAnJztcbiAgICBcbiAgICAvLyBJZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGlzIGEgbnVtYmVyLCBtYWtlIGFuIGluZGVudCBzdHJpbmcgY29udGFpbmluZyB0aGF0XG4gICAgLy8gbWFueSBzcGFjZXMuXG4gICAgaWYgKHR5cGVvZiBzcGFjZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNwYWNlOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGluZGVudCArPSAnICc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgdGhlIHNwYWNlIHBhcmFtZXRlciBpcyBhIHN0cmluZywgaXQgd2lsbCBiZSB1c2VkIGFzIHRoZSBpbmRlbnQgc3RyaW5nLlxuICAgIGVsc2UgaWYgKHR5cGVvZiBzcGFjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaW5kZW50ID0gc3BhY2U7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUgaXMgYSByZXBsYWNlciwgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIGFycmF5LlxuICAgIC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3IuXG4gICAgcmVwID0gcmVwbGFjZXI7XG4gICAgaWYgKHJlcGxhY2VyICYmIHR5cGVvZiByZXBsYWNlciAhPT0gJ2Z1bmN0aW9uJ1xuICAgICYmICh0eXBlb2YgcmVwbGFjZXIgIT09ICdvYmplY3QnIHx8IHR5cGVvZiByZXBsYWNlci5sZW5ndGggIT09ICdudW1iZXInKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0pTT04uc3RyaW5naWZ5Jyk7XG4gICAgfVxuICAgIFxuICAgIC8vIE1ha2UgYSBmYWtlIHJvb3Qgb2JqZWN0IGNvbnRhaW5pbmcgb3VyIHZhbHVlIHVuZGVyIHRoZSBrZXkgb2YgJycuXG4gICAgLy8gUmV0dXJuIHRoZSByZXN1bHQgb2Ygc3RyaW5naWZ5aW5nIHRoZSB2YWx1ZS5cbiAgICByZXR1cm4gc3RyKCcnLCB7Jyc6IHZhbHVlfSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL1VzZXJzL2ZhaW5hc2hhbHRzL3RydWZmbGUtZGV2L3RydWZmbGUvbm9kZV9tb2R1bGVzL2pzb25pZnkvbGliL3N0cmluZ2lmeS5qc1xuLy8gbW9kdWxlIGlkID0gNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidHJ1ZmZsZS1zb2xpZGl0eS11dGlsc1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInRydWZmbGUtc29saWRpdHktdXRpbHNcIlxuLy8gbW9kdWxlIGlkID0gNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidHJ1ZmZsZS1jb2RlLXV0aWxzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwidHJ1ZmZsZS1jb2RlLXV0aWxzXCJcbi8vIG1vZHVsZSBpZCA9IDQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xyXG4vLyBBbiBhdWdtZW50ZWQgQVZMIFRyZWUgd2hlcmUgZWFjaCBub2RlIG1haW50YWlucyBhIGxpc3Qgb2YgcmVjb3JkcyBhbmQgdGhlaXIgc2VhcmNoIGludGVydmFscy5cclxuLy8gUmVjb3JkIGlzIGNvbXBvc2VkIG9mIGFuIGludGVydmFsIGFuZCBpdHMgdW5kZXJseWluZyBkYXRhLCBzZW50IGJ5IGEgY2xpZW50LiBUaGlzIGFsbG93cyB0aGVcclxuLy8gaW50ZXJ2YWwgdHJlZSB0byBoYXZlIHRoZSBzYW1lIGludGVydmFsIGluc2VydGVkIG11bHRpcGxlIHRpbWVzLCBhcyBsb25nIGl0cyBkYXRhIGlzIGRpZmZlcmVudC5cclxuLy8gQm90aCBpbnNlcnRpb24gYW5kIGRlbGV0aW9uIHJlcXVpcmUgTyhsb2cgbikgdGltZS4gU2VhcmNoaW5nIHJlcXVpcmVzIE8oaypsb2duKSB0aW1lLCB3aGVyZSBga2BcclxuLy8gaXMgdGhlIG51bWJlciBvZiBpbnRlcnZhbHMgaW4gdGhlIG91dHB1dCBsaXN0LlxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBpc1NhbWUgPSByZXF1aXJlKFwic2hhbGxvd2VxdWFsXCIpO1xyXG5mdW5jdGlvbiBoZWlnaHQobm9kZSkge1xyXG4gICAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBub2RlLmhlaWdodDtcclxuICAgIH1cclxufVxyXG52YXIgTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE5vZGUoaW50ZXJ2YWxUcmVlLCByZWNvcmQpIHtcclxuICAgICAgICB0aGlzLmludGVydmFsVHJlZSA9IGludGVydmFsVHJlZTtcclxuICAgICAgICB0aGlzLnJlY29yZHMgPSBbXTtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IDA7XHJcbiAgICAgICAgdGhpcy5rZXkgPSByZWNvcmQubG93O1xyXG4gICAgICAgIHRoaXMubWF4ID0gcmVjb3JkLmhpZ2g7XHJcbiAgICAgICAgLy8gU2F2ZSB0aGUgYXJyYXkgb2YgYWxsIHJlY29yZHMgd2l0aCB0aGUgc2FtZSBrZXkgZm9yIHRoaXMgbm9kZVxyXG4gICAgICAgIHRoaXMucmVjb3Jkcy5wdXNoKHJlY29yZCk7XHJcbiAgICB9XHJcbiAgICAvLyBHZXRzIHRoZSBoaWdoZXN0IHJlY29yZC5oaWdoIHZhbHVlIGZvciB0aGlzIG5vZGVcclxuICAgIE5vZGUucHJvdG90eXBlLmdldE5vZGVIaWdoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBoaWdoID0gdGhpcy5yZWNvcmRzWzBdLmhpZ2g7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLnJlY29yZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucmVjb3Jkc1tpXS5oaWdoID4gaGlnaCkge1xyXG4gICAgICAgICAgICAgICAgaGlnaCA9IHRoaXMucmVjb3Jkc1tpXS5oaWdoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBoaWdoO1xyXG4gICAgfTtcclxuICAgIC8vIFVwZGF0ZXMgaGVpZ2h0IHZhbHVlIG9mIHRoZSBub2RlLiBDYWxsZWQgZHVyaW5nIGluc2VydGlvbiwgcmViYWxhbmNlLCByZW1vdmFsXHJcbiAgICBOb2RlLnByb3RvdHlwZS51cGRhdGVIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBNYXRoLm1heChoZWlnaHQodGhpcy5sZWZ0KSwgaGVpZ2h0KHRoaXMucmlnaHQpKSArIDE7XHJcbiAgICB9O1xyXG4gICAgLy8gVXBkYXRlcyB0aGUgbWF4IHZhbHVlIG9mIGFsbCB0aGUgcGFyZW50cyBhZnRlciBpbnNlcnRpbmcgaW50byBhbHJlYWR5IGV4aXN0aW5nIG5vZGUsIGFzIHdlbGwgYXNcclxuICAgIC8vIHJlbW92aW5nIHRoZSBub2RlIGNvbXBsZXRlbHkgb3IgcmVtb3ZpbmcgdGhlIHJlY29yZCBvZiBhbiBhbHJlYWR5IGV4aXN0aW5nIG5vZGUuIFN0YXJ0cyB3aXRoXHJcbiAgICAvLyB0aGUgcGFyZW50IG9mIGFuIGFmZmVjdGVkIG5vZGUgYW5kIGJ1YmJsZXMgdXAgdG8gcm9vdFxyXG4gICAgTm9kZS5wcm90b3R5cGUudXBkYXRlTWF4T2ZQYXJlbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdGhpc0hpZ2ggPSB0aGlzLmdldE5vZGVIaWdoKCk7XHJcbiAgICAgICAgaWYgKHRoaXMubGVmdCAhPT0gdW5kZWZpbmVkICYmIHRoaXMucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IE1hdGgubWF4KE1hdGgubWF4KHRoaXMubGVmdC5tYXgsIHRoaXMucmlnaHQubWF4KSwgdGhpc0hpZ2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmxlZnQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnJpZ2h0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXggPSBNYXRoLm1heCh0aGlzLmxlZnQubWF4LCB0aGlzSGlnaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMubGVmdCA9PT0gdW5kZWZpbmVkICYmIHRoaXMucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IE1hdGgubWF4KHRoaXMucmlnaHQubWF4LCB0aGlzSGlnaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IHRoaXNIaWdoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5wYXJlbnQudXBkYXRlTWF4T2ZQYXJlbnRzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBMZWZ0LUxlZnQgY2FzZTpcclxuICBcclxuICAgICAgICAgICB6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5XHJcbiAgICAgICAgICAvIFxcICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvICAgXFxcclxuICAgICAgICAgeSAgIFQ0ICAgICAgUmlnaHQgUm90YXRlICh6KSAgICAgICAgICB4ICAgICB6XHJcbiAgICAgICAgLyBcXCAgICAgICAgICAtIC0gLSAtIC0gLSAtIC0gLT4gICAgICAgLyBcXCAgIC8gXFxcclxuICAgICAgIHggICBUMyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVDEgVDIgVDMgVDRcclxuICAgICAgLyBcXFxyXG4gICAgVDEgICBUMlxyXG4gIFxyXG4gICAgTGVmdC1SaWdodCBjYXNlOlxyXG4gIFxyXG4gICAgICAgICB6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHogICAgICAgICAgICAgICAgICAgICAgICAgICB4XHJcbiAgICAgICAgLyBcXCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyBcXCAgICAgICAgICAgICAgICAgICAgICAgIC8gICBcXFxyXG4gICAgICAgeSAgIFQ0ICBMZWZ0IFJvdGF0ZSAoeSkgICAgICAgICB4ICBUNCAgUmlnaHQgUm90YXRlKHopICAgICB5ICAgICB6XHJcbiAgICAgIC8gXFwgICAgICAtIC0gLSAtIC0gLSAtIC0gLT4gICAgIC8gXFwgICAgICAtIC0gLSAtIC0gLSAtIC0+ICAvIFxcICAgLyBcXFxyXG4gICAgVDEgICB4ICAgICAgICAgICAgICAgICAgICAgICAgICAgeSAgVDMgICAgICAgICAgICAgICAgICAgICAgVDEgVDIgVDMgVDRcclxuICAgICAgICAvIFxcICAgICAgICAgICAgICAgICAgICAgICAgIC8gXFxcclxuICAgICAgVDIgICBUMyAgICAgICAgICAgICAgICAgICAgICBUMSBUMlxyXG4gICAgKi9cclxuICAgIC8vIEhhbmRsZXMgTGVmdC1MZWZ0IGNhc2UgYW5kIExlZnQtUmlnaHQgY2FzZSBhZnRlciByZWJhbGFuY2luZyBBVkwgdHJlZVxyXG4gICAgTm9kZS5wcm90b3R5cGUuX3VwZGF0ZU1heEFmdGVyUmlnaHRSb3RhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xyXG4gICAgICAgIHZhciBsZWZ0ID0gcGFyZW50LmxlZnQ7XHJcbiAgICAgICAgLy8gVXBkYXRlIG1heCBvZiBsZWZ0IHNpYmxpbmcgKHggaW4gZmlyc3QgY2FzZSwgeSBpbiBzZWNvbmQpXHJcbiAgICAgICAgdmFyIHRoaXNQYXJlbnRMZWZ0SGlnaCA9IGxlZnQuZ2V0Tm9kZUhpZ2goKTtcclxuICAgICAgICBpZiAobGVmdC5sZWZ0ID09PSB1bmRlZmluZWQgJiYgbGVmdC5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGxlZnQubWF4ID0gTWF0aC5tYXgodGhpc1BhcmVudExlZnRIaWdoLCBsZWZ0LnJpZ2h0Lm1heCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGxlZnQubGVmdCAhPT0gdW5kZWZpbmVkICYmIGxlZnQucmlnaHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBsZWZ0Lm1heCA9IE1hdGgubWF4KHRoaXNQYXJlbnRMZWZ0SGlnaCwgbGVmdC5sZWZ0Lm1heCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGxlZnQubGVmdCA9PT0gdW5kZWZpbmVkICYmIGxlZnQucmlnaHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBsZWZ0Lm1heCA9IHRoaXNQYXJlbnRMZWZ0SGlnaDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxlZnQubWF4ID0gTWF0aC5tYXgoTWF0aC5tYXgobGVmdC5sZWZ0Lm1heCwgbGVmdC5yaWdodC5tYXgpLCB0aGlzUGFyZW50TGVmdEhpZ2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBVcGRhdGUgbWF4IG9mIGl0c2VsZiAoeilcclxuICAgICAgICB2YXIgdGhpc0hpZ2ggPSB0aGlzLmdldE5vZGVIaWdoKCk7XHJcbiAgICAgICAgaWYgKHRoaXMubGVmdCA9PT0gdW5kZWZpbmVkICYmIHRoaXMucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IE1hdGgubWF4KHRoaXNIaWdoLCB0aGlzLnJpZ2h0Lm1heCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMubGVmdCAhPT0gdW5kZWZpbmVkICYmIHRoaXMucmlnaHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IE1hdGgubWF4KHRoaXNIaWdoLCB0aGlzLmxlZnQubWF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5sZWZ0ID09PSB1bmRlZmluZWQgJiYgdGhpcy5yaWdodCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF4ID0gdGhpc0hpZ2g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IE1hdGgubWF4KE1hdGgubWF4KHRoaXMubGVmdC5tYXgsIHRoaXMucmlnaHQubWF4KSwgdGhpc0hpZ2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBVcGRhdGUgbWF4IG9mIHBhcmVudCAoeSBpbiBmaXJzdCBjYXNlLCB4IGluIHNlY29uZClcclxuICAgICAgICBwYXJlbnQubWF4ID0gTWF0aC5tYXgoTWF0aC5tYXgocGFyZW50LmxlZnQubWF4LCBwYXJlbnQucmlnaHQubWF4KSwgcGFyZW50LmdldE5vZGVIaWdoKCkpO1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBSaWdodC1SaWdodCBjYXNlOlxyXG4gIFxyXG4gICAgICB6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlcclxuICAgICAvIFxcICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8gICBcXFxyXG4gICAgVDEgIHkgICAgIExlZnQgUm90YXRlKHopICAgICAgIHogICAgIHhcclxuICAgICAgIC8gXFwgICAtIC0gLSAtIC0gLSAtIC0+ICAgICAvIFxcICAgLyBcXFxyXG4gICAgICBUMiAgeCAgICAgICAgICAgICAgICAgICAgICBUMSBUMiBUMyBUNFxyXG4gICAgICAgICAvIFxcXHJcbiAgICAgICAgVDMgVDRcclxuICBcclxuICAgIFJpZ2h0LUxlZnQgY2FzZTpcclxuICBcclxuICAgICAgIHogICAgICAgICAgICAgICAgICAgICAgICAgICAgeiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4XHJcbiAgICAgIC8gXFwgICAgICAgICAgICAgICAgICAgICAgICAgIC8gXFwgICAgICAgICAgICAgICAgICAgICAgICAgLyAgIFxcXHJcbiAgICAgVDEgIHkgICBSaWdodCBSb3RhdGUgKHkpICAgICBUMSAgeCAgICAgIExlZnQgUm90YXRlKHopICAgeiAgICAgeVxyXG4gICAgICAgIC8gXFwgIC0gLSAtIC0gLSAtIC0gLSAtPiAgICAgIC8gXFwgICAtIC0gLSAtIC0gLSAtIC0+ICAvIFxcICAgLyBcXFxyXG4gICAgICAgeCAgVDQgICAgICAgICAgICAgICAgICAgICAgICBUMiAgeSAgICAgICAgICAgICAgICAgICBUMSBUMiBUMyBUNFxyXG4gICAgICAvIFxcICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyBcXFxyXG4gICAgVDIgICBUMyAgICAgICAgICAgICAgICAgICAgICAgICAgIFQzIFQ0XHJcbiAgICAqL1xyXG4gICAgLy8gSGFuZGxlcyBSaWdodC1SaWdodCBjYXNlIGFuZCBSaWdodC1MZWZ0IGNhc2UgaW4gcmViYWxhbmNpbmcgQVZMIHRyZWVcclxuICAgIE5vZGUucHJvdG90eXBlLl91cGRhdGVNYXhBZnRlckxlZnRSb3RhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xyXG4gICAgICAgIHZhciByaWdodCA9IHBhcmVudC5yaWdodDtcclxuICAgICAgICAvLyBVcGRhdGUgbWF4IG9mIHJpZ2h0IHNpYmxpbmcgKHggaW4gZmlyc3QgY2FzZSwgeSBpbiBzZWNvbmQpXHJcbiAgICAgICAgdmFyIHRoaXNQYXJlbnRSaWdodEhpZ2ggPSByaWdodC5nZXROb2RlSGlnaCgpO1xyXG4gICAgICAgIGlmIChyaWdodC5sZWZ0ID09PSB1bmRlZmluZWQgJiYgcmlnaHQucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByaWdodC5tYXggPSBNYXRoLm1heCh0aGlzUGFyZW50UmlnaHRIaWdoLCByaWdodC5yaWdodC5tYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChyaWdodC5sZWZ0ICE9PSB1bmRlZmluZWQgJiYgcmlnaHQucmlnaHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByaWdodC5tYXggPSBNYXRoLm1heCh0aGlzUGFyZW50UmlnaHRIaWdoLCByaWdodC5sZWZ0Lm1heCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHJpZ2h0LmxlZnQgPT09IHVuZGVmaW5lZCAmJiByaWdodC5yaWdodCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJpZ2h0Lm1heCA9IHRoaXNQYXJlbnRSaWdodEhpZ2g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByaWdodC5tYXggPSBNYXRoLm1heChNYXRoLm1heChyaWdodC5sZWZ0Lm1heCwgcmlnaHQucmlnaHQubWF4KSwgdGhpc1BhcmVudFJpZ2h0SGlnaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFVwZGF0ZSBtYXggb2YgaXRzZWxmICh6KVxyXG4gICAgICAgIHZhciB0aGlzSGlnaCA9IHRoaXMuZ2V0Tm9kZUhpZ2goKTtcclxuICAgICAgICBpZiAodGhpcy5sZWZ0ID09PSB1bmRlZmluZWQgJiYgdGhpcy5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF4ID0gTWF0aC5tYXgodGhpc0hpZ2gsIHRoaXMucmlnaHQubWF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5sZWZ0ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5yaWdodCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF4ID0gTWF0aC5tYXgodGhpc0hpZ2gsIHRoaXMubGVmdC5tYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmxlZnQgPT09IHVuZGVmaW5lZCAmJiB0aGlzLnJpZ2h0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXggPSB0aGlzSGlnaDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF4ID0gTWF0aC5tYXgoTWF0aC5tYXgodGhpcy5sZWZ0Lm1heCwgdGhpcy5yaWdodC5tYXgpLCB0aGlzSGlnaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFVwZGF0ZSBtYXggb2YgcGFyZW50ICh5IGluIGZpcnN0IGNhc2UsIHggaW4gc2Vjb25kKVxyXG4gICAgICAgIHBhcmVudC5tYXggPSBNYXRoLm1heChNYXRoLm1heChwYXJlbnQubGVmdC5tYXgsIHJpZ2h0Lm1heCksIHBhcmVudC5nZXROb2RlSGlnaCgpKTtcclxuICAgIH07XHJcbiAgICBOb2RlLnByb3RvdHlwZS5fbGVmdFJvdGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmlnaHRDaGlsZCA9IHRoaXMucmlnaHQ7XHJcbiAgICAgICAgcmlnaHRDaGlsZC5wYXJlbnQgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICBpZiAocmlnaHRDaGlsZC5wYXJlbnQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLmludGVydmFsVHJlZS5yb290ID0gcmlnaHRDaGlsZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChyaWdodENoaWxkLnBhcmVudC5sZWZ0ID09PSB0aGlzKSB7XHJcbiAgICAgICAgICAgICAgICByaWdodENoaWxkLnBhcmVudC5sZWZ0ID0gcmlnaHRDaGlsZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChyaWdodENoaWxkLnBhcmVudC5yaWdodCA9PT0gdGhpcykge1xyXG4gICAgICAgICAgICAgICAgcmlnaHRDaGlsZC5wYXJlbnQucmlnaHQgPSByaWdodENoaWxkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmlnaHQgPSByaWdodENoaWxkLmxlZnQ7XHJcbiAgICAgICAgaWYgKHRoaXMucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLnJpZ2h0LnBhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJpZ2h0Q2hpbGQubGVmdCA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSByaWdodENoaWxkO1xyXG4gICAgICAgIHRoaXMudXBkYXRlSGVpZ2h0KCk7XHJcbiAgICAgICAgcmlnaHRDaGlsZC51cGRhdGVIZWlnaHQoKTtcclxuICAgIH07XHJcbiAgICBOb2RlLnByb3RvdHlwZS5fcmlnaHRSb3RhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGxlZnRDaGlsZCA9IHRoaXMubGVmdDtcclxuICAgICAgICBsZWZ0Q2hpbGQucGFyZW50ID0gdGhpcy5wYXJlbnQ7XHJcbiAgICAgICAgaWYgKGxlZnRDaGlsZC5wYXJlbnQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLmludGVydmFsVHJlZS5yb290ID0gbGVmdENoaWxkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGxlZnRDaGlsZC5wYXJlbnQubGVmdCA9PT0gdGhpcykge1xyXG4gICAgICAgICAgICAgICAgbGVmdENoaWxkLnBhcmVudC5sZWZ0ID0gbGVmdENoaWxkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGxlZnRDaGlsZC5wYXJlbnQucmlnaHQgPT09IHRoaXMpIHtcclxuICAgICAgICAgICAgICAgIGxlZnRDaGlsZC5wYXJlbnQucmlnaHQgPSBsZWZ0Q2hpbGQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdENoaWxkLnJpZ2h0O1xyXG4gICAgICAgIGlmICh0aGlzLmxlZnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLmxlZnQucGFyZW50ID0gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgbGVmdENoaWxkLnJpZ2h0ID0gdGhpcztcclxuICAgICAgICB0aGlzLnBhcmVudCA9IGxlZnRDaGlsZDtcclxuICAgICAgICB0aGlzLnVwZGF0ZUhlaWdodCgpO1xyXG4gICAgICAgIGxlZnRDaGlsZC51cGRhdGVIZWlnaHQoKTtcclxuICAgIH07XHJcbiAgICAvLyBSZWJhbGFuY2VzIHRoZSB0cmVlIGlmIHRoZSBoZWlnaHQgdmFsdWUgYmV0d2VlbiB0d28gbm9kZXMgb2YgdGhlIHNhbWUgcGFyZW50IGlzIGdyZWF0ZXIgdGhhblxyXG4gICAgLy8gdHdvLiBUaGVyZSBhcmUgNCBjYXNlcyB0aGF0IGNhbiBoYXBwZW4gd2hpY2ggYXJlIG91dGxpbmVkIGluIHRoZSBncmFwaGljcyBhYm92ZVxyXG4gICAgTm9kZS5wcm90b3R5cGUuX3JlYmFsYW5jZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoaGVpZ2h0KHRoaXMubGVmdCkgPj0gMiArIGhlaWdodCh0aGlzLnJpZ2h0KSkge1xyXG4gICAgICAgICAgICB2YXIgbGVmdCA9IHRoaXMubGVmdDtcclxuICAgICAgICAgICAgaWYgKGhlaWdodChsZWZ0LmxlZnQpID49IGhlaWdodChsZWZ0LnJpZ2h0KSkge1xyXG4gICAgICAgICAgICAgICAgLy8gTGVmdC1MZWZ0IGNhc2VcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JpZ2h0Um90YXRlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVNYXhBZnRlclJpZ2h0Um90YXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBMZWZ0LVJpZ2h0IGNhc2VcclxuICAgICAgICAgICAgICAgIGxlZnQuX2xlZnRSb3RhdGUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JpZ2h0Um90YXRlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVNYXhBZnRlclJpZ2h0Um90YXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaGVpZ2h0KHRoaXMucmlnaHQpID49IDIgKyBoZWlnaHQodGhpcy5sZWZ0KSkge1xyXG4gICAgICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLnJpZ2h0O1xyXG4gICAgICAgICAgICBpZiAoaGVpZ2h0KHJpZ2h0LnJpZ2h0KSA+PSBoZWlnaHQocmlnaHQubGVmdCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFJpZ2h0LVJpZ2h0IGNhc2VcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xlZnRSb3RhdGUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZU1heEFmdGVyTGVmdFJvdGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gUmlnaHQtTGVmdCBjYXNlXHJcbiAgICAgICAgICAgICAgICByaWdodC5fcmlnaHRSb3RhdGUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xlZnRSb3RhdGUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZU1heEFmdGVyTGVmdFJvdGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE5vZGUucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcclxuICAgICAgICBpZiAocmVjb3JkLmxvdyA8IHRoaXMua2V5KSB7XHJcbiAgICAgICAgICAgIC8vIEluc2VydCBpbnRvIGxlZnQgc3VidHJlZVxyXG4gICAgICAgICAgICBpZiAodGhpcy5sZWZ0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGVmdCA9IG5ldyBOb2RlKHRoaXMuaW50ZXJ2YWxUcmVlLCByZWNvcmQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sZWZ0LnBhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxlZnQuaW5zZXJ0KHJlY29yZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEluc2VydCBpbnRvIHJpZ2h0IHN1YnRyZWVcclxuICAgICAgICAgICAgaWYgKHRoaXMucmlnaHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yaWdodCA9IG5ldyBOb2RlKHRoaXMuaW50ZXJ2YWxUcmVlLCByZWNvcmQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yaWdodC5wYXJlbnQgPSB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yaWdodC5pbnNlcnQocmVjb3JkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBVcGRhdGUgdGhlIG1heCB2YWx1ZSBvZiB0aGlzIGFuY2VzdG9yIGlmIG5lZWRlZFxyXG4gICAgICAgIGlmICh0aGlzLm1heCA8IHJlY29yZC5oaWdoKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF4ID0gcmVjb3JkLmhpZ2g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFVwZGF0ZSBoZWlnaHQgb2YgZWFjaCBub2RlXHJcbiAgICAgICAgdGhpcy51cGRhdGVIZWlnaHQoKTtcclxuICAgICAgICAvLyBSZWJhbGFuY2UgdGhlIHRyZWUgdG8gZW5zdXJlIGFsbCBvcGVyYXRpb25zIGFyZSBleGVjdXRlZCBpbiBPKGxvZ24pIHRpbWUuIFRoaXMgaXMgZXNwZWNpYWxseVxyXG4gICAgICAgIC8vIGltcG9ydGFudCBpbiBzZWFyY2hpbmcsIGFzIHRoZSB0cmVlIGhhcyBhIGhpZ2ggY2hhbmNlIG9mIGRlZ2VuZXJhdGluZyB3aXRob3V0IHRoZSByZWJhbGFuY2luZ1xyXG4gICAgICAgIHRoaXMuX3JlYmFsYW5jZSgpO1xyXG4gICAgfTtcclxuICAgIE5vZGUucHJvdG90eXBlLl9nZXRPdmVybGFwcGluZ1JlY29yZHMgPSBmdW5jdGlvbiAoY3VycmVudE5vZGUsIGxvdywgaGlnaCkge1xyXG4gICAgICAgIGlmIChjdXJyZW50Tm9kZS5rZXkgPD0gaGlnaCAmJiBsb3cgPD0gY3VycmVudE5vZGUuZ2V0Tm9kZUhpZ2goKSkge1xyXG4gICAgICAgICAgICAvLyBOb2RlcyBhcmUgb3ZlcmxhcHBpbmcsIGNoZWNrIGlmIGluZGl2aWR1YWwgcmVjb3JkcyBpbiB0aGUgbm9kZSBhcmUgb3ZlcmxhcHBpbmdcclxuICAgICAgICAgICAgdmFyIHRlbXBSZXN1bHRzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3VycmVudE5vZGUucmVjb3Jkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlLnJlY29yZHNbaV0uaGlnaCA+PSBsb3cpIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wUmVzdWx0cy5wdXNoKGN1cnJlbnROb2RlLnJlY29yZHNbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0ZW1wUmVzdWx0cztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfTtcclxuICAgIE5vZGUucHJvdG90eXBlLnNlYXJjaCA9IGZ1bmN0aW9uIChsb3csIGhpZ2gpIHtcclxuICAgICAgICAvLyBEb24ndCBzZWFyY2ggbm9kZXMgdGhhdCBkb24ndCBleGlzdFxyXG4gICAgICAgIGlmICh0aGlzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbGVmdFNlYXJjaCA9IFtdO1xyXG4gICAgICAgIHZhciBvd25TZWFyY2ggPSBbXTtcclxuICAgICAgICB2YXIgcmlnaHRTZWFyY2ggPSBbXTtcclxuICAgICAgICAvLyBJZiBpbnRlcnZhbCBpcyB0byB0aGUgcmlnaHQgb2YgdGhlIHJpZ2h0bW9zdCBwb2ludCBvZiBhbnkgaW50ZXJ2YWwgaW4gdGhpcyBub2RlIGFuZCBhbGwgaXRzXHJcbiAgICAgICAgLy8gY2hpbGRyZW4sIHRoZXJlIHdvbid0IGJlIGFueSBtYXRjaGVzXHJcbiAgICAgICAgaWYgKGxvdyA+IHRoaXMubWF4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU2VhcmNoIGxlZnQgY2hpbGRyZW5cclxuICAgICAgICBpZiAodGhpcy5sZWZ0ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5sZWZ0Lm1heCA+PSBsb3cpIHtcclxuICAgICAgICAgICAgbGVmdFNlYXJjaCA9IHRoaXMubGVmdC5zZWFyY2gobG93LCBoaWdoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2hlY2sgdGhpcyBub2RlXHJcbiAgICAgICAgb3duU2VhcmNoID0gdGhpcy5fZ2V0T3ZlcmxhcHBpbmdSZWNvcmRzKHRoaXMsIGxvdywgaGlnaCk7XHJcbiAgICAgICAgLy8gSWYgaW50ZXJ2YWwgaXMgdG8gdGhlIGxlZnQgb2YgdGhlIHN0YXJ0IG9mIHRoaXMgaW50ZXJ2YWwsIHRoZW4gaXQgY2FuJ3QgYmUgaW4gYW55IGNoaWxkIHRvXHJcbiAgICAgICAgLy8gdGhlIHJpZ2h0XHJcbiAgICAgICAgaWYgKGhpZ2ggPCB0aGlzLmtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbGVmdFNlYXJjaC5jb25jYXQob3duU2VhcmNoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBzZWFyY2ggcmlnaHQgY2hpbGRyZW5cclxuICAgICAgICBpZiAodGhpcy5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJpZ2h0U2VhcmNoID0gdGhpcy5yaWdodC5zZWFyY2gobG93LCBoaWdoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUmV0dXJuIGFjY3VtdWxhdGVkIHJlc3VsdHMsIGlmIGFueVxyXG4gICAgICAgIHJldHVybiBsZWZ0U2VhcmNoLmNvbmNhdChvd25TZWFyY2gsIHJpZ2h0U2VhcmNoKTtcclxuICAgIH07XHJcbiAgICAvLyBTZWFyY2hlcyBmb3IgYSBub2RlIGJ5IGEgYGtleWAgdmFsdWVcclxuICAgIE5vZGUucHJvdG90eXBlLnNlYXJjaEV4aXN0aW5nID0gZnVuY3Rpb24gKGxvdykge1xyXG4gICAgICAgIGlmICh0aGlzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMua2V5ID09PSBsb3cpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGxvdyA8IHRoaXMua2V5KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxlZnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5zZWFyY2hFeGlzdGluZyhsb3cpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yaWdodC5zZWFyY2hFeGlzdGluZyhsb3cpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG4gICAgLy8gUmV0dXJucyB0aGUgc21hbGxlc3Qgbm9kZSBvZiB0aGUgc3VidHJlZVxyXG4gICAgTm9kZS5wcm90b3R5cGUuX21pblZhbHVlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmxlZnQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnQuX21pblZhbHVlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE5vZGUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xyXG4gICAgICAgIGlmIChub2RlLmtleSA8IHRoaXMua2V5KSB7XHJcbiAgICAgICAgICAgIC8vIE5vZGUgdG8gYmUgcmVtb3ZlZCBpcyBvbiB0aGUgbGVmdCBzaWRlXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxlZnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5yZW1vdmUobm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG5vZGUua2V5ID4gdGhpcy5rZXkpIHtcclxuICAgICAgICAgICAgLy8gTm9kZSB0byBiZSByZW1vdmVkIGlzIG9uIHRoZSByaWdodCBzaWRlXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJpZ2h0LnJlbW92ZShub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxlZnQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vZGUgaGFzIHR3byBjaGlsZHJlblxyXG4gICAgICAgICAgICAgICAgdmFyIG1pblZhbHVlID0gdGhpcy5yaWdodC5fbWluVmFsdWUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMua2V5ID0gbWluVmFsdWUua2V5O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvcmRzID0gbWluVmFsdWUucmVjb3JkcztcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJpZ2h0LnJlbW92ZSh0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChwYXJlbnQubGVmdCA9PT0gdGhpcykge1xyXG4gICAgICAgICAgICAgICAgLy8gT25lIGNoaWxkIG9yIG5vIGNoaWxkIGNhc2Ugb24gbGVmdCBzaWRlXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LmxlZnQgPSB0aGlzLnJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmlnaHQucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LmxlZnQgPSB0aGlzLmxlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubGVmdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGVmdC5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcGFyZW50LnVwZGF0ZU1heE9mUGFyZW50cygpO1xyXG4gICAgICAgICAgICAgICAgcGFyZW50LnVwZGF0ZUhlaWdodCgpO1xyXG4gICAgICAgICAgICAgICAgcGFyZW50Ll9yZWJhbGFuY2UoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmVudC5yaWdodCA9PT0gdGhpcykge1xyXG4gICAgICAgICAgICAgICAgLy8gT25lIGNoaWxkIG9yIG5vIGNoaWxkIGNhc2Ugb24gcmlnaHQgc2lkZVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5yaWdodCA9IHRoaXMucmlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yaWdodC5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQucmlnaHQgPSB0aGlzLmxlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubGVmdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGVmdC5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcGFyZW50LnVwZGF0ZU1heE9mUGFyZW50cygpO1xyXG4gICAgICAgICAgICAgICAgcGFyZW50LnVwZGF0ZUhlaWdodCgpO1xyXG4gICAgICAgICAgICAgICAgcGFyZW50Ll9yZWJhbGFuY2UoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBOb2RlO1xyXG59KCkpO1xyXG5leHBvcnRzLk5vZGUgPSBOb2RlO1xyXG52YXIgSW50ZXJ2YWxUcmVlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSW50ZXJ2YWxUcmVlKCkge1xyXG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xyXG4gICAgfVxyXG4gICAgSW50ZXJ2YWxUcmVlLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAocmVjb3JkKSB7XHJcbiAgICAgICAgaWYgKHJlY29yZC5sb3cgPiByZWNvcmQuaGlnaCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Bsb3dgIHZhbHVlIG11c3QgYmUgbG93ZXIgb3IgZXF1YWwgdG8gYGhpZ2hgIHZhbHVlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnJvb3QgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAvLyBCYXNlIGNhc2U6IFRyZWUgaXMgZW1wdHksIG5ldyBub2RlIGJlY29tZXMgcm9vdFxyXG4gICAgICAgICAgICB0aGlzLnJvb3QgPSBuZXcgTm9kZSh0aGlzLCByZWNvcmQpO1xyXG4gICAgICAgICAgICB0aGlzLmNvdW50Kys7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBjaGVjayBpZiBub2RlIGFscmVhZHkgZXhpc3RzIHdpdGggdGhlIHNhbWUga2V5XHJcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5yb290LnNlYXJjaEV4aXN0aW5nKHJlY29yZC5sb3cpO1xyXG4gICAgICAgICAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGUgcmVjb3JkcyBpbiB0aGlzIG5vZGUgaWYgdGhlcmUgYWxyZWFkeSBpcyB0aGUgb25lIHdpdGggc2FtZSBsb3csIGhpZ2gsIGRhdGFcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5yZWNvcmRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2FtZShub2RlLnJlY29yZHNbaV0sIHJlY29yZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyByZWNvcmQgaXMgc2FtZSBhcyB0aGUgb25lIHdlJ3JlIHRyeWluZyB0byBpbnNlcnQ7IHJldHVybiBmYWxzZSB0byBpbmRpY2F0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub3RoaW5nIGhhcyBiZWVuIGluc2VydGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIHJlY29yZCB0byB0aGUgbm9kZVxyXG4gICAgICAgICAgICAgICAgbm9kZS5yZWNvcmRzLnB1c2gocmVjb3JkKTtcclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBtYXggb2YgdGhlIG5vZGUgYW5kIGl0cyBwYXJlbnRzIGlmIG5lY2Vzc2FyeVxyXG4gICAgICAgICAgICAgICAgaWYgKHJlY29yZC5oaWdoID4gbm9kZS5tYXgpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLm1heCA9IHJlY29yZC5oaWdoO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnBhcmVudC51cGRhdGVNYXhPZlBhcmVudHMoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50Kys7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vZGUgd2l0aCB0aGlzIGtleSBkb2Vzbid0IGFscmVhZHkgZXhpc3QuIENhbGwgaW5zZXJ0IGZ1bmN0aW9uIG9uIHJvb3QncyBub2RlXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJvb3QuaW5zZXJ0KHJlY29yZCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50Kys7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBJbnRlcnZhbFRyZWUucHJvdG90eXBlLnNlYXJjaCA9IGZ1bmN0aW9uIChsb3csIGhpZ2gpIHtcclxuICAgICAgICBpZiAodGhpcy5yb290ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgLy8gVHJlZSBpcyBlbXB0eTsgcmV0dXJuIGVtcHR5IGFycmF5XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvb3Quc2VhcmNoKGxvdywgaGlnaCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEludGVydmFsVHJlZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKHJlY29yZCkge1xyXG4gICAgICAgIGlmICh0aGlzLnJvb3QgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAvLyBUcmVlIGlzIGVtcHR5OyBub3RoaW5nIHRvIHJlbW92ZVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMucm9vdC5zZWFyY2hFeGlzdGluZyhyZWNvcmQubG93KTtcclxuICAgICAgICAgICAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUucmVjb3Jkcy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlZFJlY29yZCA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgIC8vIE5vZGUgd2l0aCB0aGlzIGtleSBoYXMgMiBvciBtb3JlIHJlY29yZHMuIEZpbmQgdGhlIG9uZSB3ZSBuZWVkIGFuZCByZW1vdmUgaXRcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5yZWNvcmRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2FtZShub2RlLnJlY29yZHNbaV0sIHJlY29yZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZFJlY29yZCA9IG5vZGUucmVjb3Jkc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5yZWNvcmRzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZWRSZWNvcmQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVkUmVjb3JkID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBtYXggb2YgdGhhdCBub2RlIGFuZCBpdHMgcGFyZW50cyBpZiBuZWNlc3NhcnlcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVjb3JkLmhpZ2ggPT09IG5vZGUubWF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlSGlnaCA9IG5vZGUuZ2V0Tm9kZUhpZ2goKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubGVmdCAhPT0gdW5kZWZpbmVkICYmIG5vZGUucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5tYXggPSBNYXRoLm1heChNYXRoLm1heChub2RlLmxlZnQubWF4LCBub2RlLnJpZ2h0Lm1heCksIG5vZGVIaWdoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlLmxlZnQgIT09IHVuZGVmaW5lZCAmJiBub2RlLnJpZ2h0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubWF4ID0gTWF0aC5tYXgobm9kZS5sZWZ0Lm1heCwgbm9kZUhpZ2gpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUubGVmdCA9PT0gdW5kZWZpbmVkICYmIG5vZGUucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5tYXggPSBNYXRoLm1heChub2RlLnJpZ2h0Lm1heCwgbm9kZUhpZ2gpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5tYXggPSBub2RlSGlnaDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50LnVwZGF0ZU1heE9mUGFyZW50cygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY291bnQtLTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChub2RlLnJlY29yZHMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBOb2RlIHdpdGggdGhpcyBrZXkgaGFzIG9ubHkgMSByZWNvcmQuIENoZWNrIGlmIHRoZSByZW1haW5pbmcgcmVjb3JkIGluIHRoaXMgbm9kZSBpc1xyXG4gICAgICAgICAgICAgICAgLy8gYWN0dWFsbHkgdGhlIG9uZSB3ZSB3YW50IHRvIHJlbW92ZVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzU2FtZShub2RlLnJlY29yZHNbMF0sIHJlY29yZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcmVtYWluaW5nIHJlY29yZCBpcyB0aGUgb25lIHdlIHdhbnQgdG8gcmVtb3ZlLiBSZW1vdmUgdGhlIHdob2xlIG5vZGUgZnJvbSB0aGUgdHJlZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJvb3Qua2V5ID09PSBub2RlLmtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSdyZSByZW1vdmluZyB0aGUgcm9vdCBlbGVtZW50LiBDcmVhdGUgYSBkdW1teSBub2RlIHRoYXQgd2lsbCB0ZW1wb3JhcmlseSB0YWtlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJvb3QncyBwYXJlbnQgcm9sZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm9vdFBhcmVudCA9IG5ldyBOb2RlKHRoaXMsIHsgbG93OiByZWNvcmQubG93LCBoaWdoOiByZWNvcmQubG93IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByb290UGFyZW50LmxlZnQgPSB0aGlzLnJvb3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucm9vdC5wYXJlbnQgPSByb290UGFyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlZE5vZGUgPSB0aGlzLnJvb3QucmVtb3ZlKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJvb3QgPSByb290UGFyZW50LmxlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJvb3QgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yb290LnBhcmVudCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVtb3ZlZE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWROb2RlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb3VudC0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZW1vdmVkTm9kZSA9IHRoaXMucm9vdC5yZW1vdmUobm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZW1vdmVkTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZE5vZGUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvdW50LS07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZW1haW5pbmcgcmVjb3JkIGlzIG5vdCB0aGUgb25lIHdlIHdhbnQgdG8gcmVtb3ZlXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gTm8gcmVjb3JkcyBhdCBhbGwgaW4gdGhpcyBub2RlPyEgU2hvdWxkbid0IGhhcHBlblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEludGVydmFsVHJlZS5wcm90b3R5cGUuaW5PcmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEluT3JkZXIodGhpcy5yb290KTtcclxuICAgIH07XHJcbiAgICBJbnRlcnZhbFRyZWUucHJvdG90eXBlLnByZU9yZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJlT3JkZXIodGhpcy5yb290KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gSW50ZXJ2YWxUcmVlO1xyXG59KCkpO1xyXG5leHBvcnRzLkludGVydmFsVHJlZSA9IEludGVydmFsVHJlZTtcclxudmFyIERhdGFJbnRlcnZhbFRyZWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEYXRhSW50ZXJ2YWxUcmVlKCkge1xyXG4gICAgICAgIHRoaXMudHJlZSA9IG5ldyBJbnRlcnZhbFRyZWUoKTtcclxuICAgIH1cclxuICAgIERhdGFJbnRlcnZhbFRyZWUucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChsb3csIGhpZ2gsIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50cmVlLmluc2VydCh7IGxvdzogbG93LCBoaWdoOiBoaWdoLCBkYXRhOiBkYXRhIH0pO1xyXG4gICAgfTtcclxuICAgIERhdGFJbnRlcnZhbFRyZWUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChsb3csIGhpZ2gsIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50cmVlLnJlbW92ZSh7IGxvdzogbG93LCBoaWdoOiBoaWdoLCBkYXRhOiBkYXRhIH0pO1xyXG4gICAgfTtcclxuICAgIERhdGFJbnRlcnZhbFRyZWUucHJvdG90eXBlLnNlYXJjaCA9IGZ1bmN0aW9uIChsb3csIGhpZ2gpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50cmVlLnNlYXJjaChsb3csIGhpZ2gpLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gdi5kYXRhOyB9KTtcclxuICAgIH07XHJcbiAgICBEYXRhSW50ZXJ2YWxUcmVlLnByb3RvdHlwZS5pbk9yZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRyZWUuaW5PcmRlcigpO1xyXG4gICAgfTtcclxuICAgIERhdGFJbnRlcnZhbFRyZWUucHJvdG90eXBlLnByZU9yZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRyZWUucHJlT3JkZXIoKTtcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0YUludGVydmFsVHJlZS5wcm90b3R5cGUsIFwiY291bnRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmVlLmNvdW50O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIERhdGFJbnRlcnZhbFRyZWU7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IERhdGFJbnRlcnZhbFRyZWU7XHJcbnZhciBJbk9yZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSW5PcmRlcihzdGFydE5vZGUpIHtcclxuICAgICAgICB0aGlzLnN0YWNrID0gW107XHJcbiAgICAgICAgaWYgKHN0YXJ0Tm9kZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHVzaChzdGFydE5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIEluT3JkZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gV2lsbCBvbmx5IGhhcHBlbiBpZiBzdGFjayBpcyBlbXB0eSBhbmQgcG9wIGlzIGNhbGxlZFxyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnROb2RlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGRvbmU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBQcm9jZXNzIHRoaXMgbm9kZVxyXG4gICAgICAgIGlmICh0aGlzLmkgPCB0aGlzLmN1cnJlbnROb2RlLnJlY29yZHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBkb25lOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLmN1cnJlbnROb2RlLnJlY29yZHNbdGhpcy5pKytdLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50Tm9kZS5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHVzaCh0aGlzLmN1cnJlbnROb2RlLnJpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIE1pZ2h0IHBvcCB0aGUgbGFzdCBhbmQgc2V0IHRoaXMuY3VycmVudE5vZGUgPSB1bmRlZmluZWRcclxuICAgICAgICAgICAgdGhpcy5wb3AoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dCgpO1xyXG4gICAgfTtcclxuICAgIEluT3JkZXIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgIHRoaXMuY3VycmVudE5vZGUgPSBub2RlO1xyXG4gICAgICAgIHRoaXMuaSA9IDA7XHJcbiAgICAgICAgd2hpbGUgKHRoaXMuY3VycmVudE5vZGUubGVmdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLmN1cnJlbnROb2RlKTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50Tm9kZSA9IHRoaXMuY3VycmVudE5vZGUubGVmdDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgSW5PcmRlci5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY3VycmVudE5vZGUgPSB0aGlzLnN0YWNrLnBvcCgpO1xyXG4gICAgICAgIHRoaXMuaSA9IDA7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEluT3JkZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuSW5PcmRlciA9IEluT3JkZXI7XHJcbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICBJbk9yZGVyLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcclxufVxyXG52YXIgUHJlT3JkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQcmVPcmRlcihzdGFydE5vZGUpIHtcclxuICAgICAgICB0aGlzLnN0YWNrID0gW107XHJcbiAgICAgICAgdGhpcy5pID0gMDtcclxuICAgICAgICB0aGlzLmN1cnJlbnROb2RlID0gc3RhcnROb2RlO1xyXG4gICAgfVxyXG4gICAgUHJlT3JkZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gV2lsbCBvbmx5IGhhcHBlbiBpZiBzdGFjayBpcyBlbXB0eSBhbmQgcG9wIGlzIGNhbGxlZCxcclxuICAgICAgICAvLyB3aGljaCBvbmx5IGhhcHBlbnMgaWYgdGhlcmUgaXMgbm8gcmlnaHQgbm9kZSAoaS5lIHdlIGFyZSBkb25lKVxyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnROb2RlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGRvbmU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBQcm9jZXNzIHRoaXMgbm9kZVxyXG4gICAgICAgIGlmICh0aGlzLmkgPCB0aGlzLmN1cnJlbnROb2RlLnJlY29yZHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBkb25lOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLmN1cnJlbnROb2RlLnJlY29yZHNbdGhpcy5pKytdLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50Tm9kZS5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHVzaCh0aGlzLmN1cnJlbnROb2RlLnJpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudE5vZGUubGVmdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHVzaCh0aGlzLmN1cnJlbnROb2RlLmxlZnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnBvcCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5leHQoKTtcclxuICAgIH07XHJcbiAgICBQcmVPcmRlci5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgdGhpcy5zdGFjay5wdXNoKG5vZGUpO1xyXG4gICAgfTtcclxuICAgIFByZU9yZGVyLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50Tm9kZSA9IHRoaXMuc3RhY2sucG9wKCk7XHJcbiAgICAgICAgdGhpcy5pID0gMDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUHJlT3JkZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuUHJlT3JkZXIgPSBQcmVPcmRlcjtcclxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcclxuICAgIFByZU9yZGVyLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvVXNlcnMvZmFpbmFzaGFsdHMvdHJ1ZmZsZS1kZXYvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvbm9kZS1pbnRlcnZhbC10cmVlL2xpYi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqQSwgb2JqQiwgY29tcGFyZSwgY29tcGFyZUNvbnRleHQpIHtcbiAgdmFyIHJldCA9IGNvbXBhcmUgPyBjb21wYXJlLmNhbGwoY29tcGFyZUNvbnRleHQsIG9iakEsIG9iakIpIDogdm9pZCAwO1xuXG4gIGlmIChyZXQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiAhIXJldDtcbiAgfVxuXG4gIGlmIChvYmpBID09PSBvYmpCKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iakEgIT09IFwib2JqZWN0XCIgfHwgIW9iakEgfHwgdHlwZW9mIG9iakIgIT09IFwib2JqZWN0XCIgfHwgIW9iakIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKTtcbiAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMob2JqQik7XG5cbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGJIYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuYmluZChvYmpCKTtcblxuICAvLyBUZXN0IGZvciBBJ3Mga2V5cyBkaWZmZXJlbnQgZnJvbSBCLlxuICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBrZXlzQS5sZW5ndGg7IGlkeCsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNBW2lkeF07XG5cbiAgICBpZiAoIWJIYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlQSA9IG9iakFba2V5XTtcbiAgICB2YXIgdmFsdWVCID0gb2JqQltrZXldO1xuXG4gICAgcmV0ID0gY29tcGFyZSA/IGNvbXBhcmUuY2FsbChjb21wYXJlQ29udGV4dCwgdmFsdWVBLCB2YWx1ZUIsIGtleSkgOiB2b2lkIDA7XG5cbiAgICBpZiAocmV0ID09PSBmYWxzZSB8fCAocmV0ID09PSB2b2lkIDAgJiYgdmFsdWVBICE9PSB2YWx1ZUIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL1VzZXJzL2ZhaW5hc2hhbHRzL3RydWZmbGUtZGV2L3RydWZmbGUvbm9kZV9tb2R1bGVzL3NoYWxsb3dlcXVhbC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOnNlc3Npb246c2FnYXNcIik7XG5cbmltcG9ydCB7IGNhbGwsIGFsbCwgZm9yaywgdGFrZSwgcHV0IH0gZnJvbSBcInJlZHV4LXNhZ2EvZWZmZWN0c1wiO1xuXG5pbXBvcnQgeyBwcmVmaXhOYW1lIH0gZnJvbSBcImxpYi9oZWxwZXJzXCI7XG5cbmltcG9ydCAqIGFzIGFzdCBmcm9tIFwibGliL2FzdC9zYWdhc1wiO1xuaW1wb3J0ICogYXMgY29udHJvbGxlciBmcm9tIFwibGliL2NvbnRyb2xsZXIvc2FnYXNcIjtcbmltcG9ydCAqIGFzIHNvbGlkaXR5IGZyb20gXCJsaWIvc29saWRpdHkvc2FnYXNcIjtcbmltcG9ydCAqIGFzIGV2bSBmcm9tIFwibGliL2V2bS9zYWdhc1wiO1xuaW1wb3J0ICogYXMgdHJhY2UgZnJvbSBcImxpYi90cmFjZS9zYWdhc1wiO1xuaW1wb3J0ICogYXMgZGF0YSBmcm9tIFwibGliL2RhdGEvc2FnYXNcIjtcbmltcG9ydCAqIGFzIHdlYjMgZnJvbSBcImxpYi93ZWIzL3NhZ2FzXCI7XG5cbmltcG9ydCAqIGFzIGFjdGlvbnMgZnJvbSBcIi4uL2FjdGlvbnNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uKiBzYWdhKCkge1xuICBkZWJ1ZyhcInN0YXJ0aW5nIGxpc3RlbmVyc1wiKTtcbiAgeWllbGQqIGZvcmtMaXN0ZW5lcnMoKTtcblxuICAvLyByZWNlaXZpbmcgJiBzYXZpbmcgY29udHJhY3RzIGludG8gc3RhdGVcbiAgZGVidWcoXCJ3YWl0aW5nIGZvciBjb250cmFjdCBpbmZvcm1hdGlvblwiKTtcbiAgbGV0IHsgY29udGV4dHMsIHNvdXJjZXMgfSA9IHlpZWxkIHRha2UoYWN0aW9ucy5SRUNPUkRfQ09OVFJBQ1RTKTtcblxuICBkZWJ1ZyhcInJlY29yZGluZyBjb250cmFjdCBiaW5hcmllc1wiKTtcbiAgeWllbGQqIHJlY29yZENvbnRleHRzKC4uLmNvbnRleHRzKTtcblxuICBkZWJ1ZyhcInJlY29yZGluZyBjb250cmFjdCBzb3VyY2VzXCIpO1xuICB5aWVsZCogcmVjb3JkU291cmNlcyguLi5zb3VyY2VzKTtcblxuICBkZWJ1ZyhcIm5vcm1hbGl6aW5nIGNvbnRleHRzXCIpO1xuICB5aWVsZCogZXZtLm5vcm1hbGl6ZUNvbnRleHRzKCk7XG5cbiAgZGVidWcoXCJ3YWl0aW5nIGZvciBzdGFydFwiKTtcbiAgLy8gd2FpdCBmb3Igc3RhcnQgc2lnbmFsXG4gIGxldCB7IHR4SGFzaCwgcHJvdmlkZXIgfSA9IHlpZWxkIHRha2UoYWN0aW9ucy5TVEFSVCk7XG4gIGRlYnVnKFwic3RhcnRpbmdcIik7XG5cbiAgLy8gcHJvY2VzcyB0cmFuc2FjdGlvblxuICBkZWJ1ZyhcImZldGNoaW5nIHRyYW5zYWN0aW9uIGluZm9cIik7XG4gIGxldCBlcnIgPSB5aWVsZCogZmV0Y2hUeCh0eEhhc2gsIHByb3ZpZGVyKTtcbiAgaWYgKGVycikge1xuICAgIGRlYnVnKFwiZXJyb3IgJW9cIiwgZXJyKTtcbiAgICB5aWVsZCogZXJyb3IoZXJyKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBkZWJ1ZyhcInZpc2l0aW5nIEFTVHNcIik7XG4gIC8vIHZpc2l0IGFzdHNcbiAgeWllbGQqIGFzdC52aXNpdEFsbCgpO1xuXG4gIC8vc2F2ZSBhbGxvY2F0aW9uIHRhYmxlXG4gIGRlYnVnKFwic2F2aW5nIGFsbG9jYXRpb24gdGFibGVcIik7XG4gIHlpZWxkKiBkYXRhLnJlY29yZEFsbG9jYXRpb25zKCk7XG5cbiAgZGVidWcoXCJyZWFkeWluZ1wiKTtcbiAgLy8gc2lnbmFsIHRoYXQgc3RlcHBpbmcgY2FuIGJlZ2luXG4gIHlpZWxkKiByZWFkeSgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBwcmVmaXhOYW1lKFwic2Vzc2lvblwiLCBzYWdhKTtcblxuZnVuY3Rpb24qIGZvcmtMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiB5aWVsZCBhbGwoXG4gICAgW2NvbnRyb2xsZXIsIGRhdGEsIGV2bSwgc29saWRpdHksIHRyYWNlLCB3ZWIzXS5tYXAoXG4gICAgICBhcHAgPT4gZm9yayhhcHAuc2FnYSlcbiAgICAgIC8vYXN0IG5vIGxvbmdlciBoYXMgYSBsaXN0ZW5lclxuICAgIClcbiAgKTtcbn1cblxuZnVuY3Rpb24qIGZldGNoVHgodHhIYXNoLCBwcm92aWRlcikge1xuICBsZXQgcmVzdWx0ID0geWllbGQqIHdlYjMuaW5zcGVjdFRyYW5zYWN0aW9uKHR4SGFzaCwgcHJvdmlkZXIpO1xuICBkZWJ1ZyhcInJlc3VsdCAlb1wiLCByZXN1bHQpO1xuXG4gIGlmIChyZXN1bHQuZXJyb3IpIHtcbiAgICByZXR1cm4gcmVzdWx0LmVycm9yO1xuICB9XG5cbiAgeWllbGQqIGV2bS5iZWdpbihyZXN1bHQpO1xuXG4gIC8vZ2V0IGFkZHJlc3NlcyBjcmVhdGVkL2NhbGxlZCBkdXJpbmcgdHJhbnNhY3Rpb25cbiAgbGV0IGFkZHJlc3NlcyA9IHlpZWxkKiB0cmFjZS5wcm9jZXNzVHJhY2UocmVzdWx0LnRyYWNlKTtcbiAgLy9hZGQgaW4gdGhlIGFkZHJlc3Mgb2YgdGhlIGNhbGwgaXRzZWxmIChpZiBhIGNhbGwpXG4gIGlmIChyZXN1bHQuYWRkcmVzcyAmJiAhYWRkcmVzc2VzLmluY2x1ZGVzKHJlc3VsdC5hZGRyZXNzKSkge1xuICAgIGFkZHJlc3Nlcy5wdXNoKHJlc3VsdC5hZGRyZXNzKTtcbiAgfVxuICAvL2lmIGEgY3JlYXRlLCBvbmx5IGFkZCBpbiBhZGRyZXNzIGlmIGl0IHdhcyBzdWNjZXNzZnVsXG4gIGlmIChcbiAgICByZXN1bHQuYmluYXJ5ICYmXG4gICAgcmVzdWx0LnN0YXR1cyAmJlxuICAgICFhZGRyZXNzZXMuaW5jbHVkZXMocmVzdWx0LnN0b3JhZ2VBZGRyZXNzKVxuICApIHtcbiAgICBhZGRyZXNzZXMucHVzaChyZXN1bHQuc3RvcmFnZUFkZHJlc3MpO1xuICB9XG5cbiAgbGV0IGJpbmFyaWVzID0geWllbGQqIHdlYjMub2J0YWluQmluYXJpZXMoYWRkcmVzc2VzKTtcblxuICB5aWVsZCBhbGwoXG4gICAgYWRkcmVzc2VzLm1hcCgoYWRkcmVzcywgaSkgPT4gY2FsbChyZWNvcmRJbnN0YW5jZSwgYWRkcmVzcywgYmluYXJpZXNbaV0pKVxuICApO1xufVxuXG5mdW5jdGlvbiogcmVjb3JkQ29udGV4dHMoLi4uY29udGV4dHMpIHtcbiAgZm9yIChsZXQgY29udGV4dCBvZiBjb250ZXh0cykge1xuICAgIHlpZWxkKiBldm0uYWRkQ29udGV4dChjb250ZXh0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiogcmVjb3JkU291cmNlcyguLi5zb3VyY2VzKSB7XG4gIGZvciAobGV0IHNvdXJjZURhdGEgb2Ygc291cmNlcykge1xuICAgIGlmIChzb3VyY2VEYXRhICE9PSB1bmRlZmluZWQgJiYgc291cmNlRGF0YSAhPT0gbnVsbCkge1xuICAgICAgeWllbGQqIHNvbGlkaXR5LmFkZFNvdXJjZShcbiAgICAgICAgc291cmNlRGF0YS5zb3VyY2UsXG4gICAgICAgIHNvdXJjZURhdGEuc291cmNlUGF0aCxcbiAgICAgICAgc291cmNlRGF0YS5hc3QsXG4gICAgICAgIHNvdXJjZURhdGEuY29tcGlsZXJcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uKiByZWNvcmRJbnN0YW5jZShhZGRyZXNzLCBiaW5hcnkpIHtcbiAgeWllbGQqIGV2bS5hZGRJbnN0YW5jZShhZGRyZXNzLCBiaW5hcnkpO1xufVxuXG5mdW5jdGlvbiogcmVhZHkoKSB7XG4gIHlpZWxkIHB1dChhY3Rpb25zLnJlYWR5KCkpO1xufVxuXG5mdW5jdGlvbiogZXJyb3IoZXJyKSB7XG4gIHlpZWxkIHB1dChhY3Rpb25zLmVycm9yKGVycikpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9zZXNzaW9uL3NhZ2FzL2luZGV4LmpzIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOmFzdDpzYWdhc1wiKTtcblxuaW1wb3J0IHsgYWxsLCBjYWxsLCBzZWxlY3QgfSBmcm9tIFwicmVkdXgtc2FnYS9lZmZlY3RzXCI7XG5cbmltcG9ydCAqIGFzIGRhdGEgZnJvbSBcImxpYi9kYXRhL3NhZ2FzXCI7XG5cbmltcG9ydCBhc3QgZnJvbSBcIi4uL3NlbGVjdG9yc1wiO1xuXG5mdW5jdGlvbiogd2Fsayhzb3VyY2VJZCwgbm9kZSwgcG9pbnRlciA9IFwiXCIsIHBhcmVudElkID0gbnVsbCkge1xuICBkZWJ1ZyhcIndhbGtpbmcgJW8gJW9cIiwgcG9pbnRlciwgbm9kZSk7XG5cbiAgeWllbGQqIGhhbmRsZUVudGVyKHNvdXJjZUlkLCBub2RlLCBwb2ludGVyLCBwYXJlbnRJZCk7XG5cbiAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIGZvciAobGV0IFtpLCBjaGlsZF0gb2Ygbm9kZS5lbnRyaWVzKCkpIHtcbiAgICAgIHlpZWxkIGNhbGwod2Fsaywgc291cmNlSWQsIGNoaWxkLCBgJHtwb2ludGVyfS8ke2l9YCwgcGFyZW50SWQpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgZm9yIChsZXQgW2tleSwgY2hpbGRdIG9mIE9iamVjdC5lbnRyaWVzKG5vZGUpKSB7XG4gICAgICB5aWVsZCBjYWxsKHdhbGssIHNvdXJjZUlkLCBjaGlsZCwgYCR7cG9pbnRlcn0vJHtrZXl9YCwgbm9kZS5pZCk7XG4gICAgfVxuICB9XG5cbiAgeWllbGQqIGhhbmRsZUV4aXQoc291cmNlSWQsIG5vZGUsIHBvaW50ZXIpO1xufVxuXG5mdW5jdGlvbiogaGFuZGxlRW50ZXIoc291cmNlSWQsIG5vZGUsIHBvaW50ZXIsIHBhcmVudElkKSB7XG4gIGlmICghKG5vZGUgaW5zdGFuY2VvZiBPYmplY3QpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZGVidWcoXCJlbnRlcmluZyAlc1wiLCBwb2ludGVyKTtcblxuICBpZiAobm9kZS5pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZGVidWcoXCIlcyByZWNvcmRpbmcgc2NvcGUgJXNcIiwgcG9pbnRlciwgbm9kZS5pZCk7XG4gICAgeWllbGQqIGRhdGEuc2NvcGUobm9kZS5pZCwgcG9pbnRlciwgcGFyZW50SWQsIHNvdXJjZUlkKTtcbiAgfVxuXG4gIHN3aXRjaCAobm9kZS5ub2RlVHlwZSkge1xuICAgIGNhc2UgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCI6XG4gICAgICBkZWJ1ZyhcIiVzIHJlY29yZGluZyB2YXJpYWJsZSAlb1wiLCBwb2ludGVyLCBub2RlKTtcbiAgICAgIHlpZWxkKiBkYXRhLmRlY2xhcmUobm9kZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiQ29udHJhY3REZWZpbml0aW9uXCI6XG4gICAgY2FzZSBcIlN0cnVjdERlZmluaXRpb25cIjpcbiAgICBjYXNlIFwiRW51bURlZmluaXRpb25cIjpcbiAgICAgIHlpZWxkKiBkYXRhLmRlZmluZVR5cGUobm9kZSk7XG4gICAgICBicmVhaztcbiAgfVxufVxuXG5mdW5jdGlvbiogaGFuZGxlRXhpdChzb3VyY2VJZCwgbm9kZSwgcG9pbnRlcikge1xuICBkZWJ1ZyhcImV4aXRpbmcgJXNcIiwgcG9pbnRlcik7XG5cbiAgLy8gbm8tb3AgcmlnaHQgbm93XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogdmlzaXRBbGwoKSB7XG4gIGxldCBzb3VyY2VzID0geWllbGQgc2VsZWN0KGFzdC52aWV3cy5zb3VyY2VzKTtcblxuICB5aWVsZCBhbGwoXG4gICAgT2JqZWN0LmVudHJpZXMoc291cmNlcylcbiAgICAgIC5maWx0ZXIoKFtfLCBzb3VyY2VdKSA9PiBzb3VyY2UuYXN0KVxuICAgICAgLm1hcCgoW2lkLCB7IGFzdCB9XSkgPT4gY2FsbCh3YWxrLCBpZCwgYXN0KSlcbiAgKTtcblxuICBkZWJ1ZyhcImRvbmUgdmlzaXRpbmdcIik7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2FzdC9zYWdhcy9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImxvZGFzaC5zdW1cIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJsb2Rhc2guc3VtXCJcbi8vIG1vZHVsZSBpZCA9IDU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjpjb250cm9sbGVyOnNhZ2FzXCIpO1xuXG5pbXBvcnQgeyBwdXQsIGNhbGwsIHJhY2UsIHRha2UsIHNlbGVjdCB9IGZyb20gXCJyZWR1eC1zYWdhL2VmZmVjdHNcIjtcblxuaW1wb3J0IHsgcHJlZml4TmFtZSwgaXNEZWxpYmVyYXRlbHlTa2lwcGVkTm9kZVR5cGUgfSBmcm9tIFwibGliL2hlbHBlcnNcIjtcblxuaW1wb3J0ICogYXMgdHJhY2UgZnJvbSBcImxpYi90cmFjZS9zYWdhc1wiO1xuaW1wb3J0ICogYXMgZGF0YSBmcm9tIFwibGliL2RhdGEvc2FnYXNcIjtcbmltcG9ydCAqIGFzIGV2bSBmcm9tIFwibGliL2V2bS9zYWdhc1wiO1xuaW1wb3J0ICogYXMgc29saWRpdHkgZnJvbSBcImxpYi9zb2xpZGl0eS9zYWdhc1wiO1xuXG5pbXBvcnQgKiBhcyBhY3Rpb25zIGZyb20gXCIuLi9hY3Rpb25zXCI7XG5cbmltcG9ydCBjb250cm9sbGVyIGZyb20gXCIuLi9zZWxlY3RvcnNcIjtcblxuLy9OT1RFOiB3aGVuIHVwZGF0aW5nIHRoaXMgZG9uJ3QgZm9yZ2V0IHRvIHVwZGF0ZSBDT05UUk9MX0FDVElPTlMgaW5cbi8vcmVkdWNlcnMuanMgYXMgd2VsbCFcbmNvbnN0IENPTlRST0xfU0FHQVMgPSB7XG4gIFthY3Rpb25zLkFEVkFOQ0VdOiBhZHZhbmNlLFxuICBbYWN0aW9ucy5TVEVQX05FWFRdOiBzdGVwTmV4dCxcbiAgW2FjdGlvbnMuU1RFUF9PVkVSXTogc3RlcE92ZXIsXG4gIFthY3Rpb25zLlNURVBfSU5UT106IHN0ZXBJbnRvLFxuICBbYWN0aW9ucy5TVEVQX09VVF06IHN0ZXBPdXQsXG4gIFthY3Rpb25zLkNPTlRJTlVFXTogY29udGludWVVbnRpbEJyZWFrcG9pbnQsXG4gIFthY3Rpb25zLlJFU0VUXTogcmVzZXRcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiogc2FnYSgpIHtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBkZWJ1ZyhcIndhaXRpbmcgZm9yIGNvbnRyb2wgYWN0aW9uXCIpO1xuICAgIGxldCBhY3Rpb24gPSB5aWVsZCB0YWtlKE9iamVjdC5rZXlzKENPTlRST0xfU0FHQVMpKTtcbiAgICBkZWJ1ZyhcImdvdCBjb250cm9sIGFjdGlvblwiKTtcbiAgICBsZXQgc2FnYSA9IENPTlRST0xfU0FHQVNbYWN0aW9uLnR5cGVdO1xuXG4gICAgeWllbGQgcmFjZSh7XG4gICAgICBleGVjOiBjYWxsKHNhZ2EsIGFjdGlvbiksIC8vbm90IGFsbCB3aWxsIHVzZSB0aGlzXG4gICAgICBpbnRlcnJ1cHQ6IHRha2UoYWN0aW9ucy5JTlRFUlJVUFQpXG4gICAgfSk7XG4gICAgeWllbGQgcHV0KGFjdGlvbnMuZG9uZVN0ZXBwaW5nKCkpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHByZWZpeE5hbWUoXCJjb250cm9sbGVyXCIsIHNhZ2EpO1xuXG4vKlxuICogQWR2YW5jZSB0aGUgc3RhdGUgYnkgdGhlIGdpdmVuIG51bWJlciBvZiBpbnN0cnVjdGlvbnMgKGJ1dCBub3QgcGFzdCB0aGUgZW5kKVxuICogKGlmIG5vIGNvdW50IGdpdmVuLCBhZHZhbmNlIDEpXG4gKi9cbmZ1bmN0aW9uKiBhZHZhbmNlKGFjdGlvbikge1xuICBsZXQgY291bnQgPVxuICAgIGFjdGlvbiAhPT0gdW5kZWZpbmVkICYmIGFjdGlvbi5jb3VudCAhPT0gdW5kZWZpbmVkID8gYWN0aW9uLmNvdW50IDogMTsgLy9kZWZhdWx0IGlzLCBhcyBtZW50aW9uZWQsIHRvIGFkdmFuY2UgMVxuICBmb3IgKFxuICAgIGxldCBpID0gMDtcbiAgICBpIDwgY291bnQgJiYgISh5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LmZpbmlzaGVkKSk7XG4gICAgaSsrXG4gICkge1xuICAgIHlpZWxkKiB0cmFjZS5hZHZhbmNlKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBzdGVwTmV4dCAtIHN0ZXAgdG8gdGhlIG5leHQgbG9naWNhbCBjb2RlIHNlZ21lbnRcbiAqXG4gKiBOb3RlOiBJdCBtaWdodCB0YWtlIG11bHRpcGxlIGluc3RydWN0aW9ucyB0byBleHByZXNzIHRoZSBzYW1lIHNlY3Rpb24gb2YgY29kZS5cbiAqIFwiU3RlcHBpbmdcIiwgdGhlbiwgaXMgc3RlcHBpbmcgdG8gdGhlIG5leHQgbG9naWNhbCBpdGVtLCBub3Qgc3RlcHBpbmcgdG8gdGhlIG5leHRcbiAqIGluc3RydWN0aW9uLiBTZWUgYWR2YW5jZSgpIGlmIHlvdSdkIGxpa2UgdG8gYWR2YW5jZSBieSBvbmUgaW5zdHJ1Y3Rpb24uXG4gKi9cbmZ1bmN0aW9uKiBzdGVwTmV4dCgpIHtcbiAgY29uc3Qgc3RhcnRpbmdSYW5nZSA9IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb24uc291cmNlUmFuZ2UpO1xuXG4gIHZhciB1cGNvbWluZywgZmluaXNoZWQ7XG5cbiAgZG8ge1xuICAgIC8vIGFkdmFuY2UgYXQgbGVhc3Qgb25jZSBzdGVwXG4gICAgeWllbGQqIGFkdmFuY2UoKTtcblxuICAgIC8vIGFuZCBjaGVjayB0aGUgbmV4dCBzb3VyY2UgcmFuZ2VcbiAgICB0cnkge1xuICAgICAgdXBjb21pbmcgPSB5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LmxvY2F0aW9uKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB1cGNvbWluZyA9IG51bGw7XG4gICAgfVxuXG4gICAgZmluaXNoZWQgPSB5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LmZpbmlzaGVkKTtcblxuICAgIC8vIGlmIHRoZSBuZXh0IHN0ZXAncyBzb3VyY2UgcmFuZ2UgaXMgc3RpbGwgdGhlIHNhbWUsIGtlZXAgZ29pbmdcbiAgfSB3aGlsZSAoXG4gICAgIWZpbmlzaGVkICYmXG4gICAgKCF1cGNvbWluZyB8fFxuICAgICAgIXVwY29taW5nLm5vZGUgfHxcbiAgICAgIGlzRGVsaWJlcmF0ZWx5U2tpcHBlZE5vZGVUeXBlKHVwY29taW5nLm5vZGUpIHx8XG4gICAgICAodXBjb21pbmcuc291cmNlUmFuZ2Uuc3RhcnQgPT0gc3RhcnRpbmdSYW5nZS5zdGFydCAmJlxuICAgICAgICB1cGNvbWluZy5zb3VyY2VSYW5nZS5sZW5ndGggPT0gc3RhcnRpbmdSYW5nZS5sZW5ndGgpKVxuICApO1xufVxuXG4vKipcbiAqIHN0ZXBJbnRvIC0gc3RlcCBpbnRvIHRoZSBjdXJyZW50IGZ1bmN0aW9uXG4gKlxuICogQ29uY2VwdHVhbGx5IHRoaXMgaXMgZWFzeSwgYnV0IGZyb20gYSBwcm9ncmFtbWluZyBzdGFuZHBvaW50IGl0J3MgaGFyZC5cbiAqIENvZGUgbGlrZSBgZ2V0QmFsYW5jZShtc2cuc2VuZGVyKWAgbWlnaHQgYmUgaGlnaGxpZ2h0ZWQsIGJ1dCB0aGVyZSBjb3VsZFxuICogYmUgYSBudW1iZXIgb2YgZGlmZmVyZW50IGludGVybWVkaWF0ZSBzdGVwcyAobGlrZSBldmFsdWF0aW5nIGBtc2cuc2VuZGVyYClcbiAqIGJlZm9yZSBgZ2V0QmFsYW5jZWAgaXMgc3RlcHBlZCBpbnRvLiBUaGlzIGZ1bmN0aW9uIHdpbGwgc3RlcCBpbnRvIHRoZSBmaXJzdFxuICogZnVuY3Rpb24gYXZhaWxhYmxlICh3aGVyZSBpbnN0cnVjdGlvbi5qdW1wID09IFwiaVwiKSwgaWdub3JpbmcgYW55IGludGVybWVkaWF0ZVxuICogc3RlcHMgdGhhdCBmYWxsIHdpdGhpbiB0aGUgc2FtZSBjb2RlIHJhbmdlLiBJZiB0aGVyZSdzIGEgc3RlcCBlbmNvdW50ZXJlZFxuICogdGhhdCBleGlzdHMgb3V0c2lkZSBvZiB0aGUgcmFuZ2UsIHRoZW4gc3RlcEludG8gd2lsbCBvbmx5IGV4ZWN1dGUgdW50aWwgdGhhdFxuICogc3RlcC5cbiAqL1xuZnVuY3Rpb24qIHN0ZXBJbnRvKCkge1xuICBpZiAoeWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuY3VycmVudC53aWxsSnVtcCkpIHtcbiAgICB5aWVsZCogc3RlcE5leHQoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoeWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuY3VycmVudC5sb2NhdGlvbi5pc011bHRpbGluZSkpIHtcbiAgICB5aWVsZCogc3RlcE92ZXIoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBzdGFydGluZ0RlcHRoID0geWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuY3VycmVudC5mdW5jdGlvbkRlcHRoKTtcbiAgY29uc3Qgc3RhcnRpbmdSYW5nZSA9IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb24uc291cmNlUmFuZ2UpO1xuICB2YXIgY3VycmVudERlcHRoO1xuICB2YXIgY3VycmVudFJhbmdlO1xuXG4gIGRvIHtcbiAgICB5aWVsZCogc3RlcE5leHQoKTtcblxuICAgIGN1cnJlbnREZXB0aCA9IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQuZnVuY3Rpb25EZXB0aCk7XG4gICAgY3VycmVudFJhbmdlID0geWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuY3VycmVudC5sb2NhdGlvbi5zb3VyY2VSYW5nZSk7XG4gIH0gd2hpbGUgKFxuICAgIC8vIHRoZSBmdW5jdGlvbiBzdGFjayBoYXMgbm90IGluY3JlYXNlZCxcbiAgICBjdXJyZW50RGVwdGggPD0gc3RhcnRpbmdEZXB0aCAmJlxuICAgIC8vIHRoZSBjdXJyZW50IHNvdXJjZSByYW5nZSBiZWdpbnMgb24gb3IgYWZ0ZXIgdGhlIHN0YXJ0aW5nIHJhbmdlXG4gICAgY3VycmVudFJhbmdlLnN0YXJ0ID49IHN0YXJ0aW5nUmFuZ2Uuc3RhcnQgJiZcbiAgICAvLyBhbmQgdGhlIGN1cnJlbnQgcmFuZ2UgZW5kcyBvbiBvciBiZWZvcmUgdGhlIHN0YXJ0aW5nIHJhbmdlIGVuZHNcbiAgICBjdXJyZW50UmFuZ2Uuc3RhcnQgKyBjdXJyZW50UmFuZ2UubGVuZ3RoIDw9XG4gICAgICBzdGFydGluZ1JhbmdlLnN0YXJ0ICsgc3RhcnRpbmdSYW5nZS5sZW5ndGhcbiAgKTtcbn1cblxuLyoqXG4gKiBTdGVwIG91dCBvZiB0aGUgY3VycmVudCBmdW5jdGlvblxuICpcbiAqIFRoaXMgd2lsbCBydW4gdW50aWwgdGhlIGRlYnVnZ2VyIGVuY291bnRlcnMgYSBkZWNyZWFzZSBpbiBmdW5jdGlvbiBkZXB0aC5cbiAqL1xuZnVuY3Rpb24qIHN0ZXBPdXQoKSB7XG4gIGlmICh5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LmxvY2F0aW9uLmlzTXVsdGlsaW5lKSkge1xuICAgIHlpZWxkKiBzdGVwT3ZlcigpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHN0YXJ0aW5nRGVwdGggPSB5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LmZ1bmN0aW9uRGVwdGgpO1xuICB2YXIgY3VycmVudERlcHRoO1xuXG4gIGRvIHtcbiAgICB5aWVsZCogc3RlcE5leHQoKTtcblxuICAgIGN1cnJlbnREZXB0aCA9IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQuZnVuY3Rpb25EZXB0aCk7XG4gIH0gd2hpbGUgKGN1cnJlbnREZXB0aCA+PSBzdGFydGluZ0RlcHRoKTtcbn1cblxuLyoqXG4gKiBzdGVwT3ZlciAtIHN0ZXAgb3ZlciB0aGUgY3VycmVudCBsaW5lXG4gKlxuICogU3RlcCBvdmVyIHRoZSBjdXJyZW50IGxpbmUuIFRoaXMgd2lsbCBzdGVwIHRvIHRoZSBuZXh0IGluc3RydWN0aW9uIHRoYXRcbiAqIGV4aXN0cyBvbiBhIGRpZmZlcmVudCBsaW5lIG9mIGNvZGUgd2l0aGluIHRoZSBzYW1lIGZ1bmN0aW9uIGRlcHRoLlxuICovXG5mdW5jdGlvbiogc3RlcE92ZXIoKSB7XG4gIGNvbnN0IHN0YXJ0aW5nRGVwdGggPSB5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LmZ1bmN0aW9uRGVwdGgpO1xuICBjb25zdCBzdGFydGluZ1JhbmdlID0geWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuY3VycmVudC5sb2NhdGlvbi5zb3VyY2VSYW5nZSk7XG4gIHZhciBjdXJyZW50RGVwdGg7XG4gIHZhciBjdXJyZW50UmFuZ2U7XG5cbiAgZG8ge1xuICAgIHlpZWxkKiBzdGVwTmV4dCgpO1xuXG4gICAgY3VycmVudERlcHRoID0geWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuY3VycmVudC5mdW5jdGlvbkRlcHRoKTtcbiAgICBjdXJyZW50UmFuZ2UgPSB5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LmxvY2F0aW9uLnNvdXJjZVJhbmdlKTtcbiAgfSB3aGlsZSAoXG4gICAgLy8ga2VlcCBzdGVwcGluZyBwcm92aWRlZDpcbiAgICAvL1xuICAgIC8vIHdlIGhhdmVuJ3QganVtcGVkIG91dFxuICAgICEoY3VycmVudERlcHRoIDwgc3RhcnRpbmdEZXB0aCkgJiZcbiAgICAvLyBlaXRoZXI6IGZ1bmN0aW9uIGRlcHRoIGlzIGdyZWF0ZXIgdGhhbiBzdGFydGluZyAoaWdub3JlIGZ1bmN0aW9uIGNhbGxzKVxuICAgIC8vIG9yLCBpZiB3ZSdyZSBhdCB0aGUgc2FtZSBkZXB0aCwga2VlcCBzdGVwcGluZyB1bnRpbCB3ZSdyZSBvbiBhIG5ld1xuICAgIC8vIGxpbmUuXG4gICAgKGN1cnJlbnREZXB0aCA+IHN0YXJ0aW5nRGVwdGggfHxcbiAgICAgIGN1cnJlbnRSYW5nZS5saW5lcy5zdGFydC5saW5lID09IHN0YXJ0aW5nUmFuZ2UubGluZXMuc3RhcnQubGluZSlcbiAgKTtcbn1cblxuLyoqXG4gKiBjb250aW51ZVVudGlsQnJlYWtwb2ludCAtIHN0ZXAgdGhyb3VnaCBleGVjdXRpb24gdW50aWwgYSBicmVha3BvaW50XG4gKi9cbmZ1bmN0aW9uKiBjb250aW51ZVVudGlsQnJlYWtwb2ludChhY3Rpb24pIHtcbiAgdmFyIGN1cnJlbnRMb2NhdGlvbiwgY3VycmVudE5vZGUsIGN1cnJlbnRMaW5lLCBjdXJyZW50U291cmNlSWQ7XG4gIHZhciBmaW5pc2hlZDtcbiAgdmFyIHByZXZpb3VzTGluZSwgcHJldmlvdXNTb3VyY2VJZDtcblxuICAvL2lmIGJyZWFrcG9pbnRzIHdhcyBub3Qgc3BlY2lmaWVkLCB1c2UgdGhlIHN0b3JlZCBsaXN0IGZyb20gdGhlIHN0YXRlLlxuICAvL2lmIGl0IHdhcywgb3ZlcnJpZGUgdGhhdCB3aXRoIHRoZSBzcGVjaWZpZWQgbGlzdC5cbiAgLy9ub3RlIHRoYXQgZXhwbGljaXRseSBzcGVjaWZ5aW5nIGFuIGVtcHR5IGxpc3Qgd2lsbCBhZHZhbmNlIHRvIHRoZSBlbmQuXG4gIGxldCBicmVha3BvaW50cyA9XG4gICAgYWN0aW9uICE9PSB1bmRlZmluZWQgJiYgYWN0aW9uLmJyZWFrcG9pbnRzICE9PSB1bmRlZmluZWRcbiAgICAgID8gYWN0aW9uLmJyZWFrcG9pbnRzXG4gICAgICA6IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmJyZWFrcG9pbnRzKTtcblxuICBsZXQgYnJlYWtwb2ludEhpdCA9IGZhbHNlO1xuXG4gIGN1cnJlbnRMb2NhdGlvbiA9IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb24pO1xuICBjdXJyZW50Tm9kZSA9IGN1cnJlbnRMb2NhdGlvbi5ub2RlLmlkO1xuICBjdXJyZW50TGluZSA9IGN1cnJlbnRMb2NhdGlvbi5zb3VyY2VSYW5nZS5saW5lcy5zdGFydC5saW5lO1xuICBjdXJyZW50U291cmNlSWQgPSBjdXJyZW50TG9jYXRpb24uc291cmNlLmlkO1xuXG4gIGRvIHtcbiAgICB5aWVsZCogc3RlcE5leHQoKTtcblxuICAgIHByZXZpb3VzTGluZSA9IGN1cnJlbnRMaW5lO1xuICAgIHByZXZpb3VzU291cmNlSWQgPSBjdXJyZW50U291cmNlSWQ7XG5cbiAgICBjdXJyZW50TG9jYXRpb24gPSB5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LmxvY2F0aW9uKTtcbiAgICBmaW5pc2hlZCA9IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQuZmluaXNoZWQpO1xuICAgIGRlYnVnKFwiZmluaXNoZWQgJW9cIiwgZmluaXNoZWQpO1xuXG4gICAgY3VycmVudE5vZGUgPSBjdXJyZW50TG9jYXRpb24ubm9kZS5pZDtcbiAgICBjdXJyZW50TGluZSA9IGN1cnJlbnRMb2NhdGlvbi5zb3VyY2VSYW5nZS5saW5lcy5zdGFydC5saW5lO1xuICAgIGN1cnJlbnRTb3VyY2VJZCA9IGN1cnJlbnRMb2NhdGlvbi5zb3VyY2UuaWQ7XG5cbiAgICBicmVha3BvaW50SGl0ID1cbiAgICAgIGJyZWFrcG9pbnRzLmZpbHRlcigoeyBzb3VyY2VJZCwgbGluZSwgbm9kZSB9KSA9PiB7XG4gICAgICAgIGlmIChub2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkZWJ1ZyhcIm5vZGUgJWQgY3VycmVudE5vZGUgJWRcIiwgbm9kZSwgY3VycmVudE5vZGUpO1xuICAgICAgICAgIHJldHVybiBzb3VyY2VJZCA9PT0gY3VycmVudFNvdXJjZUlkICYmIG5vZGUgPT09IGN1cnJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIC8vb3RoZXJ3aXNlLCB3ZSBoYXZlIGEgbGluZS1zdHlsZSBicmVha3BvaW50OyB3ZSB3YW50IHRvIHN0b3AgYXQgdGhlXG4gICAgICAgIC8vKmZpcnN0KiBwb2ludCBvbiB0aGUgbGluZVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHNvdXJjZUlkID09PSBjdXJyZW50U291cmNlSWQgJiZcbiAgICAgICAgICBsaW5lID09PSBjdXJyZW50TGluZSAmJlxuICAgICAgICAgIChjdXJyZW50U291cmNlSWQgIT09IHByZXZpb3VzU291cmNlSWQgfHwgY3VycmVudExpbmUgIT09IHByZXZpb3VzTGluZSlcbiAgICAgICAgKTtcbiAgICAgIH0pLmxlbmd0aCA+IDA7XG4gIH0gd2hpbGUgKCFicmVha3BvaW50SGl0ICYmICFmaW5pc2hlZCk7XG59XG5cbi8qKlxuICogcmVzZXQgLS0gcmVzZXQgdGhlIHN0YXRlIG9mIHRoZSBkZWJ1Z2dlclxuICovXG5mdW5jdGlvbiogcmVzZXQoKSB7XG4gIHlpZWxkKiBkYXRhLnJlc2V0KCk7XG4gIHlpZWxkKiBldm0ucmVzZXQoKTtcbiAgeWllbGQqIHNvbGlkaXR5LnJlc2V0KCk7XG4gIHlpZWxkKiB0cmFjZS5yZXNldCgpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9jb250cm9sbGVyL3NhZ2FzL2luZGV4LmpzIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOndlYjM6c2FnYXNcIik7XG5cbmltcG9ydCB7XG4gIGFsbCxcbiAgdGFrZUV2ZXJ5LFxuICBhcHBseSxcbiAgZm9yayxcbiAgam9pbixcbiAgdGFrZSxcbiAgcHV0XG59IGZyb20gXCJyZWR1eC1zYWdhL2VmZmVjdHNcIjtcbmltcG9ydCB7IHByZWZpeE5hbWUgfSBmcm9tIFwibGliL2hlbHBlcnNcIjtcblxuaW1wb3J0ICogYXMgYWN0aW9ucyBmcm9tIFwiLi4vYWN0aW9uc1wiO1xuaW1wb3J0ICogYXMgc2Vzc2lvbiBmcm9tIFwibGliL3Nlc3Npb24vYWN0aW9uc1wiO1xuXG5pbXBvcnQgQk4gZnJvbSBcImJuLmpzXCI7XG5pbXBvcnQgV2ViMyBmcm9tIFwid2ViM1wiOyAvL2p1c3QgZm9yIHV0aWxzIVxuaW1wb3J0ICogYXMgRGVjb2RlVXRpbHMgZnJvbSBcInRydWZmbGUtZGVjb2RlLXV0aWxzXCI7XG5cbmltcG9ydCBXZWIzQWRhcHRlciBmcm9tIFwiLi4vYWRhcHRlclwiO1xuXG5mdW5jdGlvbiogZmV0Y2hUcmFuc2FjdGlvbkluZm8oYWRhcHRlciwgeyB0eEhhc2ggfSkge1xuICBkZWJ1ZyhcImluc3BlY3RpbmcgdHJhbnNhY3Rpb25cIik7XG4gIHZhciB0cmFjZTtcbiAgdHJ5IHtcbiAgICB0cmFjZSA9IHlpZWxkIGFwcGx5KGFkYXB0ZXIsIGFkYXB0ZXIuZ2V0VHJhY2UsIFt0eEhhc2hdKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGRlYnVnKFwicHV0dGluZyBlcnJvclwiKTtcbiAgICB5aWVsZCBwdXQoYWN0aW9ucy5lcnJvcihlKSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZGVidWcoXCJnb3QgdHJhY2VcIik7XG4gIHlpZWxkIHB1dChhY3Rpb25zLnJlY2VpdmVUcmFjZSh0cmFjZSkpO1xuXG4gIGxldCB0eCA9IHlpZWxkIGFwcGx5KGFkYXB0ZXIsIGFkYXB0ZXIuZ2V0VHJhbnNhY3Rpb24sIFt0eEhhc2hdKTtcbiAgZGVidWcoXCJ0eCAlT1wiLCB0eCk7XG4gIGxldCByZWNlaXB0ID0geWllbGQgYXBwbHkoYWRhcHRlciwgYWRhcHRlci5nZXRSZWNlaXB0LCBbdHhIYXNoXSk7XG4gIGRlYnVnKFwicmVjZWlwdCAlT1wiLCByZWNlaXB0KTtcbiAgbGV0IGJsb2NrID0geWllbGQgYXBwbHkoYWRhcHRlciwgYWRhcHRlci5nZXRCbG9jaywgW3R4LmJsb2NrTnVtYmVyXSk7XG4gIGRlYnVnKFwiYmxvY2sgJU9cIiwgYmxvY2spO1xuXG4gIHlpZWxkIHB1dChzZXNzaW9uLnNhdmVUcmFuc2FjdGlvbih0eCkpO1xuICB5aWVsZCBwdXQoc2Vzc2lvbi5zYXZlUmVjZWlwdChyZWNlaXB0KSk7XG4gIHlpZWxkIHB1dChzZXNzaW9uLnNhdmVCbG9jayhibG9jaykpO1xuXG4gIC8vdGhlc2Ugb25lcyBnZXQgZ3JvdXBlZCB0b2dldGhlciBmb3IgY29udmVuaWVuY2VcbiAgbGV0IHNvbGlkaXR5QmxvY2sgPSB7XG4gICAgY29pbmJhc2U6IGJsb2NrLm1pbmVyLFxuICAgIGRpZmZpY3VsdHk6IG5ldyBCTihibG9jay5kaWZmaWN1bHR5KSxcbiAgICBnYXNsaW1pdDogbmV3IEJOKGJsb2NrLmdhc0xpbWl0KSxcbiAgICBudW1iZXI6IG5ldyBCTihibG9jay5udW1iZXIpLFxuICAgIHRpbWVzdGFtcDogbmV3IEJOKGJsb2NrLnRpbWVzdGFtcClcbiAgfTtcblxuICBpZiAodHgudG8gIT0gbnVsbCkge1xuICAgIHlpZWxkIHB1dChcbiAgICAgIGFjdGlvbnMucmVjZWl2ZUNhbGwoe1xuICAgICAgICBhZGRyZXNzOiB0eC50byxcbiAgICAgICAgZGF0YTogdHguaW5wdXQsXG4gICAgICAgIHN0b3JhZ2VBZGRyZXNzOiB0eC50byxcbiAgICAgICAgc2VuZGVyOiB0eC5mcm9tLFxuICAgICAgICB2YWx1ZTogbmV3IEJOKHR4LnZhbHVlKSxcbiAgICAgICAgZ2FzcHJpY2U6IG5ldyBCTih0eC5nYXNQcmljZSksXG4gICAgICAgIGJsb2NrOiBzb2xpZGl0eUJsb2NrXG4gICAgICB9KVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHN0b3JhZ2VBZGRyZXNzID0gV2ViMy51dGlscy5pc0FkZHJlc3MocmVjZWlwdC5jb250cmFjdEFkZHJlc3MpXG4gICAgICA/IHJlY2VpcHQuY29udHJhY3RBZGRyZXNzXG4gICAgICA6IERlY29kZVV0aWxzLkVWTS5aRVJPX0FERFJFU1M7XG4gICAgeWllbGQgcHV0KFxuICAgICAgYWN0aW9ucy5yZWNlaXZlQ2FsbCh7XG4gICAgICAgIGJpbmFyeTogdHguaW5wdXQsXG4gICAgICAgIHN0b3JhZ2VBZGRyZXNzLFxuICAgICAgICBzdGF0dXM6IHJlY2VpcHQuc3RhdHVzLFxuICAgICAgICBzZW5kZXI6IHR4LmZyb20sXG4gICAgICAgIHZhbHVlOiBuZXcgQk4odHgudmFsdWUpLFxuICAgICAgICBnYXNwcmljZTogbmV3IEJOKHR4Lmdhc1ByaWNlKSxcbiAgICAgICAgYmxvY2s6IHNvbGlkaXR5QmxvY2tcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiogZmV0Y2hCaW5hcnkoYWRhcHRlciwgeyBhZGRyZXNzIH0pIHtcbiAgZGVidWcoXCJmZXRjaGluZyBiaW5hcnkgZm9yICVzXCIsIGFkZHJlc3MpO1xuICBsZXQgYmluYXJ5ID0geWllbGQgYXBwbHkoYWRhcHRlciwgYWRhcHRlci5nZXREZXBsb3llZENvZGUsIFthZGRyZXNzXSk7XG5cbiAgZGVidWcoXCJyZWNlaXZlZCBiaW5hcnkgZm9yICVzXCIsIGFkZHJlc3MpO1xuICB5aWVsZCBwdXQoYWN0aW9ucy5yZWNlaXZlQmluYXJ5KGFkZHJlc3MsIGJpbmFyeSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24qIGluc3BlY3RUcmFuc2FjdGlvbih0eEhhc2gsIHByb3ZpZGVyKSB7XG4gIHlpZWxkIHB1dChhY3Rpb25zLmluaXQocHJvdmlkZXIpKTtcbiAgeWllbGQgcHV0KGFjdGlvbnMuaW5zcGVjdCh0eEhhc2gpKTtcblxuICBsZXQgYWN0aW9uID0geWllbGQgdGFrZShbYWN0aW9ucy5SRUNFSVZFX1RSQUNFLCBhY3Rpb25zLkVSUk9SX1dFQjNdKTtcbiAgZGVidWcoXCJhY3Rpb24gJW9cIiwgYWN0aW9uKTtcblxuICB2YXIgdHJhY2U7XG4gIGlmIChhY3Rpb24udHlwZSA9PSBhY3Rpb25zLlJFQ0VJVkVfVFJBQ0UpIHtcbiAgICB0cmFjZSA9IGFjdGlvbi50cmFjZTtcbiAgICBkZWJ1ZyhcInJlY2VpdmVkIHRyYWNlXCIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IGVycm9yOiBhY3Rpb24uZXJyb3IgfTtcbiAgfVxuXG4gIGxldCB7XG4gICAgYWRkcmVzcyxcbiAgICBiaW5hcnksXG4gICAgZGF0YSxcbiAgICBzdG9yYWdlQWRkcmVzcyxcbiAgICBzdGF0dXMsXG4gICAgc2VuZGVyLFxuICAgIHZhbHVlLFxuICAgIGdhc3ByaWNlLFxuICAgIGJsb2NrXG4gIH0gPSB5aWVsZCB0YWtlKGFjdGlvbnMuUkVDRUlWRV9DQUxMKTtcbiAgZGVidWcoXCJyZWNlaXZlZCBjYWxsXCIpO1xuXG4gIHJldHVybiB7XG4gICAgdHJhY2UsXG4gICAgYWRkcmVzcyxcbiAgICBiaW5hcnksXG4gICAgZGF0YSxcbiAgICBzdG9yYWdlQWRkcmVzcyxcbiAgICBzdGF0dXMsXG4gICAgc2VuZGVyLFxuICAgIHZhbHVlLFxuICAgIGdhc3ByaWNlLFxuICAgIGJsb2NrXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogb2J0YWluQmluYXJpZXMoYWRkcmVzc2VzKSB7XG4gIGxldCB0YXNrcyA9IHlpZWxkIGFsbChhZGRyZXNzZXMubWFwKGFkZHJlc3MgPT4gZm9yayhyZWNlaXZlQmluYXJ5LCBhZGRyZXNzKSkpO1xuXG4gIGRlYnVnKFwicmVxdWVzdGluZyBiaW5hcmllc1wiKTtcbiAgeWllbGQgYWxsKGFkZHJlc3Nlcy5tYXAoYWRkcmVzcyA9PiBwdXQoYWN0aW9ucy5mZXRjaEJpbmFyeShhZGRyZXNzKSkpKTtcblxuICBsZXQgYmluYXJpZXMgPSBbXTtcbiAgYmluYXJpZXMgPSB5aWVsZCBhbGwodGFza3MubWFwKHRhc2sgPT4gam9pbih0YXNrKSkpO1xuXG4gIGRlYnVnKFwiYmluYXJpZXMgJW9cIiwgYmluYXJpZXMpO1xuXG4gIHJldHVybiBiaW5hcmllcztcbn1cblxuZnVuY3Rpb24qIHJlY2VpdmVCaW5hcnkoYWRkcmVzcykge1xuICBsZXQgeyBiaW5hcnkgfSA9IHlpZWxkIHRha2UoXG4gICAgYWN0aW9uID0+IGFjdGlvbi50eXBlID09IGFjdGlvbnMuUkVDRUlWRV9CSU5BUlkgJiYgYWN0aW9uLmFkZHJlc3MgPT0gYWRkcmVzc1xuICApO1xuICBkZWJ1ZyhcImdvdCBiaW5hcnkgZm9yICVzXCIsIGFkZHJlc3MpO1xuXG4gIHJldHVybiBiaW5hcnk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogc2FnYSgpIHtcbiAgLy8gd2FpdCBmb3Igd2ViMyBpbml0IHNpZ25hbFxuICBsZXQgeyBwcm92aWRlciB9ID0geWllbGQgdGFrZShhY3Rpb25zLklOSVRfV0VCMyk7XG4gIGxldCBhZGFwdGVyID0gbmV3IFdlYjNBZGFwdGVyKHByb3ZpZGVyKTtcblxuICB5aWVsZCB0YWtlRXZlcnkoYWN0aW9ucy5JTlNQRUNULCBmZXRjaFRyYW5zYWN0aW9uSW5mbywgYWRhcHRlcik7XG4gIHlpZWxkIHRha2VFdmVyeShhY3Rpb25zLkZFVENIX0JJTkFSWSwgZmV0Y2hCaW5hcnksIGFkYXB0ZXIpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBwcmVmaXhOYW1lKFwid2ViM1wiLCBzYWdhKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvd2ViMy9zYWdhcy9pbmRleC5qcyIsImV4cG9ydCBjb25zdCBJTklUX1dFQjMgPSBcIklOSVRfV0VCM1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGluaXQocHJvdmlkZXIpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBJTklUX1dFQjMsXG4gICAgcHJvdmlkZXJcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IElOU1BFQ1QgPSBcIklOU1BFQ1RfVFJBTlNBQ1RJT05cIjtcbmV4cG9ydCBmdW5jdGlvbiBpbnNwZWN0KHR4SGFzaCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IElOU1BFQ1QsXG4gICAgdHhIYXNoXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBGRVRDSF9CSU5BUlkgPSBcIkZFVENIX0JJTkFSWVwiO1xuZXhwb3J0IGZ1bmN0aW9uIGZldGNoQmluYXJ5KGFkZHJlc3MpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBGRVRDSF9CSU5BUlksXG4gICAgYWRkcmVzc1xuICB9O1xufVxuXG5leHBvcnQgY29uc3QgUkVDRUlWRV9CSU5BUlkgPSBcIlJFQ0VJVkVfQklOQVJZXCI7XG5leHBvcnQgZnVuY3Rpb24gcmVjZWl2ZUJpbmFyeShhZGRyZXNzLCBiaW5hcnkpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBSRUNFSVZFX0JJTkFSWSxcbiAgICBhZGRyZXNzLFxuICAgIGJpbmFyeVxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgUkVDRUlWRV9UUkFDRSA9IFwiUkVDRUlWRV9UUkFDRVwiO1xuZXhwb3J0IGZ1bmN0aW9uIHJlY2VpdmVUcmFjZSh0cmFjZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFJFQ0VJVkVfVFJBQ0UsXG4gICAgdHJhY2VcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IFJFQ0VJVkVfQ0FMTCA9IFwiUkVDRUlWRV9DQUxMXCI7XG5leHBvcnQgZnVuY3Rpb24gcmVjZWl2ZUNhbGwoe1xuICBhZGRyZXNzLFxuICBiaW5hcnksXG4gIGRhdGEsXG4gIHN0b3JhZ2VBZGRyZXNzLFxuICBzdGF0dXMsXG4gIHNlbmRlcixcbiAgdmFsdWUsXG4gIGdhc3ByaWNlLFxuICBibG9ja1xufSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFJFQ0VJVkVfQ0FMTCxcbiAgICBhZGRyZXNzLFxuICAgIGJpbmFyeSxcbiAgICBkYXRhLFxuICAgIHN0b3JhZ2VBZGRyZXNzLFxuICAgIHN0YXR1cywgLy9vbmx5IHVzZWQgZm9yIGNyZWF0aW9uIGNhbGxzIGF0IHByZXNlbnQhXG4gICAgc2VuZGVyLFxuICAgIHZhbHVlLFxuICAgIGdhc3ByaWNlLFxuICAgIGJsb2NrXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBFUlJPUl9XRUIzID0gXCJFUlJPUl9XRUIzXCI7XG5leHBvcnQgZnVuY3Rpb24gZXJyb3IoZXJyb3IpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBFUlJPUl9XRUIzLFxuICAgIGVycm9yXG4gIH07XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3dlYjMvYWN0aW9ucy9pbmRleC5qcyIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjp3ZWIzOmFkYXB0ZXJcIik7XG5cbmltcG9ydCBXZWIzIGZyb20gXCJ3ZWIzXCI7XG5pbXBvcnQgeyBwcm9taXNpZnkgfSBmcm9tIFwidXRpbFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXZWIzQWRhcHRlciB7XG4gIGNvbnN0cnVjdG9yKHByb3ZpZGVyKSB7XG4gICAgdGhpcy53ZWIzID0gbmV3IFdlYjMocHJvdmlkZXIpO1xuICB9XG5cbiAgYXN5bmMgZ2V0VHJhY2UodHhIYXNoKSB7XG4gICAgbGV0IHJlc3VsdCA9IGF3YWl0IHByb21pc2lmeSh0aGlzLndlYjMuY3VycmVudFByb3ZpZGVyLnNlbmQpKFxuICAgICAgLy9zZW5kICpvbmx5KiB1c2VzIGNhbGxiYWNrcywgc28gd2UgdXNlIHByb21zaWZpeSB0byBtYWtlIHRoaW5ncyBtb3JlXG4gICAgICAvL3JlYWRhYmxlXG4gICAgICB7XG4gICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgIG1ldGhvZDogXCJkZWJ1Z190cmFjZVRyYW5zYWN0aW9uXCIsXG4gICAgICAgIHBhcmFtczogW3R4SGFzaCwge31dLFxuICAgICAgICBpZDogbmV3IERhdGUoKS5nZXRUaW1lKClcbiAgICAgIH1cbiAgICApO1xuICAgIGlmIChyZXN1bHQuZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihyZXN1bHQuZXJyb3IubWVzc2FnZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXN1bHQucmVzdWx0LnN0cnVjdExvZ3M7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb24odHhIYXNoKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMud2ViMy5ldGguZ2V0VHJhbnNhY3Rpb24odHhIYXNoKTtcbiAgfVxuXG4gIGFzeW5jIGdldFJlY2VpcHQodHhIYXNoKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMud2ViMy5ldGguZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHR4SGFzaCk7XG4gIH1cblxuICBhc3luYyBnZXRCbG9jayhibG9ja051bWJlck9ySGFzaCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLndlYjMuZXRoLmdldEJsb2NrKGJsb2NrTnVtYmVyT3JIYXNoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXREZXBsb3llZENvZGUgLSBnZXQgdGhlIGRlcGxveWVkIGNvZGUgZm9yIGFuIGFkZHJlc3MgZnJvbSB0aGUgY2xpZW50XG4gICAqIEBwYXJhbSAge1N0cmluZ30gYWRkcmVzc1xuICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgZGVwbG95ZWRCaW5hcnlcbiAgICovXG4gIGFzeW5jIGdldERlcGxveWVkQ29kZShhZGRyZXNzKSB7XG4gICAgZGVidWcoXCJnZXR0aW5nIGRlcGxveWVkIGNvZGUgZm9yICVzXCIsIGFkZHJlc3MpO1xuICAgIGxldCBjb2RlID0gYXdhaXQgdGhpcy53ZWIzLmV0aC5nZXRDb2RlKGFkZHJlc3MpO1xuICAgIHJldHVybiBjb2RlID09PSBcIjB4MFwiID8gXCIweFwiIDogY29kZTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi93ZWIzL2FkYXB0ZXIuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwidXRpbFwiXG4vLyBtb2R1bGUgaWQgPSA1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBjb21iaW5lUmVkdWNlcnMgfSBmcm9tIFwicmVkdXhcIjtcblxuaW1wb3J0IGRhdGEgZnJvbSBcImxpYi9kYXRhL3JlZHVjZXJzXCI7XG5pbXBvcnQgZXZtIGZyb20gXCJsaWIvZXZtL3JlZHVjZXJzXCI7XG5pbXBvcnQgc29saWRpdHkgZnJvbSBcImxpYi9zb2xpZGl0eS9yZWR1Y2Vyc1wiO1xuaW1wb3J0IHRyYWNlIGZyb20gXCJsaWIvdHJhY2UvcmVkdWNlcnNcIjtcbmltcG9ydCBjb250cm9sbGVyIGZyb20gXCJsaWIvY29udHJvbGxlci9yZWR1Y2Vyc1wiO1xuXG5pbXBvcnQgKiBhcyBhY3Rpb25zIGZyb20gXCIuL2FjdGlvbnNcIjtcblxuZXhwb3J0IGNvbnN0IFdBSVRJTkcgPSBcIldBSVRJTkdcIjtcbmV4cG9ydCBjb25zdCBBQ1RJVkUgPSBcIkFDVElWRVwiO1xuZXhwb3J0IGNvbnN0IEVSUk9SID0gXCJFUlJPUlwiO1xuXG5mdW5jdGlvbiBzdGF0dXMoc3RhdGUgPSBXQUlUSU5HLCBhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgYWN0aW9ucy5SRUFEWTpcbiAgICAgIHJldHVybiBBQ1RJVkU7XG5cbiAgICBjYXNlIGFjdGlvbnMuRVJST1I6XG4gICAgICByZXR1cm4geyBlcnJvcjogYWN0aW9uLmVycm9yIH07XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyYW5zYWN0aW9uKHN0YXRlID0ge30sIGFjdGlvbikge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBhY3Rpb25zLlNBVkVfVFJBTlNBQ1RJT046XG4gICAgICByZXR1cm4gYWN0aW9uLnRyYW5zYWN0aW9uO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjZWlwdChzdGF0ZSA9IHt9LCBhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgYWN0aW9ucy5TQVZFX1JFQ0VJUFQ6XG4gICAgICByZXR1cm4gYWN0aW9uLnJlY2VpcHQ7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBibG9jayhzdGF0ZSA9IHt9LCBhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgYWN0aW9ucy5TQVZFX0JMT0NLOlxuICAgICAgcmV0dXJuIGFjdGlvbi5ibG9jaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbmNvbnN0IHNlc3Npb24gPSBjb21iaW5lUmVkdWNlcnMoe1xuICBzdGF0dXMsXG4gIHRyYW5zYWN0aW9uLFxuICByZWNlaXB0LFxuICBibG9ja1xufSk7XG5cbmNvbnN0IHJlZHVjZVN0YXRlID0gY29tYmluZVJlZHVjZXJzKHtcbiAgc2Vzc2lvbixcbiAgZGF0YSxcbiAgZXZtLFxuICBzb2xpZGl0eSxcbiAgdHJhY2UsXG4gIGNvbnRyb2xsZXJcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCByZWR1Y2VTdGF0ZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvc2Vzc2lvbi9yZWR1Y2Vycy5qcyIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjpkYXRhOnJlZHVjZXJzXCIpO1xuXG5pbXBvcnQgeyBjb21iaW5lUmVkdWNlcnMgfSBmcm9tIFwicmVkdXhcIjtcblxuaW1wb3J0ICogYXMgYWN0aW9ucyBmcm9tIFwiLi9hY3Rpb25zXCI7XG5cbmltcG9ydCB7IHNsb3RBZGRyZXNzIH0gZnJvbSBcInRydWZmbGUtZGVjb2RlclwiO1xuaW1wb3J0IHsgbWFrZUFzc2lnbm1lbnQgfSBmcm9tIFwibGliL2hlbHBlcnNcIjtcbmltcG9ydCB7IENvbnZlcnNpb24sIERlZmluaXRpb24sIEVWTSB9IGZyb20gXCJ0cnVmZmxlLWRlY29kZS11dGlsc1wiO1xuXG5jb25zdCBERUZBVUxUX1NDT1BFUyA9IHtcbiAgYnlJZDoge31cbn07XG5cbmZ1bmN0aW9uIHNjb3BlcyhzdGF0ZSA9IERFRkFVTFRfU0NPUEVTLCBhY3Rpb24pIHtcbiAgdmFyIHNjb3BlO1xuICB2YXIgdmFyaWFibGVzO1xuXG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIGFjdGlvbnMuU0NPUEU6XG4gICAgICBzY29wZSA9IHN0YXRlLmJ5SWRbYWN0aW9uLmlkXSB8fCB7fTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYnlJZDoge1xuICAgICAgICAgIC4uLnN0YXRlLmJ5SWQsXG5cbiAgICAgICAgICBbYWN0aW9uLmlkXToge1xuICAgICAgICAgICAgLi4uc2NvcGUsXG5cbiAgICAgICAgICAgIGlkOiBhY3Rpb24uaWQsXG4gICAgICAgICAgICBzb3VyY2VJZDogYWN0aW9uLnNvdXJjZUlkLFxuICAgICAgICAgICAgcGFyZW50SWQ6IGFjdGlvbi5wYXJlbnRJZCxcbiAgICAgICAgICAgIHBvaW50ZXI6IGFjdGlvbi5wb2ludGVyXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgY2FzZSBhY3Rpb25zLkRFQ0xBUkU6XG4gICAgICBzY29wZSA9IHN0YXRlLmJ5SWRbYWN0aW9uLm5vZGUuc2NvcGVdIHx8IHt9O1xuICAgICAgdmFyaWFibGVzID0gc2NvcGUudmFyaWFibGVzIHx8IFtdO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBieUlkOiB7XG4gICAgICAgICAgLi4uc3RhdGUuYnlJZCxcblxuICAgICAgICAgIFthY3Rpb24ubm9kZS5zY29wZV06IHtcbiAgICAgICAgICAgIC4uLnNjb3BlLFxuXG4gICAgICAgICAgICB2YXJpYWJsZXM6IFtcbiAgICAgICAgICAgICAgLi4udmFyaWFibGVzLFxuXG4gICAgICAgICAgICAgIHsgbmFtZTogYWN0aW9uLm5vZGUubmFtZSwgaWQ6IGFjdGlvbi5ub2RlLmlkIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbi8vYSBub3RlIG9uIHRoZSBmb2xsb3dpbmcgcmVkdWNlcjogc29saWRpdHkgYXNzaWducyBhIHVuaXF1ZSBBU1QgSUQgdG8gZXZlcnlcbi8vQVNUIG5vZGUgYW1vbmcgYWxsIHRoZSBmaWxlcyBiZWluZyBjb21waWxlZCB0b2dldGhlci4gIHRodXMsIGl0IGlzLCBmb3Igbm93LFxuLy9zYWZlIHRvIGlkZW50aWZ5IHVzZXItZGVmaW5lZCB0eXBlcyBzb2xlbHkgYnkgdGhlaXIgQVNUIElELiAgSW4gdGhlIGZ1dHVyZSxcbi8vb25jZSB3ZSBldmVudHVhbGx5IHN1cHBvcnQgaGF2aW5nIHNvbWUgZmlsZXMgY29tcGlsZWQgc2VwYXJhdGVseSBmcm9tIG90aGVycyxcbi8vdGhpcyB3aWxsIGJlY29tZSBhIGJ1ZyB5b3UnbGwgaGF2ZSB0byBmaXgsIGFuZCB5b3UnbGwgaGF2ZSB0byBmaXggaXQgaW4gdGhlXG4vL2RlY29kZXIsIHRvby4gIFNvcnJ5LCBmdXR1cmUgbWUhIChvciB3aG9ldmVyJ3Mgc3R1Y2sgZG9pbmcgdGhpcylcblxuZnVuY3Rpb24gdXNlckRlZmluZWRUeXBlcyhzdGF0ZSA9IFtdLCBhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgYWN0aW9ucy5ERUZJTkVfVFlQRTpcbiAgICAgIHJldHVybiBbLi4uc3RhdGUsIGFjdGlvbi5ub2RlLmlkXTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbmNvbnN0IERFRkFVTFRfQUxMT0NBVElPTlMgPSB7XG4gIHN0b3JhZ2U6IHt9LFxuICBtZW1vcnk6IHt9LFxuICBjYWxsZGF0YToge31cbn07XG5cbmZ1bmN0aW9uIGFsbG9jYXRpb25zKHN0YXRlID0gREVGQVVMVF9BTExPQ0FUSU9OUywgYWN0aW9uKSB7XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5BTExPQ0FURSkge1xuICAgIHJldHVybiB7XG4gICAgICBzdG9yYWdlOiBhY3Rpb24uc3RvcmFnZSxcbiAgICAgIG1lbW9yeTogYWN0aW9uLm1lbW9yeSxcbiAgICAgIGNhbGxkYXRhOiBhY3Rpb24uY2FsbGRhdGFcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5jb25zdCBpbmZvID0gY29tYmluZVJlZHVjZXJzKHtcbiAgc2NvcGVzLFxuICB1c2VyRGVmaW5lZFR5cGVzLFxuICBhbGxvY2F0aW9uc1xufSk7XG5cbmNvbnN0IEdMT0JBTF9BU1NJR05NRU5UUyA9IFtcbiAgW3sgYnVpbHRpbjogXCJtc2dcIiB9LCB7IHNwZWNpYWw6IFwibXNnXCIgfV0sXG4gIFt7IGJ1aWx0aW46IFwidHhcIiB9LCB7IHNwZWNpYWw6IFwidHhcIiB9XSxcbiAgW3sgYnVpbHRpbjogXCJibG9ja1wiIH0sIHsgc3BlY2lhbDogXCJibG9ja1wiIH1dLFxuICBbeyBidWlsdGluOiBcInRoaXNcIiB9LCB7IHNwZWNpYWw6IFwidGhpc1wiIH1dLFxuICBbeyBidWlsdGluOiBcIm5vd1wiIH0sIHsgc3BlY2lhbDogXCJ0aW1lc3RhbXBcIiB9XSAvL3dlIGRvbid0IGhhdmUgYW4gYWxpYXMgXCJub3dcIlxuXS5tYXAoKFtpZE9iaiwgcmVmXSkgPT4gbWFrZUFzc2lnbm1lbnQoaWRPYmosIHJlZikpO1xuXG5jb25zdCBERUZBVUxUX0FTU0lHTk1FTlRTID0ge1xuICBieUlkOiBPYmplY3QuYXNzaWduKFxuICAgIHt9LCAvL3dlIHN0YXJ0IG91dCB3aXRoIGFsbCBnbG9iYWxzIGFzc2lnbmVkXG4gICAgLi4uR0xPQkFMX0FTU0lHTk1FTlRTLm1hcChhc3NpZ25tZW50ID0+ICh7IFthc3NpZ25tZW50LmlkXTogYXNzaWdubWVudCB9KSlcbiAgKSxcbiAgYnlBc3RJZDoge30sIC8vbm8gcmVndWxhciB2YXJpYWJsZXMgYXNzaWduZWQgYXQgc3RhcnRcbiAgYnlCdWlsdGluOiBPYmplY3QuYXNzaWduKFxuICAgIHt9LCAvL2FnYWluLCBhbGwgZ2xvYmFscyBzdGFydCBhc3NpZ25lZFxuICAgIC4uLkdMT0JBTF9BU1NJR05NRU5UUy5tYXAoYXNzaWdubWVudCA9PiAoe1xuICAgICAgW2Fzc2lnbm1lbnQuYnVpbHRpbl06IFthc3NpZ25tZW50LmlkXSAvL3llcywgdGhhdCdzIGEgMS1lbGVtZW50IGFycmF5XG4gICAgfSkpXG4gIClcbn07XG5cbmZ1bmN0aW9uIGFzc2lnbm1lbnRzKHN0YXRlID0gREVGQVVMVF9BU1NJR05NRU5UUywgYWN0aW9uKSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIGFjdGlvbnMuQVNTSUdOOlxuICAgIGNhc2UgYWN0aW9ucy5NQVBfUEFUSF9BTkRfQVNTSUdOOlxuICAgICAgZGVidWcoXCJhY3Rpb24udHlwZSAlT1wiLCBhY3Rpb24udHlwZSk7XG4gICAgICBkZWJ1ZyhcImFjdGlvbi5hc3NpZ25tZW50cyAlT1wiLCBhY3Rpb24uYXNzaWdubWVudHMpO1xuICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoYWN0aW9uLmFzc2lnbm1lbnRzKS5yZWR1Y2UoKGFjYywgYXNzaWdubWVudCkgPT4ge1xuICAgICAgICBsZXQgeyBpZCwgYXN0SWQgfSA9IGFzc2lnbm1lbnQ7XG4gICAgICAgIC8vd2UgYXNzdW1lIGZvciBub3cgdGhhdCBvbmx5IG9yZGluYXJ5IHZhcmlhYmxlcyB3aWxsIGJlIGFzc2lnbmVkIHRoaXNcbiAgICAgICAgLy93YXksIGFuZCBub3QgZ2xvYmFsczsgZ2xvYmFscyBhcmUgaGFuZGxlZCBpbiBERUZBVUxUX0FTU0lHTk1FTlRTXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uYWNjLFxuICAgICAgICAgIGJ5SWQ6IHtcbiAgICAgICAgICAgIC4uLmFjYy5ieUlkLFxuICAgICAgICAgICAgW2lkXTogYXNzaWdubWVudFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYnlBc3RJZDoge1xuICAgICAgICAgICAgLi4uYWNjLmJ5QXN0SWQsXG4gICAgICAgICAgICBbYXN0SWRdOiBbLi4ubmV3IFNldChbLi4uKGFjYy5ieUFzdElkW2FzdElkXSB8fCBbXSksIGlkXSldXG4gICAgICAgICAgICAvL3dlIHVzZSBhIHNldCBmb3IgdW5pcXVlbmVzc1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0sIHN0YXRlKTtcblxuICAgIGNhc2UgYWN0aW9ucy5SRVNFVDpcbiAgICAgIHJldHVybiBERUZBVUxUX0FTU0lHTk1FTlRTO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5jb25zdCBERUZBVUxUX1BBVEhTID0ge1xuICBkZWNvZGluZ1N0YXJ0ZWQ6IDAsXG4gIGJ5QWRkcmVzczoge31cbn07XG5cbi8vV0FSTklORzogZG8gKm5vdCogcmVseSBvbiBtYXBwZWRQYXRocyB0byBrZWVwIHRyYWNrIG9mIHBhdGhzIHRoYXQgZG8gbm90XG4vL2ludm9sdmUgbWFwcGluZyBrZXlzISAgWWVzLCBtYW55IHdpbGwgZ2V0IG1hcHBlZCwgYnV0IHRoZXJlIGlzIG5vIGd1YXJhbnRlZS5cbi8vT25seSB3aGVuIG1hcHBpbmcga2V5cyBhcmUgaW52b2x2ZWQgZG9lcyBpdCBuZWNlc3NhcmlseSB3b3JrIHJlbGlhYmx5IC0tXG4vL3doaWNoIGlzIGZpbmUsIGFzIHRoYXQncyBhbGwgd2UgbmVlZCBpdCBmb3IuXG5mdW5jdGlvbiBtYXBwZWRQYXRocyhzdGF0ZSA9IERFRkFVTFRfUEFUSFMsIGFjdGlvbikge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBhY3Rpb25zLk1BUF9LRVlfREVDT0RJTkc6XG4gICAgICBkZWJ1ZyhcbiAgICAgICAgXCJkZWNvZGluZyBzdGFydGVkOiAlZFwiLFxuICAgICAgICBzdGF0ZS5kZWNvZGluZ1N0YXJ0ZWQgKyAoYWN0aW9uLnN0YXJ0ZWQgPyAxIDogLTEpXG4gICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGRlY29kaW5nU3RhcnRlZDogc3RhdGUuZGVjb2RpbmdTdGFydGVkICsgKGFjdGlvbi5zdGFydGVkID8gMSA6IC0xKVxuICAgICAgfTtcbiAgICBjYXNlIGFjdGlvbnMuTUFQX1BBVEhfQU5EX0FTU0lHTjpcbiAgICAgIGxldCB7IGFkZHJlc3MsIHNsb3QsIHR5cGVJZGVudGlmaWVyLCBwYXJlbnRUeXBlIH0gPSBhY3Rpb247XG4gICAgICAvL2hvdyB0aGlzIGNhc2Ugd29ya3M6IGZpcnN0LCB3ZSBmaW5kIHRoZSBzcG90IGluIG91ciB0YWJsZSAoYmFzZWQgb25cbiAgICAgIC8vYWRkcmVzcywgdHlwZSBpZGVudGlmaWVyLCBhbmQgc2xvdCBhZGRyZXNzKSB3aGVyZSB0aGUgbmV3IGVudHJ5IHNob3VsZFxuICAgICAgLy9iZSBhZGRlZDsgaWYgbmVlZGVkIHdlIHNldCB1cCBhbGwgdGhlIG9iamVjdHMgbmVlZGVkIGFsb25nIHRoZSB3YXkuICBJZlxuICAgICAgLy90aGVyZSdzIGFscmVhZHkgc29tZXRoaW5nIHRoZXJlLCB3ZSBkbyBub3RoaW5nLiAgSWYgdGhlcmUncyBub3RoaW5nXG4gICAgICAvL3RoZXJlLCB3ZSByZWNvcmQgb3VyIGdpdmVuIHNsb3QgaW4gdGhhdCBzcG90IGluIHRoYXQgdGFibGUgLS0gaG93ZXZlcixcbiAgICAgIC8vd2UgYWx0ZXIgaXQgaW4gb25lIGtleSB3YXkuICBCZWZvcmUgZW50cnksIHdlIGNoZWNrIGlmIHRoZSBzbG90J3NcbiAgICAgIC8vKnBhcmVudCogaGFzIGEgc3BvdCBpbiB0aGUgdGFibGUsIGJhc2VkIG9uIGFkZHJlc3MgKHNhbWUgZm9yIGJvdGggY2hpbGRcbiAgICAgIC8vYW5kIHBhcmVudCksIHBhcmVudFR5cGUsIGFuZCB0aGUgcGFyZW50J3Mgc2xvdCBhZGRyZXNzICh3aGljaCBjYW4gYmVcbiAgICAgIC8vZm91bmQgYXMgdGhlIHNsb3RBZGRyZXNzIG9mIHRoZSBzbG90J3MgcGF0aCBvYmplY3QsIGlmIGl0IGV4aXN0cyAtLSBpZlxuICAgICAgLy9pdCBkb2Vzbid0IHRoZW4gd2UgY29uY2x1ZGUgdGhhdCBubyB0aGUgcGFyZW50IGRvZXMgbm90IGhhdmUgYSBzcG90IGluXG4gICAgICAvL3RoZSB0YWJsZSkuICBJZiB0aGUgcGFyZW50IGhhcyBhIHNsb3QgaW4gdGhlIHRhYmxlIGFscmVhZHksIHRoZW4gd2VcbiAgICAgIC8vYWx0ZXIgdGhlIGNoaWxkIHNsb3QgYnkgcmVwbGFjaW5nIGl0cyBwYXRoIHdpdGggdGhlIHBhcmVudCBzbG90LiAgVGhpc1xuICAgICAgLy93aWxsIGtlZXAgdGhlIHNsb3RBZGRyZXNzIHRoZSBzYW1lLCBidXQgc2luY2UgdGhlIHZlcnNpb25zIGtlcHQgaW4gdGhlXG4gICAgICAvL3RhYmxlIGhlcmUgYXJlIHN1cHBvc2VkIHRvIHByZXNlcnZlIHBhdGggaW5mb3JtYXRpb24sIHdlJ2xsIGJlXG4gICAgICAvL3JlcGxhY2luZyBhIGZhaXJseSBiYXJlLWJvbmVzIFNsb3Qgb2JqZWN0IHdpdGggb25lIHdpdGggYSBmdWxsIHBhdGguXG5cbiAgICAgIC8vd2UgZG8gTk9UIHdhbnQgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiB0eXBlcyB3aXRoIGFuZCB3aXRob3V0IFwiX3B0clwiIG9uXG4gICAgICAvL3RoZSBlbmQgaGVyZSFcbiAgICAgIGRlYnVnKFwidHlwZUlkZW50aWZpZXIgJXNcIiwgdHlwZUlkZW50aWZpZXIpO1xuICAgICAgdHlwZUlkZW50aWZpZXIgPSBEZWZpbml0aW9uLnJlc3RvcmVQdHIodHlwZUlkZW50aWZpZXIpO1xuICAgICAgcGFyZW50VHlwZSA9IERlZmluaXRpb24ucmVzdG9yZVB0cihwYXJlbnRUeXBlKTtcblxuICAgICAgZGVidWcoXCJzbG90ICVvXCIsIHNsb3QpO1xuICAgICAgbGV0IGhleFNsb3RBZGRyZXNzID0gQ29udmVyc2lvbi50b0hleFN0cmluZyhcbiAgICAgICAgc2xvdEFkZHJlc3Moc2xvdCksXG4gICAgICAgIEVWTS5XT1JEX1NJWkVcbiAgICAgICk7XG4gICAgICBsZXQgcGFyZW50QWRkcmVzcyA9IHNsb3QucGF0aFxuICAgICAgICA/IENvbnZlcnNpb24udG9IZXhTdHJpbmcoc2xvdEFkZHJlc3Moc2xvdC5wYXRoKSwgRVZNLldPUkRfU0laRSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgIC8vdGhpcyBpcyBnb2luZyB0byBiZSBtZXNzeSBhbmQgcHJvY2VkdXJhbCwgc29ycnkuICBidXQgbGV0J3Mgc3RhcnQgd2l0aFxuICAgICAgLy90aGUgZWFzeSBzdHVmZjogY3JlYXRlIHRoZSBuZXcgYWRkcmVzcyBpZiBuZWVkZWQsIGNsb25lIGlmIG5vdFxuICAgICAgbGV0IG5ld1N0YXRlID0ge1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgYnlBZGRyZXNzOiB7XG4gICAgICAgICAgLi4uc3RhdGUuYnlBZGRyZXNzLFxuICAgICAgICAgIFthZGRyZXNzXToge1xuICAgICAgICAgICAgYnlUeXBlOiB7XG4gICAgICAgICAgICAgIC4uLihzdGF0ZS5ieUFkZHJlc3NbYWRkcmVzc10gfHwgeyBieVR5cGU6IHt9IH0pLmJ5VHlwZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy9ub3csIGxldCdzIGFkZCBpbiB0aGUgbmV3IHR5cGUsIGlmIG5lZWRlZFxuICAgICAgbmV3U3RhdGUuYnlBZGRyZXNzW2FkZHJlc3NdLmJ5VHlwZSA9IHtcbiAgICAgICAgLi4ubmV3U3RhdGUuYnlBZGRyZXNzW2FkZHJlc3NdLmJ5VHlwZSxcbiAgICAgICAgW3R5cGVJZGVudGlmaWVyXToge1xuICAgICAgICAgIGJ5U2xvdEFkZHJlc3M6IHtcbiAgICAgICAgICAgIC4uLihcbiAgICAgICAgICAgICAgbmV3U3RhdGUuYnlBZGRyZXNzW2FkZHJlc3NdLmJ5VHlwZVt0eXBlSWRlbnRpZmllcl0gfHwge1xuICAgICAgICAgICAgICAgIGJ5U2xvdEFkZHJlc3M6IHt9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICkuYnlTbG90QWRkcmVzc1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgbGV0IG9sZFNsb3QgPVxuICAgICAgICBuZXdTdGF0ZS5ieUFkZHJlc3NbYWRkcmVzc10uYnlUeXBlW3R5cGVJZGVudGlmaWVyXS5ieVNsb3RBZGRyZXNzW1xuICAgICAgICAgIGhleFNsb3RBZGRyZXNzXG4gICAgICAgIF07XG4gICAgICAvL3llcywgdGhpcyBsb29rcyBzdHJhbmdlLCBidXQgd2UgaGF2ZW4ndCBjaGFuZ2VkIGl0IHlldCBleGNlcHQgdG9cbiAgICAgIC8vY2xvbmUgb3IgY3JlYXRlIGVtcHR5IChhbmQgd2UgZG9uJ3Qgd2FudCB1bmRlZmluZWQhKVxuICAgICAgLy9ub3c6IGlzIHRoZXJlIHNvbWV0aGluZyBhbHJlYWR5IHRoZXJlIG9yIG5vPyAgaWYgbm8sIHdlIG11c3QgYWRkXG4gICAgICBpZiAob2xkU2xvdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCBuZXdTbG90O1xuICAgICAgICBkZWJ1ZyhcInBhcmVudEFkZHJlc3MgJW9cIiwgcGFyZW50QWRkcmVzcyk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBwYXJlbnRBZGRyZXNzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICBuZXdTdGF0ZS5ieUFkZHJlc3NbYWRkcmVzc10uYnlUeXBlW3BhcmVudFR5cGVdICYmXG4gICAgICAgICAgbmV3U3RhdGUuYnlBZGRyZXNzW2FkZHJlc3NdLmJ5VHlwZVtwYXJlbnRUeXBlXS5ieVNsb3RBZGRyZXNzW1xuICAgICAgICAgICAgcGFyZW50QWRkcmVzc1xuICAgICAgICAgIF1cbiAgICAgICAgKSB7XG4gICAgICAgICAgLy9pZiB0aGUgcGFyZW50IGlzIGFscmVhZHkgcHJlc2VudCwgdXNlIHRoYXQgaW5zdGVhZCBvZiB0aGUgZ2l2ZW5cbiAgICAgICAgICAvL3BhcmVudCFcbiAgICAgICAgICBuZXdTbG90ID0ge1xuICAgICAgICAgICAgLi4uc2xvdCxcbiAgICAgICAgICAgIHBhdGg6XG4gICAgICAgICAgICAgIG5ld1N0YXRlLmJ5QWRkcmVzc1thZGRyZXNzXS5ieVR5cGVbcGFyZW50VHlwZV0uYnlTbG90QWRkcmVzc1tcbiAgICAgICAgICAgICAgICBwYXJlbnRBZGRyZXNzXG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld1Nsb3QgPSBzbG90O1xuICAgICAgICB9XG4gICAgICAgIG5ld1N0YXRlLmJ5QWRkcmVzc1thZGRyZXNzXS5ieVR5cGVbdHlwZUlkZW50aWZpZXJdLmJ5U2xvdEFkZHJlc3NbXG4gICAgICAgICAgaGV4U2xvdEFkZHJlc3NcbiAgICAgICAgXSA9IG5ld1Nsb3Q7XG4gICAgICB9XG4gICAgICAvL2lmIHRoZXJlJ3MgYWxyZWFkeSBzb21ldGhpbmcgdGhlcmUsIHdlIGRvbid0IG5lZWQgdG8gZG8gYW55dGhpbmdcblxuICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuXG4gICAgY2FzZSBhY3Rpb25zLlJFU0VUOlxuICAgICAgcmV0dXJuIERFRkFVTFRfUEFUSFM7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbmNvbnN0IHByb2MgPSBjb21iaW5lUmVkdWNlcnMoe1xuICBhc3NpZ25tZW50cyxcbiAgbWFwcGVkUGF0aHNcbn0pO1xuXG5jb25zdCByZWR1Y2VyID0gY29tYmluZVJlZHVjZXJzKHtcbiAgaW5mbyxcbiAgcHJvY1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHJlZHVjZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2RhdGEvcmVkdWNlcnMuanMiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6ZXZtOnJlZHVjZXJzXCIpO1xuXG5pbXBvcnQgeyBjb21iaW5lUmVkdWNlcnMgfSBmcm9tIFwicmVkdXhcIjtcblxuaW1wb3J0ICogYXMgYWN0aW9ucyBmcm9tIFwiLi9hY3Rpb25zXCI7XG5pbXBvcnQgeyBrZWNjYWsyNTYsIGV4dHJhY3RQcmltYXJ5U291cmNlIH0gZnJvbSBcImxpYi9oZWxwZXJzXCI7XG5pbXBvcnQgKiBhcyBEZWNvZGVVdGlscyBmcm9tIFwidHJ1ZmZsZS1kZWNvZGUtdXRpbHNcIjtcbmltcG9ydCBlc2NhcGVSZWdFeHAgZnJvbSBcImxvZGFzaC5lc2NhcGVyZWdleHBcIjtcblxuaW1wb3J0IEJOIGZyb20gXCJibi5qc1wiO1xuXG5jb25zdCBERUZBVUxUX0NPTlRFWFRTID0ge1xuICBieUNvbnRleHRzOiB7fVxufTtcblxuZnVuY3Rpb24gY29udGV4dHMoc3RhdGUgPSBERUZBVUxUX0NPTlRFWFRTLCBhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIC8qXG4gICAgICogQWRkaW5nIGEgbmV3IGNvbnRleHRcbiAgICAgKi9cbiAgICBjYXNlIGFjdGlvbnMuQUREX0NPTlRFWFQ6IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29udHJhY3ROYW1lLFxuICAgICAgICBiaW5hcnksXG4gICAgICAgIHNvdXJjZU1hcCxcbiAgICAgICAgY29tcGlsZXIsXG4gICAgICAgIGFiaSxcbiAgICAgICAgY29udHJhY3RJZCxcbiAgICAgICAgY29udHJhY3RLaW5kLFxuICAgICAgICBpc0NvbnN0cnVjdG9yXG4gICAgICB9ID0gYWN0aW9uO1xuICAgICAgZGVidWcoXCJhY3Rpb24gJU9cIiwgYWN0aW9uKTtcbiAgICAgIC8vTk9URTogd2UgdGFrZSBoYXNoIGFzICpzdHJpbmcqLCBub3QgYXMgYnl0ZXMsIGJlY2F1c2UgdGhlIGJpbmFyeSBtYXlcbiAgICAgIC8vY29udGFpbiBsaW5rIHJlZmVyZW5jZXMhXG4gICAgICBjb25zdCBjb250ZXh0ID0ga2VjY2FrMjU2KHsgdHlwZTogXCJzdHJpbmdcIiwgdmFsdWU6IGJpbmFyeSB9KTtcbiAgICAgIGxldCBwcmltYXJ5U291cmNlO1xuICAgICAgaWYgKHNvdXJjZU1hcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByaW1hcnlTb3VyY2UgPSBleHRyYWN0UHJpbWFyeVNvdXJjZShzb3VyY2VNYXApO1xuICAgICAgfVxuICAgICAgLy9vdGhlcndpc2UgbGVhdmUgaXQgdW5kZWZpbmVkXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBieUNvbnRleHQ6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5ieUNvbnRleHQsXG4gICAgICAgICAgW2NvbnRleHRdOiB7XG4gICAgICAgICAgICBjb250cmFjdE5hbWUsXG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgYmluYXJ5LFxuICAgICAgICAgICAgc291cmNlTWFwLFxuICAgICAgICAgICAgcHJpbWFyeVNvdXJjZSxcbiAgICAgICAgICAgIGNvbXBpbGVyLFxuICAgICAgICAgICAgYWJpLFxuICAgICAgICAgICAgY29udHJhY3RJZCxcbiAgICAgICAgICAgIGNvbnRyYWN0S2luZCxcbiAgICAgICAgICAgIGlzQ29uc3RydWN0b3JcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgY2FzZSBhY3Rpb25zLk5PUk1BTElaRV9DT05URVhUUzoge1xuICAgICAgLy91bmZvcnR1bmF0ZWx5LCBkdWUgdG8gb3VyIGN1cnJlbnQgbGluayByZWZlcmVuY2VzIGZvcm1hdCwgd2UgY2FuJ3RcbiAgICAgIC8vcmVhbGx5IHVzZSB0aGUgYmluYXJ5IGZybSB0aGUgYXJ0aWZhY3QgZGlyZWN0bHkgLS0gbmVpdGhlciBmb3IgcHVycG9zZXNcbiAgICAgIC8vb2YgbWF0Y2hpbmcsIG5vciBmb3IgcHVycG9zZXMgb2YgZGVjb2RpbmcgaW50ZXJuYWwgZnVuY3Rpb25zLiAgU28sIHdlXG4gICAgICAvL25lZWQgdG8gcGVyZm9ybSB0aGlzIG5vcm1hbGl6YXRpb24gc3RlcCBvbiBvdXIgY29udGV4dHMgYmVmb3JlIHVzaW5nXG4gICAgICAvL3RoZW0uICBPbmNlIHdlIGhhdmUgdHJ1ZmZsZS1kYiwgdGhpcyBzdGVwIHNob3VsZCBsYXJnZWx5IGdvIGF3YXkuXG5cbiAgICAgIGRlYnVnKFwibm9ybWFsaXppbmcgY29udGV4dHNcIik7XG5cbiAgICAgIC8vZmlyc3QsIGxldCdzIGNsb25lIHRoZSBzdGF0ZTsgd2UncmUgZ29pbmcgdG8gbWFrZSBzb21lIGRlZXAgbW9kaWZpY2F0aW9ucyxcbiAgICAgIC8vc28gd2UnbGwgd2FudCBtb3JlIHRoYW4gYSBzaGFsbG93IGNsb25lIGhlcmVcbiAgICAgIGxldCBuZXdTdGF0ZSA9IHtcbiAgICAgICAgYnlDb250ZXh0OiBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIC4uLk9iamVjdC5lbnRyaWVzKHN0YXRlLmJ5Q29udGV4dCkubWFwKChbaWQsIGNvbnRleHRdKSA9PiAoe1xuICAgICAgICAgICAgW2lkXToge1xuICAgICAgICAgICAgICAuLi5jb250ZXh0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpXG4gICAgICAgIClcbiAgICAgIH07XG5cbiAgICAgIGRlYnVnKFwic3RhdGUgY2xvbmVkXCIpO1xuXG4gICAgICAvL25leHQsIHdlIGdldCBhbGwgdGhlIGNvbnRyYWN0IG5hbWVzIGFuZCBzb3J0IHRoZW0gZGVzY2VuZGluZyBieSBsZW5ndGguXG4gICAgICAvL1dlJ3JlIGdvaW5nIHRvIHdhbnQgdG8gZ28gaW4gZGVzY2VuZGluZyBvcmRlciBvZiBsZW5ndGggc28gdGhhdCB3ZVxuICAgICAgLy9kb24ndCBydW4gaW50byBwcm9ibGVtcyB3aGVuIG9uZSBuYW1lIGlzIGEgc3Vic3RyaW5nIG9mIGFub3RoZXIuXG4gICAgICAvL0ZvciBzaW1wbGljaXR5LCB3ZSdsbCBleGNsdWRlIG5hbWVzIG9mIGxlbmd0aCA8MzgsIGJlY2F1c2Ugd2UgY2FuXG4gICAgICAvL2hhbmRsZSB0aGVzZSB3aXRoIG91ciBtb3JlIGdlbmVyYWwgY2hlY2sgZm9yIGxpbmsgcmVmZXJlbmNlcyBhdCB0aGUgZW5kXG4gICAgICBjb25zdCBmaWxsZXJMZW5ndGggPSAyICogRGVjb2RlVXRpbHMuRVZNLkFERFJFU1NfU0laRTtcbiAgICAgIGxldCBuYW1lcyA9IE9iamVjdC52YWx1ZXMobmV3U3RhdGUuYnlDb250ZXh0KVxuICAgICAgICAubWFwKGNvbnRleHQgPT4gY29udGV4dC5jb250cmFjdE5hbWUpXG4gICAgICAgIC5maWx0ZXIobmFtZSA9PiBuYW1lLmxlbmd0aCA+PSBmaWxsZXJMZW5ndGggLSAzKVxuICAgICAgICAvL3RoZSAtMyBpcyBmb3IgMiBsZWFkaW5nIHVuZGVyc2NvcmVzIGFuZCAxIHRyYWlsaW5nXG4gICAgICAgIC5zb3J0KChuYW1lMSwgbmFtZTIpID0+IG5hbWUyLmxlbmd0aCAtIG5hbWUxLmxlbmd0aCk7XG5cbiAgICAgIGRlYnVnKFwibmFtZXMgc29ydGVkXCIpO1xuXG4gICAgICAvL25vdywgd2UgbmVlZCB0byB0dXJuIGFsbCB0aGVzZSBuYW1lcyBpbnRvIHJlZ3VsYXIgZXhwcmVzc2lvbnMsIGJlY2F1c2UsXG4gICAgICAvL3VuZm9ydHVuYXRlbHksIHN0ci5yZXBsYWNlKCkgd2lsbCBvbmx5IHJlcGxhY2UgYWxsIGlmIHlvdSB1c2UgYSAvZyByZWdleHA7XG4gICAgICAvL25vdGUgdGhhdCBiZWNhdXNlIG5hbWVzIG1heSBjb250YWluICckJywgd2UgbmVlZCB0byBlc2NhcGUgdGhlbVxuICAgICAgLy8oYWxzbyB3ZSBwcmVwZW5kIFwiX19cIiBiZWNhdXNlIHRoYXQncyB0aGUgcGxhY2Vob2xkZXIgZm9ybWF0KVxuICAgICAgbGV0IHJlZ2V4cHMgPSBuYW1lcy5tYXAoXG4gICAgICAgIG5hbWUgPT4gbmV3IFJlZ0V4cChlc2NhcGVSZWdFeHAoXCJfX1wiICsgbmFtZSksIFwiZ1wiKVxuICAgICAgKTtcblxuICAgICAgZGVidWcoXCJyZWdleHBzIHByZXBhcmVkXCIpO1xuXG4gICAgICAvL2hhdmluZyBkb25lIHNvLCB3ZSBjYW4gZG8gdGhlIHJlcGxhY2UgZm9yIHRoZXNlIG5hbWVzIVxuICAgICAgY29uc3QgcmVwbGFjZW1lbnQgPSBcIi5cIi5yZXBlYXQoZmlsbGVyTGVuZ3RoKTtcbiAgICAgIGZvciAobGV0IHJlZ2V4cCBvZiByZWdleHBzKSB7XG4gICAgICAgIGZvciAobGV0IGNvbnRleHQgb2YgT2JqZWN0LnZhbHVlcyhuZXdTdGF0ZS5ieUNvbnRleHQpKSB7XG4gICAgICAgICAgY29udGV4dC5iaW5hcnkgPSBjb250ZXh0LmJpbmFyeS5yZXBsYWNlKHJlZ2V4cCwgcmVwbGFjZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGRlYnVnKFwibG9uZyByZXBsYWNlbWVudHMgY29tcGxldGVcIik7XG5cbiAgICAgIC8vbm93IHdlIGNhbiBkbyBhIGdlbmVyaWMgcmVwbGFjZSB0aGF0IHdpbGwgY2F0Y2ggYWxsIG5hbWVzIG9mIGxlbmd0aFxuICAgICAgLy88NDAsIHdoaWxlIGFsc28gY2F0Y2hpbmcgdGhlIFNvbGlkaXR5IGNvbXBpbGVyJ3MgbGluayByZWZlcmVuY2UgZm9ybWF0XG4gICAgICAvL2FzIHdlbGwgYXMgVHJ1ZmZsZSdzLiAgSG9vcmF5IVxuICAgICAgY29uc3QgZ2VuZXJpY1JlZ2V4cCA9IG5ldyBSZWdFeHAoXCJfLntcIiArIChmaWxsZXJMZW5ndGggLSAyKSArIFwifV9cIiwgXCJnXCIpO1xuICAgICAgLy93ZSdyZSBjb25zdHJ1Y3RpbmcgdGhlIHJlZ2V4cCAvXy57Mzh9Xy9nLCBidXQgSSBkaWRuJ3Qgd2FudCB0byB1c2UgYVxuICAgICAgLy9saXRlcmFsIDM4IDpQXG4gICAgICBmb3IgKGxldCBjb250ZXh0IG9mIE9iamVjdC52YWx1ZXMobmV3U3RhdGUuYnlDb250ZXh0KSkge1xuICAgICAgICBjb250ZXh0LmJpbmFyeSA9IGNvbnRleHQuYmluYXJ5LnJlcGxhY2UoZ2VuZXJpY1JlZ2V4cCwgcmVwbGFjZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBkZWJ1ZyhcInNob3J0IHJlcGxhY2VtZW50cyBjb21wbGV0ZVwiKTtcbiAgICAgIC8vYnV0IHRoZXJlJ3Mgb25lIG1vcmUgc3RlcCAtLSBsaWJyYXJpZXMnIGRlcGxveWVkQnl0ZWNvZGUgd2lsbCBpbmNsdWRlXG4gICAgICAvLzBzIGluIHBsYWNlIG9mIHRoZWlyIG93biBhZGRyZXNzIGluc3RlYWQgb2YgYSBsaW5rIHJlZmVyZW5jZSBhdCB0aGVcbiAgICAgIC8vYmVnaW5uaW5nLCBzbyB3ZSBuZWVkIHRvIGFjY291bnQgZm9yIHRoYXQgdG9vXG4gICAgICBjb25zdCBwdXNoQWRkcmVzc0luc3RydWN0aW9uID0gKFxuICAgICAgICAweDYwICtcbiAgICAgICAgRGVjb2RlVXRpbHMuRVZNLkFERFJFU1NfU0laRSAtXG4gICAgICAgIDFcbiAgICAgICkudG9TdHJpbmcoMTYpOyAvL1wiNzNcIlxuICAgICAgZm9yIChsZXQgY29udGV4dCBvZiBPYmplY3QudmFsdWVzKG5ld1N0YXRlLmJ5Q29udGV4dCkpIHtcbiAgICAgICAgaWYgKGNvbnRleHQuY29udHJhY3RLaW5kID09PSBcImxpYnJhcnlcIiAmJiAhY29udGV4dC5pc0NvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgY29udGV4dC5iaW5hcnkgPSBjb250ZXh0LmJpbmFyeS5yZXBsYWNlKFxuICAgICAgICAgICAgXCIweFwiICtcbiAgICAgICAgICAgICAgcHVzaEFkZHJlc3NJbnN0cnVjdGlvbiArXG4gICAgICAgICAgICAgIFwiMDBcIi5yZXBlYXQoRGVjb2RlVXRpbHMuRVZNLkFERFJFU1NfU0laRSksXG4gICAgICAgICAgICBcIjB4XCIgKyBwdXNoQWRkcmVzc0luc3RydWN0aW9uICsgcmVwbGFjZW1lbnRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGRlYnVnKFwiZXh0cmEgbGlicmFyeSByZXBsYWNlbWVudHMgY29tcGxldGVcIik7XG5cbiAgICAgIC8vZmluYWxseSwgcmV0dXJuIHRoaXMgbWVzcyFcbiAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIERlZmF1bHQgY2FzZVxuICAgICAqL1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuY29uc3QgREVGQVVMVF9JTlNUQU5DRVMgPSB7XG4gIGJ5QWRkcmVzczoge30sXG4gIGJ5Q29udGV4dDoge31cbn07XG5cbmZ1bmN0aW9uIGluc3RhbmNlcyhzdGF0ZSA9IERFRkFVTFRfSU5TVEFOQ0VTLCBhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIC8qXG4gICAgICogQWRkaW5nIGEgbmV3IGFkZHJlc3MgZm9yIGNvbnRleHRcbiAgICAgKi9cbiAgICBjYXNlIGFjdGlvbnMuQUREX0lOU1RBTkNFOlxuICAgICAgbGV0IHsgYWRkcmVzcywgY29udGV4dCwgYmluYXJ5IH0gPSBhY3Rpb247XG5cbiAgICAgIC8vIGdldCBrbm93biBhZGRyZXNzZXMgZm9yIHRoaXMgY29udGV4dFxuICAgICAgbGV0IG90aGVySW5zdGFuY2VzID0gc3RhdGUuYnlDb250ZXh0W2NvbnRleHRdIHx8IFtdO1xuICAgICAgbGV0IG90aGVyQWRkcmVzc2VzID0gb3RoZXJJbnN0YW5jZXMubWFwKCh7IGFkZHJlc3MgfSkgPT4gYWRkcmVzcyk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJ5QWRkcmVzczoge1xuICAgICAgICAgIC4uLnN0YXRlLmJ5QWRkcmVzcyxcblxuICAgICAgICAgIFthZGRyZXNzXTogeyBhZGRyZXNzLCBjb250ZXh0LCBiaW5hcnkgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGJ5Q29udGV4dDoge1xuICAgICAgICAgIC4uLnN0YXRlLmJ5Q29udGV4dCxcblxuICAgICAgICAgIC8vIHJlY29uc3RydWN0IGNvbnRleHQgaW5zdGFuY2VzIHRvIGluY2x1ZGUgbmV3IGFkZHJlc3NcbiAgICAgICAgICBbY29udGV4dF06IEFycmF5LmZyb20obmV3IFNldChvdGhlckFkZHJlc3NlcykuYWRkKGFkZHJlc3MpKS5tYXAoXG4gICAgICAgICAgICBhZGRyZXNzID0+ICh7IGFkZHJlc3MgfSlcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAvKlxuICAgICAqIERlZmF1bHQgY2FzZVxuICAgICAqL1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuY29uc3QgREVGQVVMVF9UWCA9IHtcbiAgZ2FzcHJpY2U6IG5ldyBCTigwKSxcbiAgb3JpZ2luOiBEZWNvZGVVdGlscy5FVk0uWkVST19BRERSRVNTXG59O1xuXG5mdW5jdGlvbiB0eChzdGF0ZSA9IERFRkFVTFRfVFgsIGFjdGlvbikge1xuICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuU0FWRV9HTE9CQUxTKSB7XG4gICAgbGV0IHsgZ2FzcHJpY2UsIG9yaWdpbiB9ID0gYWN0aW9uO1xuICAgIHJldHVybiB7IGdhc3ByaWNlLCBvcmlnaW4gfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuY29uc3QgREVGQVVMVF9CTE9DSyA9IHtcbiAgY29pbmJhc2U6IERlY29kZVV0aWxzLkVWTS5aRVJPX0FERFJFU1MsXG4gIGRpZmZpY3VsdHk6IG5ldyBCTigwKSxcbiAgZ2FzbGltaXQ6IG5ldyBCTigwKSxcbiAgbnVtYmVyOiBuZXcgQk4oMCksXG4gIHRpbWVzdGFtcDogbmV3IEJOKDApXG59O1xuXG5mdW5jdGlvbiBibG9jayhzdGF0ZSA9IERFRkFVTFRfQkxPQ0ssIGFjdGlvbikge1xuICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuU0FWRV9HTE9CQUxTKSB7XG4gICAgZGVidWcoXCJhY3Rpb24gJU9cIiwgYWN0aW9uKTtcbiAgICByZXR1cm4gYWN0aW9uLmJsb2NrO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5jb25zdCBnbG9iYWxzID0gY29tYmluZVJlZHVjZXJzKHtcbiAgdHgsXG4gIGJsb2NrXG59KTtcblxuY29uc3QgaW5mbyA9IGNvbWJpbmVSZWR1Y2Vycyh7XG4gIGNvbnRleHRzLFxuICBpbnN0YW5jZXMsXG4gIGdsb2JhbHNcbn0pO1xuXG5mdW5jdGlvbiBjYWxsc3RhY2soc3RhdGUgPSBbXSwgYWN0aW9uKSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIGFjdGlvbnMuQ0FMTDoge1xuICAgICAgY29uc3QgeyBhZGRyZXNzLCBkYXRhLCBzdG9yYWdlQWRkcmVzcywgc2VuZGVyLCB2YWx1ZSB9ID0gYWN0aW9uO1xuICAgICAgcmV0dXJuIHN0YXRlLmNvbmNhdChbeyBhZGRyZXNzLCBkYXRhLCBzdG9yYWdlQWRkcmVzcywgc2VuZGVyLCB2YWx1ZSB9XSk7XG4gICAgfVxuXG4gICAgY2FzZSBhY3Rpb25zLkNSRUFURToge1xuICAgICAgY29uc3QgeyBiaW5hcnksIHN0b3JhZ2VBZGRyZXNzLCBzZW5kZXIsIHZhbHVlIH0gPSBhY3Rpb247XG4gICAgICByZXR1cm4gc3RhdGUuY29uY2F0KFxuICAgICAgICBbeyBiaW5hcnksIGRhdGE6IFwiMHhcIiwgc3RvcmFnZUFkZHJlc3MsIHNlbmRlciwgdmFsdWUgfV1cbiAgICAgICAgLy90aGUgZW1wdHkgZGF0YSBmaWVsZCBpcyB0byBtYWtlIG1zZy5kYXRhIGFuZCBtc2cuc2lnIGNvbWUgb3V0IHJpZ2h0XG4gICAgICApO1xuICAgIH1cblxuICAgIGNhc2UgYWN0aW9ucy5SRVRVUk46XG4gICAgY2FzZSBhY3Rpb25zLkZBSUw6XG4gICAgICAvL3BvcCB0aGUgc3RhY2suLi4gdW5sZXNzIChIQUNLKSB0aGF0IHdvdWxkIGxlYXZlIGl0IGVtcHR5ICh0aGlzIHdpbGxcbiAgICAgIC8vb25seSBoYXBwZW4gYXQgdGhlIGVuZCB3aGVuIHdlIHdhbnQgdG8ga2VlcCB0aGUgbGFzdCBvbmUgYXJvdW5kKVxuICAgICAgcmV0dXJuIHN0YXRlLmxlbmd0aCA+IDEgPyBzdGF0ZS5zbGljZSgwLCAtMSkgOiBzdGF0ZTtcblxuICAgIGNhc2UgYWN0aW9ucy5SRVNFVDpcbiAgICAgIHJldHVybiBbc3RhdGVbMF1dOyAvL2xlYXZlIHRoZSBpbml0aWFsIGNhbGwgc3RpbGwgb24gdGhlIHN0YWNrXG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbi8vZGVmYXVsdCBjb2RleCBzdGFja2ZyYW1lIHdpdGggYSBzaW5nbGUgYWRkcmVzcyAob3Igbm9uZSBpZiBhZGRyZXNzIG5vdFxuLy9zdXBwbGllZClcbmZ1bmN0aW9uIGRlZmF1bHRDb2RleEZyYW1lKGFkZHJlc3MpIHtcbiAgaWYgKGFkZHJlc3MgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB7XG4gICAgICAvL3RoZXJlIHdpbGwgYmUgbW9yZSBoZXJlIGluIHRoZSBmdXR1cmUhXG4gICAgICBhY2NvdW50czoge1xuICAgICAgICBbYWRkcmVzc106IHtcbiAgICAgICAgICAvL3RoZXJlIHdpbGwgYmUgbW9yZSBoZXJlIGluIHRoZSBmdXR1cmUhXG4gICAgICAgICAgc3RvcmFnZToge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vdGhlcmUgd2lsbCBiZSBtb3JlIGhlcmUgaW4gdGhlIGZ1dHVyZSFcbiAgICAgIGFjY291bnRzOiB7fVxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gY29kZXgoc3RhdGUgPSBbXSwgYWN0aW9uKSB7XG4gIGxldCBuZXdTdGF0ZSwgdG9wQ29kZXg7XG5cbiAgY29uc3QgdXBkYXRlRnJhbWVTdG9yYWdlID0gKGZyYW1lLCBhZGRyZXNzLCBzbG90LCB2YWx1ZSkgPT4ge1xuICAgIGxldCBleGlzdGluZ1BhZ2UgPSBmcmFtZS5hY2NvdW50c1thZGRyZXNzXSB8fCB7IHN0b3JhZ2U6IHt9IH07XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmZyYW1lLFxuICAgICAgYWNjb3VudHM6IHtcbiAgICAgICAgLi4uZnJhbWUuYWNjb3VudHMsXG4gICAgICAgIFthZGRyZXNzXToge1xuICAgICAgICAgIC4uLmV4aXN0aW5nUGFnZSxcbiAgICAgICAgICBzdG9yYWdlOiB7XG4gICAgICAgICAgICAuLi5leGlzdGluZ1BhZ2Uuc3RvcmFnZSxcbiAgICAgICAgICAgIFtzbG90XTogdmFsdWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIGFjdGlvbnMuQ0FMTDpcbiAgICBjYXNlIGFjdGlvbnMuQ1JFQVRFOlxuICAgICAgLy9vbiBhIGNhbGwgb3IgY3JlYXRlLCBtYWtlIGEgbmV3IHN0YWNrZnJhbWUsIHRoZW4gYWRkIGEgbmV3IHBhZ2VzIHRvIHRoZVxuICAgICAgLy9jb2RleCBpZiBuZWNlc3Nhcnk7IGRvbid0IGFkZCBhIHplcm8gcGFnZSB0aG91Z2ggKG9yIHBhZ2VzIHRoYXQgYWxyZWFkeVxuICAgICAgLy9leGlzdClcblxuICAgICAgLy9maXJzdCwgYWRkIGEgbmV3IHN0YWNrZnJhbWU7IGlmIHRoZXJlJ3MgYW4gZXhpc3Rpbmcgc3RhY2tmcmFtZSwgY2xvbmVcbiAgICAgIC8vdGhhdCwgb3RoZXJ3aXNlIG1ha2Ugb25lIGZyb20gc2NyYXRjaFxuICAgICAgbmV3U3RhdGUgPVxuICAgICAgICBzdGF0ZS5sZW5ndGggPiAwXG4gICAgICAgICAgPyBbLi4uc3RhdGUsIHN0YXRlW3N0YXRlLmxlbmd0aCAtIDFdXVxuICAgICAgICAgIDogW2RlZmF1bHRDb2RleEZyYW1lKCldO1xuICAgICAgdG9wQ29kZXggPSBuZXdTdGF0ZVtuZXdTdGF0ZS5sZW5ndGggLSAxXTtcbiAgICAgIC8vbm93LCBkbyB3ZSBuZWVkIHRvIGFkZCBhIG5ldyBhZGRyZXNzIHRvIHRoaXMgc3RhY2tmcmFtZT9cbiAgICAgIGlmIChcbiAgICAgICAgdG9wQ29kZXguYWNjb3VudHNbYWN0aW9uLnN0b3JhZ2VBZGRyZXNzXSAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIGFjdGlvbi5zdG9yYWdlQWRkcmVzcyA9PT0gRGVjb2RlVXRpbHMuRVZNLlpFUk9fQUREUkVTU1xuICAgICAgKSB7XG4gICAgICAgIC8vaWYgd2UgZG9uJ3RcbiAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgICAgfVxuICAgICAgLy9pZiB3ZSBkb1xuICAgICAgbmV3U3RhdGVbbmV3U3RhdGUubGVuZ3RoIC0gMV0gPSB7XG4gICAgICAgIC4uLnRvcENvZGV4LFxuICAgICAgICBhY2NvdW50czoge1xuICAgICAgICAgIC4uLnRvcENvZGV4LmFjY291bnRzLFxuICAgICAgICAgIFthY3Rpb24uc3RvcmFnZUFkZHJlc3NdOiB7XG4gICAgICAgICAgICBzdG9yYWdlOiB7fVxuICAgICAgICAgICAgLy90aGVyZSB3aWxsIGJlIG1vcmUgaGVyZSBpbiB0aGUgZnV0dXJlIVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiBuZXdTdGF0ZTtcblxuICAgIGNhc2UgYWN0aW9ucy5TVE9SRToge1xuICAgICAgLy9vbiBhIHN0b3JlLCB0aGUgcmVsZXZhbnQgcGFnZSBzaG91bGQgYWxyZWFkeSBleGlzdCwgc28gd2UgY2FuIGp1c3RcbiAgICAgIC8vYWRkIG9yIHVwZGF0ZSB0aGUgbmVlZGVkIHNsb3RcbiAgICAgIGNvbnN0IHsgYWRkcmVzcywgc2xvdCwgdmFsdWUgfSA9IGFjdGlvbjtcbiAgICAgIGlmIChhZGRyZXNzID09PSBEZWNvZGVVdGlscy5FVk0uWkVST19BRERSRVNTKSB7XG4gICAgICAgIC8vYXMgYWx3YXlzLCB3ZSBkbyBub3QgbWFpbnRhaW4gYSB6ZXJvIHBhZ2VcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfVxuICAgICAgbmV3U3RhdGUgPSBzdGF0ZS5zbGljZSgpOyAvL2Nsb25lIHRoZSBzdGF0ZVxuICAgICAgdG9wQ29kZXggPSBuZXdTdGF0ZVtuZXdTdGF0ZS5sZW5ndGggLSAxXTtcbiAgICAgIG5ld1N0YXRlW25ld1N0YXRlLmxlbmd0aCAtIDFdID0gdXBkYXRlRnJhbWVTdG9yYWdlKFxuICAgICAgICB0b3BDb2RleCxcbiAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgc2xvdCxcbiAgICAgICAgdmFsdWVcbiAgICAgICk7XG4gICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgfVxuXG4gICAgY2FzZSBhY3Rpb25zLkxPQUQ6IHtcbiAgICAgIC8vbG9hZHMgYXJlIGEgbGl0dGxlIG1vcmUgY29tcGxpY2F0ZWQgLS0gdXN1YWxseSB3ZSBkbyBub3RoaW5nLCBidXQgaWZcbiAgICAgIC8vaXQncyBhbiBleHRlcm5hbCBsb2FkICh0aGVyZSB3YXMgbm90aGluZyBhbHJlYWR5IHRoZXJlKSwgdGhlbiB3ZSB3YW50XG4gICAgICAvL3RvIHVwZGF0ZSAqZXZlcnkqIHN0YWNrZnJhbWVcbiAgICAgIGNvbnN0IHsgYWRkcmVzcywgc2xvdCwgdmFsdWUgfSA9IGFjdGlvbjtcbiAgICAgIGlmIChhZGRyZXNzID09PSBEZWNvZGVVdGlscy5FVk0uWkVST19BRERSRVNTKSB7XG4gICAgICAgIC8vYXMgYWx3YXlzLCB3ZSBkbyBub3QgbWFpbnRhaW4gYSB6ZXJvIHBhZ2VcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfVxuICAgICAgdG9wQ29kZXggPSBzdGF0ZVtzdGF0ZS5sZW5ndGggLSAxXTtcbiAgICAgIGlmICh0b3BDb2RleC5hY2NvdW50c1thZGRyZXNzXS5zdG9yYWdlW3Nsb3RdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy9pZiB3ZSBhbHJlYWR5IGhhdmUgYSB2YWx1ZSBpbiB0aGUgKnRvcCogc3RhY2tmcmFtZSwgdXBkYXRlICpubypcbiAgICAgICAgLy9zdGFja2ZyYW1lczsgZG9uJ3QgdXBkYXRlIHRoZSB0b3AgKG5vIG5lZWQsIGl0J3MganVzdCBhIGxvYWQsIG5vdCBhXG4gICAgICAgIC8vc3RvcmUpLCBkb24ndCB1cGRhdGUgdGhlIHJlc3QgKHRoYXQgd291bGQgYmUgd3JvbmcsIHlvdSBtaWdodCBiZVxuICAgICAgICAvL2xvYWRpbmcgYSB2YWx1ZSB0aGF0IHdpbGwgZ2V0IHJldmVydGVkIGxhdGVyKVxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvL2lmIHdlICpkb24ndCogYWxyZWFkeSBoYXZlIGEgdmFsdWUgaW4gdGhlIHRvcCBzdGFja2ZyYW1lLCB0aGF0IG1lYW5zXG4gICAgICAgIC8vd2UncmUgbG9hZGluZyBhIHZhbHVlIGZyb20gYSBwcmV2aW91cyB0cmFuc2FjdGlvbiEgIFRoYXQncyBub3QgYVxuICAgICAgICAvL3ZhbHVlIHRoYXQgd2lsbCBnZXQgcmV2ZXJ0ZWQgaWYgdGhpcyBjYWxsIGZhaWxzLCBzbyB1cGRhdGUgKmV2ZXJ5KlxuICAgICAgICAvL3N0YWNrZnJhbWVcbiAgICAgICAgcmV0dXJuIHN0YXRlLm1hcChmcmFtZSA9PlxuICAgICAgICAgIHVwZGF0ZUZyYW1lU3RvcmFnZShmcmFtZSwgYWRkcmVzcywgc2xvdCwgdmFsdWUpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2FzZSBhY3Rpb25zLlJFVFVSTjpcbiAgICAgIC8vd2Ugd2FudCB0byBwb3AgdGhlIHRvcCB3aGlsZSBtYWtpbmcgdGhlIG5ldyB0b3AgYSBjb3B5IG9mIHRoZSBvbGQgdG9wO1xuICAgICAgLy90aGF0IGlzIHRvIHNheSwgd2Ugd2FudCB0byBkcm9wIGp1c3QgdGhlIGVsZW1lbnQgKnNlY29uZCogZnJvbSB0aGUgdG9wXG4gICAgICAvLyhhbHRob3VnaCwgSEFDSywgaWYgdGhlIHN0YWNrIG9ubHkgaGFzIG9uZSBlbGVtZW50LCBqdXN0IGxlYXZlIGl0IGFsb25lKVxuICAgICAgcmV0dXJuIHN0YXRlLmxlbmd0aCA+IDFcbiAgICAgICAgPyBzdGF0ZS5zbGljZSgwLCAtMikuY29uY2F0KFtzdGF0ZVtzdGF0ZS5sZW5ndGggLSAxXV0pXG4gICAgICAgIDogc3RhdGU7XG5cbiAgICBjYXNlIGFjdGlvbnMuRkFJTDpcbiAgICAgIC8vcG9wIHRoZSBzdGFjay4uLiB1bmxlc3MgKEhBQ0spIHRoYXQgd291bGQgbGVhdmUgaXQgZW1wdHkgKHRoaXMgd2lsbFxuICAgICAgLy9vbmx5IGhhcHBlbiBhdCB0aGUgZW5kIHdoZW4gd2Ugd2FudCB0byBrZWVwIHRoZSBsYXN0IG9uZSBhcm91bmQpXG4gICAgICByZXR1cm4gc3RhdGUubGVuZ3RoID4gMSA/IHN0YXRlLnNsaWNlKDAsIC0xKSA6IHN0YXRlO1xuXG4gICAgY2FzZSBhY3Rpb25zLlJFU0VUOlxuICAgICAgcmV0dXJuIFtkZWZhdWx0Q29kZXhGcmFtZShhY3Rpb24uc3RvcmFnZUFkZHJlc3MpXTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuY29uc3QgcHJvYyA9IGNvbWJpbmVSZWR1Y2Vycyh7XG4gIGNhbGxzdGFjayxcbiAgY29kZXhcbn0pO1xuXG5jb25zdCByZWR1Y2VyID0gY29tYmluZVJlZHVjZXJzKHtcbiAgaW5mbyxcbiAgcHJvY1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHJlZHVjZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2V2bS9yZWR1Y2Vycy5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9hcnJheS9mcm9tXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL2FycmF5L2Zyb21cIlxuLy8gbW9kdWxlIGlkID0gNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwibG9kYXNoLmVzY2FwZXJlZ2V4cFwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImxvZGFzaC5lc2NhcGVyZWdleHBcIlxuLy8gbW9kdWxlIGlkID0gNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgY29tYmluZVJlZHVjZXJzIH0gZnJvbSBcInJlZHV4XCI7XG5cbmltcG9ydCAqIGFzIGFjdGlvbnMgZnJvbSBcIi4vYWN0aW9uc1wiO1xuXG5jb25zdCBERUZBVUxUX1NPVVJDRVMgPSB7XG4gIGJ5SWQ6IHt9XG59O1xuXG5mdW5jdGlvbiBzb3VyY2VzKHN0YXRlID0gREVGQVVMVF9TT1VSQ0VTLCBhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIC8qXG4gICAgICogQWRkaW5nIGEgbmV3IHNvdXJjZVxuICAgICAqL1xuICAgIGNhc2UgYWN0aW9ucy5BRERfU09VUkNFOlxuICAgICAgbGV0IHsgYXN0LCBzb3VyY2UsIHNvdXJjZVBhdGgsIGNvbXBpbGVyIH0gPSBhY3Rpb247XG5cbiAgICAgIGxldCBpZCA9IE9iamVjdC5rZXlzKHN0YXRlLmJ5SWQpLmxlbmd0aDtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYnlJZDoge1xuICAgICAgICAgIC4uLnN0YXRlLmJ5SWQsXG5cbiAgICAgICAgICBbaWRdOiB7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGFzdCxcbiAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgIHNvdXJjZVBhdGgsXG4gICAgICAgICAgICBjb21waWxlclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgIC8qXG4gICAgICogRGVmYXVsdCBjYXNlXG4gICAgICovXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5jb25zdCBpbmZvID0gY29tYmluZVJlZHVjZXJzKHtcbiAgc291cmNlc1xufSk7XG5cbmZ1bmN0aW9uIGZ1bmN0aW9uRGVwdGhTdGFjayhzdGF0ZSA9IFswXSwgYWN0aW9uKSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIGFjdGlvbnMuSlVNUDpcbiAgICAgIGxldCBuZXdTdGF0ZSA9IHN0YXRlLnNsaWNlKCk7IC8vY2xvbmUgdGhlIHN0YXRlXG4gICAgICBjb25zdCBkZWx0YSA9IHNwZWx1bmsoYWN0aW9uLmp1bXBEaXJlY3Rpb24pO1xuICAgICAgbGV0IHRvcCA9IG5ld1N0YXRlW25ld1N0YXRlLmxlbmd0aCAtIDFdO1xuICAgICAgbmV3U3RhdGVbbmV3U3RhdGUubGVuZ3RoIC0gMV0gPSB0b3AgKyBkZWx0YTtcbiAgICAgIHJldHVybiBuZXdTdGF0ZTtcblxuICAgIGNhc2UgYWN0aW9ucy5SRVNFVDpcbiAgICAgIHJldHVybiBbMF07XG5cbiAgICBjYXNlIGFjdGlvbnMuRVhURVJOQUxfQ0FMTDpcbiAgICAgIHJldHVybiBbLi4uc3RhdGUsIHN0YXRlW3N0YXRlLmxlbmd0aCAtIDFdICsgMV07XG5cbiAgICBjYXNlIGFjdGlvbnMuRVhURVJOQUxfUkVUVVJOOlxuICAgICAgLy9qdXN0IHBvcCB0aGUgc3RhY2shIHVubGVzcywgSEFDSywgdGhhdCB3b3VsZCBsZWF2ZSBpdCBlbXB0eVxuICAgICAgcmV0dXJuIHN0YXRlLmxlbmd0aCA+IDEgPyBzdGF0ZS5zbGljZSgwLCAtMSkgOiBzdGF0ZTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3BlbHVuayhqdW1wKSB7XG4gIGlmIChqdW1wID09PSBcImlcIikge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2UgaWYgKGp1bXAgPT09IFwib1wiKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59XG5cbmNvbnN0IHByb2MgPSBjb21iaW5lUmVkdWNlcnMoe1xuICBmdW5jdGlvbkRlcHRoU3RhY2tcbn0pO1xuXG5jb25zdCByZWR1Y2VyID0gY29tYmluZVJlZHVjZXJzKHtcbiAgaW5mbyxcbiAgcHJvY1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHJlZHVjZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3NvbGlkaXR5L3JlZHVjZXJzLmpzIiwiaW1wb3J0IHsgY29tYmluZVJlZHVjZXJzIH0gZnJvbSBcInJlZHV4XCI7XG5cbmltcG9ydCAqIGFzIGFjdGlvbnMgZnJvbSBcIi4vYWN0aW9uc1wiO1xuXG5mdW5jdGlvbiBpbmRleChzdGF0ZSA9IDAsIGFjdGlvbikge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBhY3Rpb25zLlRPQ0s6XG4gICAgICByZXR1cm4gc3RhdGUgKyAxO1xuXG4gICAgY2FzZSBhY3Rpb25zLlJFU0VUOlxuICAgICAgcmV0dXJuIDA7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaGVkKHN0YXRlID0gZmFsc2UsIGFjdGlvbikge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBhY3Rpb25zLkVORF9PRl9UUkFDRTpcbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgY2FzZSBhY3Rpb25zLlJFU0VUOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGVwcyhzdGF0ZSA9IG51bGwsIGFjdGlvbikge1xuICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuU0FWRV9TVEVQUykge1xuICAgIHJldHVybiBhY3Rpb24uc3RlcHM7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbmNvbnN0IGluZm8gPSBjb21iaW5lUmVkdWNlcnMoe1xuICBzdGVwc1xufSk7XG5cbmNvbnN0IHByb2MgPSBjb21iaW5lUmVkdWNlcnMoe1xuICBpbmRleCxcbiAgZmluaXNoZWRcbn0pO1xuXG5jb25zdCByZWR1Y2VyID0gY29tYmluZVJlZHVjZXJzKHtcbiAgaW5mbyxcbiAgcHJvY1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHJlZHVjZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3RyYWNlL3JlZHVjZXJzLmpzIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOmNvbnRyb2xsZXI6cmVkdWNlcnNcIik7XG5cbmltcG9ydCB7IGNvbWJpbmVSZWR1Y2VycyB9IGZyb20gXCJyZWR1eFwiO1xuXG5pbXBvcnQgKiBhcyBhY3Rpb25zIGZyb20gXCIuL2FjdGlvbnNcIjtcblxuZnVuY3Rpb24gYnJlYWtwb2ludHMoc3RhdGUgPSBbXSwgYWN0aW9uKSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIGFjdGlvbnMuQUREX0JSRUFLUE9JTlQ6XG4gICAgICAvL2NoZWNrIGZvciBhbnkgZXhpc3RpbmcgaWRlbnRpY2FsIGJyZWFrcG9pbnRzIHRvIGF2b2lkIHJlZHVuZGFuY3lcbiAgICAgIGlmIChcbiAgICAgICAgc3RhdGUuZmlsdGVyKFxuICAgICAgICAgIGJyZWFrcG9pbnQgPT5cbiAgICAgICAgICAgIGJyZWFrcG9pbnQuc291cmNlSWQgPT09IGFjdGlvbi5icmVha3BvaW50LnNvdXJjZUlkICYmXG4gICAgICAgICAgICBicmVha3BvaW50LmxpbmUgPT09IGFjdGlvbi5icmVha3BvaW50LmxpbmUgJiZcbiAgICAgICAgICAgIGJyZWFrcG9pbnQubm9kZSA9PT0gYWN0aW9uLmJyZWFrcG9pbnQubm9kZSAvL21heSBiZSB1bmRlZmluZWRcbiAgICAgICAgKS5sZW5ndGggPiAwXG4gICAgICApIHtcbiAgICAgICAgLy9pZiBpdCdzIGFscmVhZHkgdGhlcmUsIGRvIG5vdGhpbmdcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy9vdGhlcndpc2UgYWRkIGl0XG4gICAgICAgIHJldHVybiBzdGF0ZS5jb25jYXQoW2FjdGlvbi5icmVha3BvaW50XSk7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgYWN0aW9ucy5SRU1PVkVfQlJFQUtQT0lOVDpcbiAgICAgIHJldHVybiBzdGF0ZS5maWx0ZXIoXG4gICAgICAgIGJyZWFrcG9pbnQgPT5cbiAgICAgICAgICBicmVha3BvaW50LnNvdXJjZUlkICE9PSBhY3Rpb24uYnJlYWtwb2ludC5zb3VyY2VJZCB8fFxuICAgICAgICAgIGJyZWFrcG9pbnQubGluZSAhPT0gYWN0aW9uLmJyZWFrcG9pbnQubGluZSB8fFxuICAgICAgICAgIGJyZWFrcG9pbnQubm9kZSAhPT0gYWN0aW9uLmJyZWFrcG9pbnQubm9kZSAvL21heSBiZSB1bmRlZmluZWRcbiAgICAgICk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgYWN0aW9ucy5SRU1PVkVfQUxMX0JSRUFLUE9JTlRTOlxuICAgICAgcmV0dXJuIFtdO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5jb25zdCBDT05UUk9MX0FDVElPTlMgPSBbXG4gIGFjdGlvbnMuQURWQU5DRSxcbiAgYWN0aW9ucy5TVEVQX05FWFQsXG4gIGFjdGlvbnMuU1RFUF9PVkVSLFxuICBhY3Rpb25zLlNURVBfSU5UTyxcbiAgYWN0aW9ucy5TVEVQX09VVCxcbiAgYWN0aW9ucy5DT05USU5VRSxcbiAgYWN0aW9ucy5SRVNFVFxuXTtcblxuZnVuY3Rpb24gaXNTdGVwcGluZyhzdGF0ZSA9IGZhbHNlLCBhY3Rpb24pIHtcbiAgaWYgKENPTlRST0xfQUNUSU9OUy5pbmNsdWRlcyhhY3Rpb24udHlwZSkpIHtcbiAgICBkZWJ1ZyhcImdvdCBzdGVwIHN0YXJ0IGFjdGlvblwiKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5ET05FX1NURVBQSU5HKSB7XG4gICAgZGVidWcoXCJnb3Qgc3RlcCBzdG9wIGFjdGlvblwiKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbmNvbnN0IHJlZHVjZXIgPSBjb21iaW5lUmVkdWNlcnMoe1xuICBicmVha3BvaW50cyxcbiAgaXNTdGVwcGluZ1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHJlZHVjZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2NvbnRyb2xsZXIvcmVkdWNlcnMuanMiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6c2Vzc2lvbjpzZWxlY3RvcnNcIik7XG5cbmltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yVHJlZSwgY3JlYXRlTGVhZiB9IGZyb20gXCJyZXNlbGVjdC10cmVlXCI7XG5cbmltcG9ydCBldm0gZnJvbSBcImxpYi9ldm0vc2VsZWN0b3JzXCI7XG5pbXBvcnQgc29saWRpdHkgZnJvbSBcImxpYi9zb2xpZGl0eS9zZWxlY3RvcnNcIjtcblxuY29uc3Qgc2Vzc2lvbiA9IGNyZWF0ZVNlbGVjdG9yVHJlZSh7XG4gIC8qKlxuICAgKiBzZXNzaW9uLmluZm9cbiAgICovXG4gIGluZm86IHtcbiAgICAvKipcbiAgICAgKiBzZXNzaW9uLmluZm8uYWZmZWN0ZWRJbnN0YW5jZXNcbiAgICAgKi9cbiAgICBhZmZlY3RlZEluc3RhbmNlczogY3JlYXRlTGVhZihcbiAgICAgIFtldm0uaW5mby5pbnN0YW5jZXMsIGV2bS5pbmZvLmNvbnRleHRzLCBzb2xpZGl0eS5pbmZvLnNvdXJjZXNdLFxuXG4gICAgICAoaW5zdGFuY2VzLCBjb250ZXh0cywgc291cmNlcykgPT5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7fSxcbiAgICAgICAgICAuLi5PYmplY3QuZW50cmllcyhpbnN0YW5jZXMpLm1hcCgoW2FkZHJlc3MsIHsgY29udGV4dCwgYmluYXJ5IH1dKSA9PiB7XG4gICAgICAgICAgICBkZWJ1ZyhcImluc3RhbmNlcyAlT1wiLCBpbnN0YW5jZXMpO1xuICAgICAgICAgICAgZGVidWcoXCJjb250ZXh0cyAlT1wiLCBjb250ZXh0cyk7XG4gICAgICAgICAgICBsZXQgeyBjb250cmFjdE5hbWUsIHByaW1hcnlTb3VyY2UgfSA9IGNvbnRleHRzW2NvbnRleHRdO1xuXG4gICAgICAgICAgICBsZXQgc291cmNlID1cbiAgICAgICAgICAgICAgcHJpbWFyeVNvdXJjZSAhPT0gdW5kZWZpbmVkID8gc291cmNlc1twcmltYXJ5U291cmNlXSA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgW2FkZHJlc3NdOiB7XG4gICAgICAgICAgICAgICAgY29udHJhY3ROYW1lLFxuICAgICAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgICAgICBiaW5hcnlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgKVxuICB9LFxuXG4gIC8qKlxuICAgKiBzZXNzaW9uLnRyYW5zYWN0aW9uIChuYW1lc3BhY2UpXG4gICAqL1xuICB0cmFuc2FjdGlvbjoge1xuICAgIC8qKlxuICAgICAqIHNlc3Npb24udHJhbnNhY3Rpb24gKHNlbGVjdG9yKVxuICAgICAqIGNvbnRhaW5zIHRoZSB3ZWIzIHRyYW5zYWN0aW9uIG9iamVjdFxuICAgICAqL1xuICAgIF86IHN0YXRlID0+IHN0YXRlLnNlc3Npb24udHJhbnNhY3Rpb24sXG5cbiAgICAvKipcbiAgICAgKiBzZXNzaW9uLnRyYW5zYWN0aW9uLnJlY2VpcHRcbiAgICAgKiBjb250YWlucyB0aGUgd2ViMyByZWNlaXB0IG9iamVjdFxuICAgICAqL1xuICAgIHJlY2VpcHQ6IHN0YXRlID0+IHN0YXRlLnNlc3Npb24ucmVjZWlwdCxcblxuICAgIC8qKlxuICAgICAqIHNlc3Npb24udHJhbnNhY3Rpb24uYmxvY2tcbiAgICAgKiBjb250YWlucyB0aGUgd2ViMyBibG9jayBvYmplY3RcbiAgICAgKi9cbiAgICBibG9jazogc3RhdGUgPT4gc3RhdGUuc2Vzc2lvbi5ibG9ja1xuICB9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgc2Vzc2lvbjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvc2Vzc2lvbi9zZWxlY3RvcnMvaW5kZXguanMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDN0RBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ0tBO0FBUUE7QUFZQTtBQWVBO0FBT0E7QUFRQTtBQVFBO0FBU0E7QUFRQTtBQVFBO0FBUUE7QUFRQTtBQVNBO0FBU0E7QUFDQTtBQTNIQTtBQUNBO0FBREE7QUFDQTs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDOUhBOzs7Ozs7QUNBQTs7Ozs7O0FDQUE7Ozs7OztBQ0FBOzs7Ozs7QUNBQTs7Ozs7O0FDQUE7Ozs7OztBQ0FBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDQUE7QUFDQTs7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7OztBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTs7Ozs7QUFUQTtBQUNBO0FBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBSUE7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBR0E7Ozs7O0FBS0E7QUFDQTtBQUdBOzs7QUFHQTtBQUNBO0FBR0E7OztBQUdBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQTFGQTtBQUNBO0FBK0ZBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFLQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUtBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUtBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXZIQTtBQTBIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBZEE7QUFDQTtBQWdCQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFSQTtBQWxDQTtBQUNBO0FBNkNBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFLQTs7O0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRkE7QUFJQTtBQUNBO0FBRUE7Ozs7O0FBS0E7QUFHQTtBQURBO0FBQ0E7QUFJQTs7O0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBTUE7QUFDQTtBQUlBOzs7O0FBSUE7QUFDQTtBQUlBOzs7O0FBSUE7QUE5Q0E7QUFDQTtBQW9EQTs7O0FBR0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBR0E7QUFqQkE7QUFsSEE7QUFDQTtBQXlJQTs7O0FBR0E7QUFDQTs7Ozs7QUFLQTtBQUdBO0FBREE7QUFDQTtBQUlBOzs7QUFHQTtBQWhCQTtBQUNBO0FBa0JBOzs7QUFHQTtBQUNBOzs7OztBQUtBO0FBR0E7QUFEQTtBQVJBO0FBN05BO0FBQ0E7QUEyT0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4Z0JBO0FBQ0E7OztBQUVBO0FBQ0E7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFDQTtBQUNBO0FBQUE7QUFDQTs7O0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTs7Ozs7QUFYQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFMQTtBQUhBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUdBO0FBQ0E7QUFLQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBS0E7OztBQUdBO0FBeENBO0FBOENBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7OztBQUdBO0FBSkE7QUFDQTtBQU1BOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBO0FBS0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUlBOzs7QUFHQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUdBO0FBREE7QUFNQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFMQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBRUE7OztBQUdBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE5SUE7QUFDQTtBQWlKQTs7O0FBR0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUVBOzs7QUFHQTtBQUNBO0FBS0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUlBOzs7QUFHQTtBQUNBO0FBSUE7OztBQUdBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBck9BO0FBQ0E7QUEyT0E7Ozs7O0FBS0E7QUFwUUE7QUFDQTtBQXNRQTs7Ozs7O0FDdlZBOzs7Ozs7Ozs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQUNBO0FBWUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBSUE7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUtBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQTdEQTtBQUNBO0FBK0RBOzs7Ozs7Ozs7Ozs7QUM5RUE7QUFRQTtBQVFBO0FBS0E7QUFLQTtBQUtBO0FBS0E7QUFLQTtBQTFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDR0E7QUE4Q0E7QUFJQTtBQVNBO0FBSUE7QUFDQTtBQS9HQTtBQUNBOzs7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBVkE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW5CQTtBQUNBO0FBMEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3JIQTs7Ozs7Ozs7Ozs7O0FDQ0E7QUFTQTtBQU9BO0FBUUE7QUFTQTtBQVFBO0FBUUE7QUFsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7Ozs7O0FDdkRBOzs7Ozs7Ozs7Ozs7QUNDQTtBQUtBO0FBS0E7QUFLQTtBQUtBO0FBS0E7QUFLQTtBQUtBO0FBU0E7QUFRQTtBQVFBO0FBT0E7QUFwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4RUE7QUFDQTs7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7Ozs7O0FBWkE7QUFDQTtBQVlBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQVZBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBO0FBSUE7OztBQUdBO0FBQ0E7OztBQUdBO0FBQ0E7Ozs7QUFJQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7O0FBR0E7QUFPQTtBQUNBO0FBRUE7QUFIQTtBQURBO0FBekJBO0FBSkE7QUFDQTtBQTJDQTs7Ozs7QUFLQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQ0E7QUFTQTs7O0FBR0E7QUFDQTs7OztBQUlBO0FBTEE7QUFDQTtBQWFBOzs7QUFHQTtBQUNBO0FBUUE7OztBQUdBO0FBbkhBO0FBQ0E7QUErSEE7OztBQUdBO0FBQ0E7OztBQUdBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUlBO0FBQ0E7QUFIQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7OztBQUdBO0FBdkRBO0FBQ0E7QUF5REE7OztBQUdBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQWRBO0FBQ0E7QUFnQkE7OztBQUdBO0FBckZBO0FBQ0E7QUEwRkE7OztBQUdBO0FBQ0E7OztBQUdBO0FBR0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTs7O0FBR0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBckJBO0FBQ0E7QUEwQkE7OztBQUdBO0FBQ0E7OztBQUdBO0FBQ0E7OztBQUdBO0FBQ0E7QUFLQTs7O0FBR0E7QUFDQTtBQUtBOzs7QUFHQTtBQUNBO0FBS0E7OztBQUdBO0FBT0E7QUFEQTtBQUNBO0FBS0E7Ozs7OztBQU1BO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFXQTtBQURBO0FBUUE7QUFEQTtBQXBFQTtBQUNBO0FBMkVBOzs7QUFHQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQWFBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFHQTtBQUdBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFLQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBS0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFHQTtBQUNBOzs7Ozs7QUFNQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFJQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUtBO0FBcENBO0FBQ0E7QUEwQ0E7Ozs7O0FBS0E7QUFLQTtBQUpBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUlBOzs7OztBQUtBO0FBQUE7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBRkE7QUFBQTtBQUFBO0FBQUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFqQkE7QUFBQTtBQUFBO0FBQUE7QUFoS0E7QUFyUEE7QUFDQTtBQXlhQTs7O0FBR0E7QUFDQTs7Ozs7QUFLQTtBQUNBOzs7QUFHQTtBQUpBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUdBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFuRUE7QUFDQTtBQXFFQTs7O0FBR0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7OztBQUdBO0FBSkE7QUFSQTtBQTN2QkE7QUFDQTtBQWt4QkE7Ozs7OztBQy8wQkE7Ozs7OztBQ0FBOzs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNBQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQ0E7QUFDQTs7O0FBVEE7QUFDQTtBQVNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7OztBQUdBO0FBQ0E7OztBQUdBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBbkJBO0FBQ0E7QUFxQkE7OztBQUdBO0FBNUNBO0FBQ0E7QUE4Q0E7OztBQUdBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBaERBO0FBQ0E7QUFrREE7Ozs7QUFJQTtBQUNBO0FBQ0E7OztBQUdBO0FBdEhBO0FBQ0E7QUF3SEE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbkhBO0FBSUE7QUFJQTtBQW9kQTtBQUlBO0FBaUZBO0FBQ0E7QUEza0JBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFNQTtBQUNBOzs7Ozs7O0FBdkJBO0FBQ0E7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUhBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbkNBO0FBcUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBakJBO0FBbUJBO0FBQ0E7QUFDQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUF6WEE7QUEyWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBTUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDOWtCQTs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDVUE7QUFjQTtBQXlCQTtBQW1CQTtBQWFBO0FBQ0E7QUFsRkE7QUFDQTs7O0FBRUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBTEE7QUFDQTtBQUtBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQU5BO0FBUUE7Ozs7Ozs7Ozs7OztBQzFGQTtBQVdBO0FBUUE7QUFRQTtBQWtCQTtBQVFBO0FBS0E7QUFRQTtBQW5FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7Ozs7Ozs7Ozs7Ozs7QUMxRUE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBTEE7QUFDQTtBQUtBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUpBO0FBSkE7QUFDQTtBQVdBOzs7Ozs7Ozs7Ozs7QUNKQTtBQVdBO0FBVUE7QUFvQkE7QUF5QkE7QUFrRUE7QUFLQTtBQUNBO0FBNUpBO0FBQ0E7OztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQURBO0FBQ0E7Ozs7O0FBWEE7QUFDQTtBQVdBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzlKQTtBQXdCQTtBQUtBO0FBVUE7QUFVQTtBQVlBO0FBV0E7QUFPQTtBQU9BO0FBVUE7QUFVQTtBQTNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOzs7Ozs7Ozs7Ozs7QUNwR0E7QUFpQ0E7QUFJQTtBQUNBO0FBbERBO0FBQ0E7OztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBVkE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDcERBO0FBV0E7QUFRQTtBQUtBO0FBS0E7QUE5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNoQ0E7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNIQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7Ozs7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWpCQTtBQWtCQTtBQUNBO0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBekVBO0FBQ0E7QUFEQTs7Ozs7Ozs7Ozs7Ozs7OztBQzFCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0FBO0FBQ0E7OztBQUVBO0FBQ0E7OztBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFDQTtBQUNBOzs7QUFBQTtBQUNBOzs7Ozs7O0FBWEE7QUFDQTtBQVdBOzs7QUFHQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBVUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFDQTtBQVlBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBckJBO0FBc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXhCQTtBQXlCQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBUUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFPQTtBQXpQQTtBQUFBOzs7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNOQTtBQUNBOzs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNPQTtBQXlDQTtBQUNBO0FBbERBO0FBQ0E7OztBQUdBO0FBQ0E7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7OztBQU5BO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFOQTtBQUNBO0FBUUE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUMvRUE7Ozs7OztBQ0FBOzs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNuRkE7QUFDQTs7Ozs7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2hSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3pKQTs7Ozs7O0FDQUE7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ25zQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM1QkE7QUFDQTtBQWxCQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7Ozs7O0FBZkE7QUFDQTtBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFGQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM0VBO0FBQ0E7QUEzREE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQVBBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBOzs7Ozs7QUNwRUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDNEJBO0FBQ0E7QUE3QkE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQWRBO0FBQ0E7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBSUE7QUFDQTtBQUVBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDL0pBO0FBMENBO0FBdUJBO0FBQ0E7QUFqS0E7QUFDQTs7O0FBRUE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBckJBO0FBQ0E7QUFDQTtBQW9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFDQTtBQU9BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBVUE7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDeEtBO0FBUUE7QUFRQTtBQVFBO0FBU0E7QUFRQTtBQTBCQTtBQXBFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3pFQTtBQUNBOzs7QUFFQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFKQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWZBO0FBZ0JBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBSUE7QUE1Q0E7QUFBQTs7Ozs7O0FDTkE7Ozs7Ozs7Ozs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUNBO0FBQ0E7QUFEQTtBQUNBOzs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFDQTtBQVFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RFQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7Ozs7O0FBVEE7QUFDQTtBQVNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBSEE7QUFEQTtBQUNBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFIQTtBQUhBO0FBREE7QUFDQTtBQWVBO0FBQ0E7QUF4Q0E7QUEwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFBQTtBQUNBO0FBT0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFEQTtBQVJBO0FBQ0E7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUZBO0FBSUE7QUFFQTtBQUNBO0FBSEE7QUFOQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBM0JBO0FBNkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBRUE7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBREE7QUFGQTtBQUZBO0FBQ0E7QUFXQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBREE7QUFIQTtBQUZBO0FBQ0E7QUFZQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBRUE7QUFGQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFoSEE7QUFrSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyU0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTs7O0FBQ0E7QUFDQTs7Ozs7OztBQVZBO0FBQ0E7QUFVQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZBO0FBRkE7QUFGQTtBQWtCQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBREE7QUFIQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBL0lBO0FBaUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBSkE7QUFQQTtBQUNBO0FBZ0JBOzs7QUFHQTtBQUNBO0FBaENBO0FBa0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF4QkE7QUEwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQUZBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRkE7QUFGQTtBQUZBO0FBRkE7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUZBO0FBRkE7QUFVQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbEdBO0FBb0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBOzs7Ozs7QUM5YUE7Ozs7OztBQ0FBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7Ozs7O0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUhBO0FBREE7QUFDQTtBQWFBOzs7QUFHQTtBQUNBO0FBM0JBO0FBNkJBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW5CQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTs7Ozs7Ozs7Ozs7OztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBOzs7Ozs7Ozs7Ozs7O0FDcERBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTs7Ozs7QUFMQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBaENBO0FBa0NBO0FBQ0E7QUFDQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2RUE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUFBO0FBQ0E7Ozs7O0FBTkE7QUFDQTtBQU1BO0FBQ0E7OztBQUdBO0FBQ0E7OztBQUdBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBREE7QUFPQTtBQXpCQTtBQUNBO0FBNkJBOzs7QUFHQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFqQkE7QUFyQ0E7QUFDQTtBQXlEQTs7OztBIiwic291cmNlUm9vdCI6IiJ9