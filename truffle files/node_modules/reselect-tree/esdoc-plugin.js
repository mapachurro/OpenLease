(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("reselect-tree", [], factory);
	else if(typeof exports === 'object')
		exports["reselect-tree"] = factory();
	else
		root["reselect-tree"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 10);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("debug");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = require("source-map-support/register");

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = require("path");

/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = require("assert");

/***/ }),
/* 4 */,
/* 5 */,
/* 6 */,
/* 7 */,
/* 8 */,
/* 9 */,
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const debug = __webpack_require__(0)("reselect-tree:esdoc-plugin");
const assert = __webpack_require__(3);
const path = __webpack_require__(2);
const fs = __webpack_require__(11);
const DocFactory = __webpack_require__(12);

__webpack_require__(1);

// hack
const ESParser = __webpack_require__(22).default;
const InvalidCodeLogger = __webpack_require__(23).default;
const PathResolver = __webpack_require__(24).default;
const ASTUtil = __webpack_require__(25).default;

class Plugin {
  onHandleDocs(ev) {
    this._docs = ev.data.docs;
    this._option = ev.data.option;

    this._exec();
  }

  _exec() {
    this._setDefault();

    const docs = this._generateDocs();
    this._docs.push(...docs);
  }

  _setDefault() {
    if (!this._option) return;

    const option = this._option;
    assert(option.source);
    if (!option.interfaces) option.interfaces = ['createSelectorTree', 'createLeaf', '<arrow>', '<function>', '<subtree>'];
    if (!option.includes) option.includes = ['selectors/.*\\.js$', 'selectors.js$'];
    if (!option.excludes) option.excludes = ['\\.config\\.js$'];
  }

  /**
   * Generate document from selector code.
   */
  _generateDocs() {
    const option = this._option;
    const results = [];

    if (!option) return results;

    const includes = option.includes.map(v => new RegExp(v));
    const excludes = option.excludes.map(v => new RegExp(v));
    const sourceDirPath = path.resolve(option.source);

    this._walk(option.source, filePath => {
      const relativeFilePath = path.relative(sourceDirPath, filePath);
      let match = false;
      for (const reg of includes) {
        if (relativeFilePath.match(reg)) {
          match = true;
          break;
        }
      }
      if (!match) return;

      for (const reg of excludes) {
        if (relativeFilePath.match(reg)) return;
      }

      console.log(`parse: ${filePath}`);
      const temp = this._traverse(option.interfaces, option.source, filePath);
      if (!temp) return;
      results.push(...temp.results);
    });

    return results;
  }

  /**
   * walk recursive in directory.
   * @param {string} dirPath - target directory path.
   * @param {function(entryPath: string)} callback - callback for find file.
   * @private
   */
  _walk(dirPath, callback) {
    const entries = fs.readdirSync(dirPath);

    for (const entry of entries) {
      const entryPath = path.resolve(dirPath, entry);
      const stat = fs.statSync(entryPath);

      if (stat.isFile()) {
        callback(entryPath);
      } else if (stat.isDirectory()) {
        this._walk(entryPath, callback);
      }
    }
  }

  /**
   * traverse doc comment in selector code file.
   * @param {string[]} interfaces - selector interface names.
   * @param {string} inDirPath - root directory path.
   * @param {string} filePath - target selector code file path.
   * @returns {Object} return document info that is traversed.
   * @property {DocObject[]} results - this is contained selector code.
   * @property {AST} ast - this is AST of selector code.
   * @private
   */
  _traverse(interfaces, inDirPath, filePath) {
    let ast;
    try {
      ast = ESParser.parse(filePath);
    } catch (e) {
      InvalidCodeLogger.showFile(filePath, e);
      return null;
    }
    const pathResolver = new PathResolver(inDirPath, filePath);
    const factory = new DocFactory(interfaces, ast, pathResolver);

    ASTUtil.traverse(ast, (node, parent) => {
      try {
        factory.push(node, parent);
      } catch (e) {
        InvalidCodeLogger.show(filePath, node);
        throw e;
      }
    });

    return { results: factory.results, ast: ast };
  }
}

module.exports = new Plugin();

/***/ }),
/* 11 */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _defineProperty = __webpack_require__(13);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _symbol = __webpack_require__(14);

var _symbol2 = _interopRequireDefault(_symbol);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = __webpack_require__(0)("reselect-tree:esdoc-plugin:factory");
const assert = __webpack_require__(3);
const Doc = __webpack_require__(15);
const FileDoc = __webpack_require__(19);
// hack: depends on ESDoc internal class
const CommentParser = __webpack_require__(21).default;

const already = (0, _symbol2.default)('already');

/**
 * Selector doc factory class.
 * @example
 * let factory = new DocFactory('mocha', ast, pathResolver);
 * factory.push(node, parentNode);
 * let results = factory.results;
 */
class DocFactory {
  /**
   * get unique id.
   * @returns {number} unique id.
   * @private
   */
  static _getUniqueId() {
    if (!this._sequence) /** @type {number} */this._sequence = 0;

    return this._sequence++;
  }

  /**
   * @type {DocObject[]}
   */
  get results() {
    return [...this._results];
  }

  /**
   * create instance.
   * @param {string[]} interfaces - selector interface names.
   * @param {AST} ast - AST of selector code.
   * @param {PathResolver} pathResolver - path resolver of selector code.
   */
  constructor(interfaces, ast, pathResolver) {
    /** @type {string} */
    this._interfaces = interfaces;

    /** @type {AST} */
    this._ast = ast;

    /** @type {PathResolver} */
    this._pathResolver = pathResolver;

    /** @type {DocObject[]} */
    this._results = [];

    // file doc
    const doc = new FileDoc(ast, ast, pathResolver, []);
    this._results.push(doc.value);
  }

  /**
   * push node, and factory process the node.
   * @param {ASTNode} node - target node.
   * @param {ASTNode} parentNode - parent node of target node.
   */
  push(node, parentNode) {
    if (node[already]) return;

    node[already] = true;
    (0, _defineProperty2.default)(node, 'parent', { value: parentNode });

    this._push(node);
  }

  /**
   * match node for conforming as selector to document
   */
  _match(node) {
    var expression;
    var name;
    var iface;
    var children = [];

    /* match node for possible signified types */
    switch (node.type) {
      case "ExpressionStatement":
        expression = node.expression;
        break;

      case "ObjectProperty":
        expression = node;
        break;

      case "VariableDeclaration":
        if (node.declarations.length > 0) {
          expression = node.declarations[0];
        }
        break;

      default:
        return null;
      // debug("skipping node type %s", node.type);
    }

    debug("node %s %O", node.type, node);

    if (!expression) return null;

    debug("expression %s %O", expression.type, expression);

    /* match left-hand side if exists */
    switch (expression.type) {
      case "AssignmentExpression":
        name = expression.left.name;

        children.push(expression); // to assign parent (so we don't lose it)
        expression = expression.right;
        break;

      case "VariableDeclarator":
        name = expression.id.name;

        children.push(expression); // to assign parent (so we don't lose it)
        expression = expression.init;
        break;

      case "ObjectProperty":
        name = expression.key.name;

        children.push(expression); // to assign parent (so we don't lose it)
        expression = expression.value;
        break;
    }

    debug("name %s", name);

    if (!expression) return null;

    /* match right hand side */
    switch (expression.type) {
      case "ArrowFunctionExpression":
        iface = "<arrow>";
        break;

      case "FunctionExpression":
        iface = "<function>";
        break;

      case "CallExpression":
        iface = expression.callee.name;
        break;

      case "ObjectExpression":
        iface = "<subtree>";
        break;

      default:
        return null;
    }

    debug("interface %s", iface);

    if (!this._interfaces.includes(iface)) return;

    // HACK assign state param to make expression work as function
    if (!expression.params) {
      expression.params = [{
        "type": "Identifier",
        "name": "state",
        "types": ["Object"]
      }];
    }

    children.push(expression);

    return {
      "expression": expression,
      "children": children,
      "name": name
    };
  }

  /**
   * push node as selector code.
   * @param {ASTNode} node - target node.
   * @private
   */
  _push(node) {
    const match = this._match(node);
    if (!match) return;

    const expression = match.expression;
    const name = match.name;
    const children = match.children;

    expression[already] = true;

    for (const child of children) {
      (0, _defineProperty2.default)(child, 'parent', { value: node });
    }

    let tags = [];
    if (node.leadingComments && node.leadingComments.length) {
      const comment = node.leadingComments[node.leadingComments.length - 1];
      tags = CommentParser.parse(comment);
    } else {
      return;
    }

    const uniqueId = this.constructor._getUniqueId();
    expression._esdocSelectorId = uniqueId;
    expression._esdocSelectorName = name;

    const selectorDoc = new Doc(this._ast, expression, this._pathResolver, tags);

    this._results.push(selectorDoc.value);
  }
}

module.exports = DocFactory;

/***/ }),
/* 13 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/reflect/define-property");

/***/ }),
/* 14 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/symbol");

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _deleteProperty = __webpack_require__(16);

var _deleteProperty2 = _interopRequireDefault(_deleteProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = __webpack_require__(0)("reselect-tree:esdoc-plugin:doc");
// hack: depends on esdoc internal class
const AbstractDoc = __webpack_require__(17).default;
const ParamParser = __webpack_require__(18).default;

/**
 * Doc Class from selector code file.
 */
class SelectorDoc extends AbstractDoc {
  /**
   * apply own tag.
   * @private
   */
  _apply() {
    super._apply();

    this._$selectorTarget();

    (0, _deleteProperty2.default)(this._value, 'export');
    (0, _deleteProperty2.default)(this._value, 'importPath');
    (0, _deleteProperty2.default)(this._value, 'importStyle');
  }

  /** use name property of self node. */
  _$kind() {
    super._$kind();

    this._value.kind = 'function';
  }

  /** set name and selectorId from special esdoc property. */
  _$name() {
    super._$name();

    const chain = [this._node._esdocSelectorName];
    let parent = this._node.parent;
    while (parent) {
      if (parent._esdocSelectorName) chain.push(parent._esdocSelectorName);
      parent = parent.parent;
    }
    debug("chain %o", chain);
    this._value.name = chain.reverse().join('.');
    this._value.selectorId = this._node._esdocSelectorId;
  }

  _$params() {
    super._$params();

    this._value.params = [{
      "name": "state",
      "types": ["Object"],
      "description": "initial state"
    }];
  }

  _$return() {
    this._value.return = {
      "types": ["Object"],
      "description": "new state"
    };
  }

  /** set memberof to use parent selector nod and file path. */
  _$memberof() {
    super._$memberof();

    const chain = [];
    let parent = this._node.parent;
    while (parent) {
      if (parent._esdocSelectorName) chain.push(parent._esdocSelectorName);
      parent = parent.parent;
    }

    const filePath = this._pathResolver.filePath;

    if (chain.length) {
      this._value.memberof = `${filePath}~${chain.reverse().join('.')}`;
      this._value.selectorDepth = chain.length;
    } else {
      this._value.memberof = filePath;
      this._value.selectorDepth = 0;
    }
  }

  // /** set describe by using selector node arguments. */
  // _$desc() {
  //   super._$desc();
  //   if (this._value.description) return;

  //   this._value.description = this._node.arguments[0].value;
  // }

  /** for @selectorTarget. */
  _$selectorTarget() {
    const values = this._findAllTagValues(['@selector', '@selectorTarget']);
    if (!values) return;

    this._value.selectorTarget = [];
    for (const value of values) {
      const { typeText } = ParamParser.parseParamValue(value, true, false, false);
      this._value.selectorTarget.push(typeText);
    }
  }

  _$selectorTarget() {
    // alias of selectorTarget
  }
}

module.exports = SelectorDoc;

/***/ }),
/* 16 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/reflect/delete-property");

/***/ }),
/* 17 */
/***/ (function(module, exports) {

module.exports = require("esdoc/out/src/Doc/AbstractDoc");

/***/ }),
/* 18 */
/***/ (function(module, exports) {

module.exports = require("esdoc/out/src/Parser/ParamParser");

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// hack: depends on esdoc internal class
const FileDoc = __webpack_require__(20).default;

/**
 * Doc class for selector code file.
 */
class SelectorFileDoc extends FileDoc {
  /** set ``testFile`` to kind. */
  _$kind() {
    this._value.kind = 'file';
  }
}

module.exports = SelectorFileDoc;

/***/ }),
/* 20 */
/***/ (function(module, exports) {

module.exports = require("esdoc/out/src/Doc/FileDoc");

/***/ }),
/* 21 */
/***/ (function(module, exports) {

module.exports = require("esdoc/out/src/Parser/CommentParser");

/***/ }),
/* 22 */
/***/ (function(module, exports) {

module.exports = require("esdoc/out/src/Parser/ESParser");

/***/ }),
/* 23 */
/***/ (function(module, exports) {

module.exports = require("esdoc/out/src/Util/InvalidCodeLogger");

/***/ }),
/* 24 */
/***/ (function(module, exports) {

module.exports = require("esdoc/out/src/Util/PathResolver");

/***/ }),
/* 25 */
/***/ (function(module, exports) {

module.exports = require("esdoc/out/src/Util/ASTUtil");

/***/ })
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXNkb2MtcGx1Z2luLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJ3ZWJwYWNrL2Jvb3RzdHJhcCBhZWQxZDg0ZTM1Y2Y2NjZmYzFhNCIsImV4dGVybmFsIFwiZGVidWdcIiIsImV4dGVybmFsIFwic291cmNlLW1hcC1zdXBwb3J0L3JlZ2lzdGVyXCIiLCJleHRlcm5hbCBcInBhdGhcIiIsImV4dGVybmFsIFwiYXNzZXJ0XCIiLCJsaWIvZXNkb2MtcGx1Z2luL2luZGV4LmpzIiwiZXh0ZXJuYWwgXCJmc1wiIiwibGliL2VzZG9jLXBsdWdpbi9mYWN0b3J5LmpzIiwiZXh0ZXJuYWwgXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvcmVmbGVjdC9kZWZpbmUtcHJvcGVydHlcIiIsImV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbFwiIiwibGliL2VzZG9jLXBsdWdpbi9kb2MuanMiLCJleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9yZWZsZWN0L2RlbGV0ZS1wcm9wZXJ0eVwiIiwiZXh0ZXJuYWwgXCJlc2RvYy9vdXQvc3JjL0RvYy9BYnN0cmFjdERvY1wiIiwiZXh0ZXJuYWwgXCJlc2RvYy9vdXQvc3JjL1BhcnNlci9QYXJhbVBhcnNlclwiIiwibGliL2VzZG9jLXBsdWdpbi9maWxlLWRvYy5qcyIsImV4dGVybmFsIFwiZXNkb2Mvb3V0L3NyYy9Eb2MvRmlsZURvY1wiIiwiZXh0ZXJuYWwgXCJlc2RvYy9vdXQvc3JjL1BhcnNlci9Db21tZW50UGFyc2VyXCIiLCJleHRlcm5hbCBcImVzZG9jL291dC9zcmMvUGFyc2VyL0VTUGFyc2VyXCIiLCJleHRlcm5hbCBcImVzZG9jL291dC9zcmMvVXRpbC9JbnZhbGlkQ29kZUxvZ2dlclwiIiwiZXh0ZXJuYWwgXCJlc2RvYy9vdXQvc3JjL1V0aWwvUGF0aFJlc29sdmVyXCIiLCJleHRlcm5hbCBcImVzZG9jL291dC9zcmMvVXRpbC9BU1RVdGlsXCIiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoXCJyZXNlbGVjdC10cmVlXCIsIFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcInJlc2VsZWN0LXRyZWVcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wicmVzZWxlY3QtdHJlZVwiXSA9IGZhY3RvcnkoKTtcbn0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMTApO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIGFlZDFkODRlMzVjZjY2NmZjMWE0IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZGVidWdcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJkZWJ1Z1wiXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwic291cmNlLW1hcC1zdXBwb3J0L3JlZ2lzdGVyXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwic291cmNlLW1hcC1zdXBwb3J0L3JlZ2lzdGVyXCJcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwicGF0aFwiXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiYXNzZXJ0XCJcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiY29uc3QgZGVidWcgPSByZXF1aXJlKFwiZGVidWdcIikoXCJyZXNlbGVjdC10cmVlOmVzZG9jLXBsdWdpblwiKTtcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IERvY0ZhY3RvcnkgPSByZXF1aXJlKCcuL2ZhY3RvcnknKTtcblxucmVxdWlyZShcInNvdXJjZS1tYXAtc3VwcG9ydC9yZWdpc3RlclwiKTtcblxuLy8gaGFja1xuY29uc3QgRVNQYXJzZXIgPSByZXF1aXJlKCdlc2RvYy9vdXQvc3JjL1BhcnNlci9FU1BhcnNlcicpLmRlZmF1bHQ7XG5jb25zdCBJbnZhbGlkQ29kZUxvZ2dlciA9IHJlcXVpcmUoJ2VzZG9jL291dC9zcmMvVXRpbC9JbnZhbGlkQ29kZUxvZ2dlcicpLmRlZmF1bHQ7XG5jb25zdCBQYXRoUmVzb2x2ZXIgPSByZXF1aXJlKCdlc2RvYy9vdXQvc3JjL1V0aWwvUGF0aFJlc29sdmVyJykuZGVmYXVsdDtcbmNvbnN0IEFTVFV0aWwgPSByZXF1aXJlKCdlc2RvYy9vdXQvc3JjL1V0aWwvQVNUVXRpbCcpLmRlZmF1bHQ7XG5cbmNsYXNzIFBsdWdpbiB7XG4gIG9uSGFuZGxlRG9jcyhldikge1xuICAgIHRoaXMuX2RvY3MgPSBldi5kYXRhLmRvY3M7XG4gICAgdGhpcy5fb3B0aW9uID0gZXYuZGF0YS5vcHRpb247XG5cbiAgICB0aGlzLl9leGVjKCk7XG4gIH1cblxuICBfZXhlYygpIHtcbiAgICB0aGlzLl9zZXREZWZhdWx0KCk7XG5cbiAgICBjb25zdCBkb2NzID0gdGhpcy5fZ2VuZXJhdGVEb2NzKCk7XG4gICAgdGhpcy5fZG9jcy5wdXNoKC4uLmRvY3MpO1xuICB9XG5cbiAgX3NldERlZmF1bHQoKSB7XG4gICAgaWYgKCF0aGlzLl9vcHRpb24pIHJldHVybjtcblxuICAgIGNvbnN0IG9wdGlvbiA9IHRoaXMuX29wdGlvbjtcbiAgICBhc3NlcnQob3B0aW9uLnNvdXJjZSk7XG4gICAgaWYgKCFvcHRpb24uaW50ZXJmYWNlcykgb3B0aW9uLmludGVyZmFjZXMgPSBbXG4gICAgICAnY3JlYXRlU2VsZWN0b3JUcmVlJywgJ2NyZWF0ZUxlYWYnLFxuICAgICAgJzxhcnJvdz4nLCAnPGZ1bmN0aW9uPicsICc8c3VidHJlZT4nXG4gICAgXTtcbiAgICBpZiAoIW9wdGlvbi5pbmNsdWRlcykgb3B0aW9uLmluY2x1ZGVzID0gW1xuICAgICAgJ3NlbGVjdG9ycy8uKlxcXFwuanMkJyxcbiAgICAgICdzZWxlY3RvcnMuanMkJ1xuICAgIF07XG4gICAgaWYgKCFvcHRpb24uZXhjbHVkZXMpIG9wdGlvbi5leGNsdWRlcyA9IFsnXFxcXC5jb25maWdcXFxcLmpzJCddO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGRvY3VtZW50IGZyb20gc2VsZWN0b3IgY29kZS5cbiAgICovXG4gIF9nZW5lcmF0ZURvY3MoKSB7XG4gICAgY29uc3Qgb3B0aW9uID0gdGhpcy5fb3B0aW9uO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcblxuICAgIGlmICghb3B0aW9uKSByZXR1cm4gcmVzdWx0cztcblxuICAgIGNvbnN0IGluY2x1ZGVzID0gb3B0aW9uLmluY2x1ZGVzLm1hcCgodikgPT4gbmV3IFJlZ0V4cCh2KSk7XG4gICAgY29uc3QgZXhjbHVkZXMgPSBvcHRpb24uZXhjbHVkZXMubWFwKCh2KSA9PiBuZXcgUmVnRXhwKHYpKTtcbiAgICBjb25zdCBzb3VyY2VEaXJQYXRoID0gcGF0aC5yZXNvbHZlKG9wdGlvbi5zb3VyY2UpO1xuXG4gICAgdGhpcy5fd2FsayhvcHRpb24uc291cmNlLCAoZmlsZVBhdGgpPT57XG4gICAgICBjb25zdCByZWxhdGl2ZUZpbGVQYXRoID0gcGF0aC5yZWxhdGl2ZShzb3VyY2VEaXJQYXRoLCBmaWxlUGF0aCk7XG4gICAgICBsZXQgbWF0Y2ggPSBmYWxzZTtcbiAgICAgIGZvciAoY29uc3QgcmVnIG9mIGluY2x1ZGVzKSB7XG4gICAgICAgIGlmIChyZWxhdGl2ZUZpbGVQYXRoLm1hdGNoKHJlZykpIHtcbiAgICAgICAgICBtYXRjaCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghbWF0Y2gpIHJldHVybjtcblxuICAgICAgZm9yIChjb25zdCByZWcgb2YgZXhjbHVkZXMpIHtcbiAgICAgICAgaWYgKHJlbGF0aXZlRmlsZVBhdGgubWF0Y2gocmVnKSkgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZyhgcGFyc2U6ICR7ZmlsZVBhdGh9YCk7XG4gICAgICBjb25zdCB0ZW1wID0gdGhpcy5fdHJhdmVyc2Uob3B0aW9uLmludGVyZmFjZXMsIG9wdGlvbi5zb3VyY2UsIGZpbGVQYXRoKTtcbiAgICAgIGlmICghdGVtcCkgcmV0dXJuO1xuICAgICAgcmVzdWx0cy5wdXNoKC4uLnRlbXAucmVzdWx0cyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIC8qKlxuICAgKiB3YWxrIHJlY3Vyc2l2ZSBpbiBkaXJlY3RvcnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkaXJQYXRoIC0gdGFyZ2V0IGRpcmVjdG9yeSBwYXRoLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGVudHJ5UGF0aDogc3RyaW5nKX0gY2FsbGJhY2sgLSBjYWxsYmFjayBmb3IgZmluZCBmaWxlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3dhbGsoZGlyUGF0aCwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBlbnRyaWVzID0gZnMucmVhZGRpclN5bmMoZGlyUGF0aCk7XG5cbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgIGNvbnN0IGVudHJ5UGF0aCA9IHBhdGgucmVzb2x2ZShkaXJQYXRoLCBlbnRyeSk7XG4gICAgICBjb25zdCBzdGF0ID0gZnMuc3RhdFN5bmMoZW50cnlQYXRoKTtcblxuICAgICAgaWYgKHN0YXQuaXNGaWxlKCkpIHtcbiAgICAgICAgY2FsbGJhY2soZW50cnlQYXRoKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgIHRoaXMuX3dhbGsoZW50cnlQYXRoLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIHRyYXZlcnNlIGRvYyBjb21tZW50IGluIHNlbGVjdG9yIGNvZGUgZmlsZS5cbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gaW50ZXJmYWNlcyAtIHNlbGVjdG9yIGludGVyZmFjZSBuYW1lcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGluRGlyUGF0aCAtIHJvb3QgZGlyZWN0b3J5IHBhdGguXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlUGF0aCAtIHRhcmdldCBzZWxlY3RvciBjb2RlIGZpbGUgcGF0aC5cbiAgICogQHJldHVybnMge09iamVjdH0gcmV0dXJuIGRvY3VtZW50IGluZm8gdGhhdCBpcyB0cmF2ZXJzZWQuXG4gICAqIEBwcm9wZXJ0eSB7RG9jT2JqZWN0W119IHJlc3VsdHMgLSB0aGlzIGlzIGNvbnRhaW5lZCBzZWxlY3RvciBjb2RlLlxuICAgKiBAcHJvcGVydHkge0FTVH0gYXN0IC0gdGhpcyBpcyBBU1Qgb2Ygc2VsZWN0b3IgY29kZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF90cmF2ZXJzZShpbnRlcmZhY2VzLCBpbkRpclBhdGgsIGZpbGVQYXRoKSB7XG4gICAgbGV0IGFzdDtcbiAgICB0cnkge1xuICAgICAgYXN0ID0gRVNQYXJzZXIucGFyc2UoZmlsZVBhdGgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIEludmFsaWRDb2RlTG9nZ2VyLnNob3dGaWxlKGZpbGVQYXRoLCBlKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBwYXRoUmVzb2x2ZXIgPSBuZXcgUGF0aFJlc29sdmVyKGluRGlyUGF0aCwgZmlsZVBhdGgpO1xuICAgIGNvbnN0IGZhY3RvcnkgPSBuZXcgRG9jRmFjdG9yeShpbnRlcmZhY2VzLCBhc3QsIHBhdGhSZXNvbHZlcik7XG5cbiAgICBBU1RVdGlsLnRyYXZlcnNlKGFzdCwgKG5vZGUsIHBhcmVudCk9PntcbiAgICAgIHRyeSB7XG4gICAgICAgIGZhY3RvcnkucHVzaChub2RlLCBwYXJlbnQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBJbnZhbGlkQ29kZUxvZ2dlci5zaG93KGZpbGVQYXRoLCBub2RlKTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB7cmVzdWx0czogZmFjdG9yeS5yZXN1bHRzLCBhc3Q6IGFzdH07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgUGx1Z2luKCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2VzZG9jLXBsdWdpbi9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImZzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiZnNcIlxuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiY29uc3QgZGVidWcgPSByZXF1aXJlKFwiZGVidWdcIikoXCJyZXNlbGVjdC10cmVlOmVzZG9jLXBsdWdpbjpmYWN0b3J5XCIpO1xuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG5jb25zdCBEb2MgPSByZXF1aXJlKCcuL2RvYycpO1xuY29uc3QgRmlsZURvYyA9IHJlcXVpcmUoJy4vZmlsZS1kb2MnKTtcbi8vIGhhY2s6IGRlcGVuZHMgb24gRVNEb2MgaW50ZXJuYWwgY2xhc3NcbmNvbnN0IENvbW1lbnRQYXJzZXIgPSByZXF1aXJlKCdlc2RvYy9vdXQvc3JjL1BhcnNlci9Db21tZW50UGFyc2VyJykuZGVmYXVsdDtcblxuY29uc3QgYWxyZWFkeSA9IFN5bWJvbCgnYWxyZWFkeScpO1xuXG4vKipcbiAqIFNlbGVjdG9yIGRvYyBmYWN0b3J5IGNsYXNzLlxuICogQGV4YW1wbGVcbiAqIGxldCBmYWN0b3J5ID0gbmV3IERvY0ZhY3RvcnkoJ21vY2hhJywgYXN0LCBwYXRoUmVzb2x2ZXIpO1xuICogZmFjdG9yeS5wdXNoKG5vZGUsIHBhcmVudE5vZGUpO1xuICogbGV0IHJlc3VsdHMgPSBmYWN0b3J5LnJlc3VsdHM7XG4gKi9cbmNsYXNzIERvY0ZhY3Rvcnkge1xuICAvKipcbiAgICogZ2V0IHVuaXF1ZSBpZC5cbiAgICogQHJldHVybnMge251bWJlcn0gdW5pcXVlIGlkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhdGljIF9nZXRVbmlxdWVJZCgpIHtcbiAgICBpZiAoIXRoaXMuX3NlcXVlbmNlKSAvKiogQHR5cGUge251bWJlcn0gKi8gdGhpcy5fc2VxdWVuY2UgPSAwO1xuXG4gICAgcmV0dXJuIHRoaXMuX3NlcXVlbmNlKys7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0RvY09iamVjdFtdfVxuICAgKi9cbiAgZ2V0IHJlc3VsdHMoKSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLl9yZXN1bHRzXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBjcmVhdGUgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IGludGVyZmFjZXMgLSBzZWxlY3RvciBpbnRlcmZhY2UgbmFtZXMuXG4gICAqIEBwYXJhbSB7QVNUfSBhc3QgLSBBU1Qgb2Ygc2VsZWN0b3IgY29kZS5cbiAgICogQHBhcmFtIHtQYXRoUmVzb2x2ZXJ9IHBhdGhSZXNvbHZlciAtIHBhdGggcmVzb2x2ZXIgb2Ygc2VsZWN0b3IgY29kZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGludGVyZmFjZXMsIGFzdCwgcGF0aFJlc29sdmVyKSB7XG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgdGhpcy5faW50ZXJmYWNlcyA9IGludGVyZmFjZXM7XG5cbiAgICAvKiogQHR5cGUge0FTVH0gKi9cbiAgICB0aGlzLl9hc3QgPSBhc3Q7XG5cbiAgICAvKiogQHR5cGUge1BhdGhSZXNvbHZlcn0gKi9cbiAgICB0aGlzLl9wYXRoUmVzb2x2ZXIgPSBwYXRoUmVzb2x2ZXI7XG5cbiAgICAvKiogQHR5cGUge0RvY09iamVjdFtdfSAqL1xuICAgIHRoaXMuX3Jlc3VsdHMgPSBbXTtcblxuICAgIC8vIGZpbGUgZG9jXG4gICAgY29uc3QgZG9jID0gbmV3IEZpbGVEb2MoYXN0LCBhc3QsIHBhdGhSZXNvbHZlciwgW10pO1xuICAgIHRoaXMuX3Jlc3VsdHMucHVzaChkb2MudmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIHB1c2ggbm9kZSwgYW5kIGZhY3RvcnkgcHJvY2VzcyB0aGUgbm9kZS5cbiAgICogQHBhcmFtIHtBU1ROb2RlfSBub2RlIC0gdGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSB7QVNUTm9kZX0gcGFyZW50Tm9kZSAtIHBhcmVudCBub2RlIG9mIHRhcmdldCBub2RlLlxuICAgKi9cbiAgcHVzaChub2RlLCBwYXJlbnROb2RlKSB7XG4gICAgaWYgKG5vZGVbYWxyZWFkeV0pIHJldHVybjtcblxuICAgIG5vZGVbYWxyZWFkeV0gPSB0cnVlO1xuICAgIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkobm9kZSwgJ3BhcmVudCcsIHt2YWx1ZTogcGFyZW50Tm9kZX0pO1xuXG4gICAgdGhpcy5fcHVzaChub2RlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBtYXRjaCBub2RlIGZvciBjb25mb3JtaW5nIGFzIHNlbGVjdG9yIHRvIGRvY3VtZW50XG4gICAqL1xuICBfbWF0Y2gobm9kZSkge1xuICAgIHZhciBleHByZXNzaW9uO1xuICAgIHZhciBuYW1lO1xuICAgIHZhciBpZmFjZTtcbiAgICB2YXIgY2hpbGRyZW4gPSBbXTtcblxuICAgIC8qIG1hdGNoIG5vZGUgZm9yIHBvc3NpYmxlIHNpZ25pZmllZCB0eXBlcyAqL1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlIFwiRXhwcmVzc2lvblN0YXRlbWVudFwiOlxuICAgICAgICBleHByZXNzaW9uID0gbm9kZS5leHByZXNzaW9uO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIk9iamVjdFByb3BlcnR5XCI6XG4gICAgICAgIGV4cHJlc3Npb24gPSBub2RlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIjpcbiAgICAgICAgaWYgKG5vZGUuZGVjbGFyYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBleHByZXNzaW9uID0gbm9kZS5kZWNsYXJhdGlvbnNbMF07XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAvLyBkZWJ1ZyhcInNraXBwaW5nIG5vZGUgdHlwZSAlc1wiLCBub2RlLnR5cGUpO1xuICAgIH1cblxuICAgIGRlYnVnKFwibm9kZSAlcyAlT1wiLCBub2RlLnR5cGUsIG5vZGUpO1xuXG4gICAgaWYgKCFleHByZXNzaW9uKSByZXR1cm4gbnVsbDtcblxuICAgIGRlYnVnKFwiZXhwcmVzc2lvbiAlcyAlT1wiLCBleHByZXNzaW9uLnR5cGUsIGV4cHJlc3Npb24pO1xuXG4gICAgLyogbWF0Y2ggbGVmdC1oYW5kIHNpZGUgaWYgZXhpc3RzICovXG4gICAgc3dpdGNoIChleHByZXNzaW9uLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiOlxuICAgICAgICBuYW1lID0gZXhwcmVzc2lvbi5sZWZ0Lm5hbWU7XG5cbiAgICAgICAgY2hpbGRyZW4ucHVzaChleHByZXNzaW9uKTsgIC8vIHRvIGFzc2lnbiBwYXJlbnQgKHNvIHdlIGRvbid0IGxvc2UgaXQpXG4gICAgICAgIGV4cHJlc3Npb24gPSBleHByZXNzaW9uLnJpZ2h0O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIlZhcmlhYmxlRGVjbGFyYXRvclwiOlxuICAgICAgICBuYW1lID0gZXhwcmVzc2lvbi5pZC5uYW1lO1xuXG4gICAgICAgIGNoaWxkcmVuLnB1c2goZXhwcmVzc2lvbik7ICAvLyB0byBhc3NpZ24gcGFyZW50IChzbyB3ZSBkb24ndCBsb3NlIGl0KVxuICAgICAgICBleHByZXNzaW9uID0gZXhwcmVzc2lvbi5pbml0O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIk9iamVjdFByb3BlcnR5XCI6XG4gICAgICAgIG5hbWUgPSBleHByZXNzaW9uLmtleS5uYW1lO1xuXG4gICAgICAgIGNoaWxkcmVuLnB1c2goZXhwcmVzc2lvbik7ICAvLyB0byBhc3NpZ24gcGFyZW50IChzbyB3ZSBkb24ndCBsb3NlIGl0KVxuICAgICAgICBleHByZXNzaW9uID0gZXhwcmVzc2lvbi52YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZGVidWcoXCJuYW1lICVzXCIsIG5hbWUpO1xuXG4gICAgaWYgKCFleHByZXNzaW9uKSByZXR1cm4gbnVsbDtcblxuICAgIC8qIG1hdGNoIHJpZ2h0IGhhbmQgc2lkZSAqL1xuICAgIHN3aXRjaCAoZXhwcmVzc2lvbi50eXBlKSB7XG4gICAgICBjYXNlIFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIjpcbiAgICAgICAgaWZhY2UgPSBcIjxhcnJvdz5cIjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJGdW5jdGlvbkV4cHJlc3Npb25cIjpcbiAgICAgICAgaWZhY2UgPSBcIjxmdW5jdGlvbj5cIjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJDYWxsRXhwcmVzc2lvblwiOlxuICAgICAgICBpZmFjZSA9IGV4cHJlc3Npb24uY2FsbGVlLm5hbWU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiT2JqZWN0RXhwcmVzc2lvblwiOlxuICAgICAgICBpZmFjZSA9IFwiPHN1YnRyZWU+XCI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBkZWJ1ZyhcImludGVyZmFjZSAlc1wiLCBpZmFjZSk7XG5cbiAgICBpZiAoIXRoaXMuX2ludGVyZmFjZXMuaW5jbHVkZXMoaWZhY2UpKSByZXR1cm47XG5cbiAgICAvLyBIQUNLIGFzc2lnbiBzdGF0ZSBwYXJhbSB0byBtYWtlIGV4cHJlc3Npb24gd29yayBhcyBmdW5jdGlvblxuICAgIGlmICghZXhwcmVzc2lvbi5wYXJhbXMpIHtcbiAgICAgIGV4cHJlc3Npb24ucGFyYW1zID0gW3tcbiAgICAgICAgXCJ0eXBlXCI6IFwiSWRlbnRpZmllclwiLFxuICAgICAgICBcIm5hbWVcIjogXCJzdGF0ZVwiLFxuICAgICAgICBcInR5cGVzXCI6IFtcIk9iamVjdFwiXVxuICAgICAgfV1cbiAgICB9XG5cbiAgICBjaGlsZHJlbi5wdXNoKGV4cHJlc3Npb24pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIFwiZXhwcmVzc2lvblwiOiBleHByZXNzaW9uLFxuICAgICAgXCJjaGlsZHJlblwiOiBjaGlsZHJlbixcbiAgICAgIFwibmFtZVwiOiBuYW1lXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBwdXNoIG5vZGUgYXMgc2VsZWN0b3IgY29kZS5cbiAgICogQHBhcmFtIHtBU1ROb2RlfSBub2RlIC0gdGFyZ2V0IG5vZGUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcHVzaChub2RlKSB7XG4gICAgY29uc3QgbWF0Y2ggPSB0aGlzLl9tYXRjaChub2RlKTtcbiAgICBpZiAoIW1hdGNoKSByZXR1cm47XG5cbiAgICBjb25zdCBleHByZXNzaW9uID0gbWF0Y2guZXhwcmVzc2lvbjtcbiAgICBjb25zdCBuYW1lID0gbWF0Y2gubmFtZTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IG1hdGNoLmNoaWxkcmVuO1xuXG4gICAgZXhwcmVzc2lvblthbHJlYWR5XSA9IHRydWU7XG5cbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgICBSZWZsZWN0LmRlZmluZVByb3BlcnR5KGNoaWxkLCAncGFyZW50Jywge3ZhbHVlOiBub2RlfSk7XG4gICAgfVxuXG4gICAgbGV0IHRhZ3MgPSBbXTtcbiAgICBpZiAobm9kZS5sZWFkaW5nQ29tbWVudHMgJiYgbm9kZS5sZWFkaW5nQ29tbWVudHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBjb21tZW50ID0gbm9kZS5sZWFkaW5nQ29tbWVudHNbbm9kZS5sZWFkaW5nQ29tbWVudHMubGVuZ3RoIC0gMV07XG4gICAgICB0YWdzID0gQ29tbWVudFBhcnNlci5wYXJzZShjb21tZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHVuaXF1ZUlkID0gdGhpcy5jb25zdHJ1Y3Rvci5fZ2V0VW5pcXVlSWQoKTtcbiAgICBleHByZXNzaW9uLl9lc2RvY1NlbGVjdG9ySWQgPSB1bmlxdWVJZDtcbiAgICBleHByZXNzaW9uLl9lc2RvY1NlbGVjdG9yTmFtZSA9IG5hbWU7XG5cbiAgICBjb25zdCBzZWxlY3RvckRvYyA9IG5ldyBEb2ModGhpcy5fYXN0LCBleHByZXNzaW9uLCB0aGlzLl9wYXRoUmVzb2x2ZXIsIHRhZ3MpO1xuXG4gICAgdGhpcy5fcmVzdWx0cy5wdXNoKHNlbGVjdG9yRG9jLnZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERvY0ZhY3Rvcnk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2VzZG9jLXBsdWdpbi9mYWN0b3J5LmpzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL3JlZmxlY3QvZGVmaW5lLXByb3BlcnR5XCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL3JlZmxlY3QvZGVmaW5lLXByb3BlcnR5XCJcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2xcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sXCJcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImNvbnN0IGRlYnVnID0gcmVxdWlyZShcImRlYnVnXCIpKFwicmVzZWxlY3QtdHJlZTplc2RvYy1wbHVnaW46ZG9jXCIpO1xuLy8gaGFjazogZGVwZW5kcyBvbiBlc2RvYyBpbnRlcm5hbCBjbGFzc1xuY29uc3QgQWJzdHJhY3REb2MgPSByZXF1aXJlKCdlc2RvYy9vdXQvc3JjL0RvYy9BYnN0cmFjdERvYycpLmRlZmF1bHQ7XG5jb25zdCBQYXJhbVBhcnNlciA9IHJlcXVpcmUoJ2VzZG9jL291dC9zcmMvUGFyc2VyL1BhcmFtUGFyc2VyJykuZGVmYXVsdDtcblxuLyoqXG4gKiBEb2MgQ2xhc3MgZnJvbSBzZWxlY3RvciBjb2RlIGZpbGUuXG4gKi9cbmNsYXNzIFNlbGVjdG9yRG9jIGV4dGVuZHMgQWJzdHJhY3REb2Mge1xuICAvKipcbiAgICogYXBwbHkgb3duIHRhZy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9hcHBseSgpIHtcbiAgICBzdXBlci5fYXBwbHkoKTtcblxuICAgIHRoaXMuXyRzZWxlY3RvclRhcmdldCgpO1xuXG4gICAgUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSh0aGlzLl92YWx1ZSwgJ2V4cG9ydCcpO1xuICAgIFJlZmxlY3QuZGVsZXRlUHJvcGVydHkodGhpcy5fdmFsdWUsICdpbXBvcnRQYXRoJyk7XG4gICAgUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSh0aGlzLl92YWx1ZSwgJ2ltcG9ydFN0eWxlJyk7XG4gIH1cblxuICAvKiogdXNlIG5hbWUgcHJvcGVydHkgb2Ygc2VsZiBub2RlLiAqL1xuICBfJGtpbmQoKSB7XG4gICAgc3VwZXIuXyRraW5kKCk7XG5cbiAgICB0aGlzLl92YWx1ZS5raW5kID0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIC8qKiBzZXQgbmFtZSBhbmQgc2VsZWN0b3JJZCBmcm9tIHNwZWNpYWwgZXNkb2MgcHJvcGVydHkuICovXG4gIF8kbmFtZSgpIHtcbiAgICBzdXBlci5fJG5hbWUoKTtcblxuICAgIGNvbnN0IGNoYWluID0gW3RoaXMuX25vZGUuX2VzZG9jU2VsZWN0b3JOYW1lXTtcbiAgICBsZXQgcGFyZW50ID0gdGhpcy5fbm9kZS5wYXJlbnQ7XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudC5fZXNkb2NTZWxlY3Rvck5hbWUpIGNoYWluLnB1c2gocGFyZW50Ll9lc2RvY1NlbGVjdG9yTmFtZSk7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cbiAgICBkZWJ1ZyhcImNoYWluICVvXCIsIGNoYWluKTtcbiAgICB0aGlzLl92YWx1ZS5uYW1lID0gY2hhaW4ucmV2ZXJzZSgpLmpvaW4oJy4nKTtcbiAgICB0aGlzLl92YWx1ZS5zZWxlY3RvcklkID0gdGhpcy5fbm9kZS5fZXNkb2NTZWxlY3RvcklkO1xuICB9XG5cbiAgXyRwYXJhbXMoKSB7XG4gICAgc3VwZXIuXyRwYXJhbXMoKTtcblxuICAgIHRoaXMuX3ZhbHVlLnBhcmFtcyA9IFt7XG4gICAgICBcIm5hbWVcIjogXCJzdGF0ZVwiLFxuICAgICAgXCJ0eXBlc1wiOiBbXCJPYmplY3RcIl0sXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiaW5pdGlhbCBzdGF0ZVwiXG4gICAgfV07XG4gIH1cblxuICBfJHJldHVybigpIHtcbiAgICB0aGlzLl92YWx1ZS5yZXR1cm4gPSB7XG4gICAgICBcInR5cGVzXCI6IFtcIk9iamVjdFwiXSxcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJuZXcgc3RhdGVcIlxuICAgIH07XG4gIH1cblxuICAvKiogc2V0IG1lbWJlcm9mIHRvIHVzZSBwYXJlbnQgc2VsZWN0b3Igbm9kIGFuZCBmaWxlIHBhdGguICovXG4gIF8kbWVtYmVyb2YoKSB7XG4gICAgc3VwZXIuXyRtZW1iZXJvZigpO1xuXG4gICAgY29uc3QgY2hhaW4gPSBbXTtcbiAgICBsZXQgcGFyZW50ID0gdGhpcy5fbm9kZS5wYXJlbnQ7XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudC5fZXNkb2NTZWxlY3Rvck5hbWUpIGNoYWluLnB1c2gocGFyZW50Ll9lc2RvY1NlbGVjdG9yTmFtZSk7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cblxuICAgIGNvbnN0IGZpbGVQYXRoID0gdGhpcy5fcGF0aFJlc29sdmVyLmZpbGVQYXRoO1xuXG4gICAgaWYgKGNoYWluLmxlbmd0aCkge1xuICAgICAgdGhpcy5fdmFsdWUubWVtYmVyb2YgPSBgJHtmaWxlUGF0aH1+JHtjaGFpbi5yZXZlcnNlKCkuam9pbignLicpfWA7XG4gICAgICB0aGlzLl92YWx1ZS5zZWxlY3RvckRlcHRoID0gY2hhaW4ubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl92YWx1ZS5tZW1iZXJvZiA9IGZpbGVQYXRoO1xuICAgICAgdGhpcy5fdmFsdWUuc2VsZWN0b3JEZXB0aCA9IDA7XG4gICAgfVxuICB9XG5cbiAgLy8gLyoqIHNldCBkZXNjcmliZSBieSB1c2luZyBzZWxlY3RvciBub2RlIGFyZ3VtZW50cy4gKi9cbiAgLy8gXyRkZXNjKCkge1xuICAvLyAgIHN1cGVyLl8kZGVzYygpO1xuICAvLyAgIGlmICh0aGlzLl92YWx1ZS5kZXNjcmlwdGlvbikgcmV0dXJuO1xuXG4gIC8vICAgdGhpcy5fdmFsdWUuZGVzY3JpcHRpb24gPSB0aGlzLl9ub2RlLmFyZ3VtZW50c1swXS52YWx1ZTtcbiAgLy8gfVxuXG4gIC8qKiBmb3IgQHNlbGVjdG9yVGFyZ2V0LiAqL1xuICBfJHNlbGVjdG9yVGFyZ2V0KCkge1xuICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMuX2ZpbmRBbGxUYWdWYWx1ZXMoWydAc2VsZWN0b3InLCAnQHNlbGVjdG9yVGFyZ2V0J10pO1xuICAgIGlmICghdmFsdWVzKSByZXR1cm47XG5cbiAgICB0aGlzLl92YWx1ZS5zZWxlY3RvclRhcmdldCA9IFtdO1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBjb25zdCB7dHlwZVRleHR9ID0gUGFyYW1QYXJzZXIucGFyc2VQYXJhbVZhbHVlKHZhbHVlLCB0cnVlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgdGhpcy5fdmFsdWUuc2VsZWN0b3JUYXJnZXQucHVzaCh0eXBlVGV4dCk7XG4gICAgfVxuICB9XG5cbiAgXyRzZWxlY3RvclRhcmdldCgpIHtcbiAgICAvLyBhbGlhcyBvZiBzZWxlY3RvclRhcmdldFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2VsZWN0b3JEb2M7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2VzZG9jLXBsdWdpbi9kb2MuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvcmVmbGVjdC9kZWxldGUtcHJvcGVydHlcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvcmVmbGVjdC9kZWxldGUtcHJvcGVydHlcIlxuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZXNkb2Mvb3V0L3NyYy9Eb2MvQWJzdHJhY3REb2NcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJlc2RvYy9vdXQvc3JjL0RvYy9BYnN0cmFjdERvY1wiXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJlc2RvYy9vdXQvc3JjL1BhcnNlci9QYXJhbVBhcnNlclwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImVzZG9jL291dC9zcmMvUGFyc2VyL1BhcmFtUGFyc2VyXCJcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGhhY2s6IGRlcGVuZHMgb24gZXNkb2MgaW50ZXJuYWwgY2xhc3NcbmNvbnN0IEZpbGVEb2MgPSByZXF1aXJlKCdlc2RvYy9vdXQvc3JjL0RvYy9GaWxlRG9jJykuZGVmYXVsdDtcblxuLyoqXG4gKiBEb2MgY2xhc3MgZm9yIHNlbGVjdG9yIGNvZGUgZmlsZS5cbiAqL1xuY2xhc3MgU2VsZWN0b3JGaWxlRG9jIGV4dGVuZHMgRmlsZURvYyB7XG4gIC8qKiBzZXQgYGB0ZXN0RmlsZWBgIHRvIGtpbmQuICovXG4gIF8ka2luZCgpIHtcbiAgICB0aGlzLl92YWx1ZS5raW5kID0gJ2ZpbGUnO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2VsZWN0b3JGaWxlRG9jO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9lc2RvYy1wbHVnaW4vZmlsZS1kb2MuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJlc2RvYy9vdXQvc3JjL0RvYy9GaWxlRG9jXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiZXNkb2Mvb3V0L3NyYy9Eb2MvRmlsZURvY1wiXG4vLyBtb2R1bGUgaWQgPSAyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJlc2RvYy9vdXQvc3JjL1BhcnNlci9Db21tZW50UGFyc2VyXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiZXNkb2Mvb3V0L3NyYy9QYXJzZXIvQ29tbWVudFBhcnNlclwiXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJlc2RvYy9vdXQvc3JjL1BhcnNlci9FU1BhcnNlclwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImVzZG9jL291dC9zcmMvUGFyc2VyL0VTUGFyc2VyXCJcbi8vIG1vZHVsZSBpZCA9IDIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImVzZG9jL291dC9zcmMvVXRpbC9JbnZhbGlkQ29kZUxvZ2dlclwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImVzZG9jL291dC9zcmMvVXRpbC9JbnZhbGlkQ29kZUxvZ2dlclwiXG4vLyBtb2R1bGUgaWQgPSAyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJlc2RvYy9vdXQvc3JjL1V0aWwvUGF0aFJlc29sdmVyXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiZXNkb2Mvb3V0L3NyYy9VdGlsL1BhdGhSZXNvbHZlclwiXG4vLyBtb2R1bGUgaWQgPSAyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJlc2RvYy9vdXQvc3JjL1V0aWwvQVNUVXRpbFwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImVzZG9jL291dC9zcmMvVXRpbC9BU1RVdGlsXCJcbi8vIG1vZHVsZSBpZCA9IDI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUM3REE7Ozs7OztBQ0FBOzs7Ozs7QUNBQTs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUlBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBeEhBO0FBQ0E7QUEwSEE7Ozs7OztBQ3pJQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBakJBO0FBQ0E7QUFtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwQkE7QUFDQTtBQXNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFsQkE7QUFDQTtBQW9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXZNQTtBQUNBO0FBeU1BOzs7Ozs7QUMxTkE7Ozs7OztBQ0FBOzs7Ozs7Ozs7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWxHQTtBQUNBO0FBb0dBOzs7Ozs7QUM3R0E7Ozs7OztBQ0FBOzs7Ozs7QUNBQTs7Ozs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7Ozs7OztBQ2JBOzs7Ozs7QUNBQTs7Ozs7O0FDQUE7Ozs7OztBQ0FBOzs7Ozs7QUNBQTs7Ozs7O0FDQUE7Ozs7QSIsInNvdXJjZVJvb3QiOiIifQ==