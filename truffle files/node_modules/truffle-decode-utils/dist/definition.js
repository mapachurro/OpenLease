"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const debug = debug_1.default("decode-utils:definition");
const evm_1 = require("./evm");
const bn_js_1 = __importDefault(require("bn.js"));
const lodash_clonedeep_1 = __importDefault(require("lodash.clonedeep"));
var Definition;
(function (Definition) {
    function typeIdentifier(definition) {
        return definition.typeDescriptions.typeIdentifier;
    }
    Definition.typeIdentifier = typeIdentifier;
    /**
     * returns basic type class for a variable definition node
     * e.g.:
     *  `t_uint256` becomes `uint`
     *  `t_struct$_Thing_$20_memory_ptr` becomes `struct`
     */
    function typeClass(definition) {
        return typeIdentifier(definition).match(/t_([^$_0-9]+)/)[1];
    }
    Definition.typeClass = typeClass;
    //for user-defined types -- structs, enums, contracts
    //often you can get these from referencedDeclaration, but not
    //always
    function typeId(definition) {
        debug("definition %O", definition);
        return parseInt(typeIdentifier(definition)
            .match(/\$(\d+)(_(storage|memory|calldata)(_ptr)?)?$/)[1]);
    }
    Definition.typeId = typeId;
    /**
     * For function types; returns internal or external
     * (not for use on other types! will cause an error!)
     * should only return "internal" or "external"
     */
    function visibility(definition) {
        return definition.typeName ?
            definition.typeName.visibility : definition.visibility;
    }
    Definition.visibility = visibility;
    /**
     * e.g. uint48 -> 6
     * @return size in bytes for explicit type size, or `null` if not stated
     */
    function specifiedSize(definition) {
        let specified = typeIdentifier(definition).match(/t_[a-z]+([0-9]+)/);
        if (!specified) {
            return null;
        }
        let num = parseInt(specified[1]);
        switch (typeClass(definition)) {
            case "int":
            case "uint":
            case "fixed":
            case "ufixed":
                return num / 8;
            case "bytes":
                return num;
            default:
            // debug("Unknown type for size specification: %s", typeIdentifier(definition));
        }
    }
    Definition.specifiedSize = specifiedSize;
    function isArray(definition) {
        return typeIdentifier(definition).match(/^t_array/) != null;
    }
    Definition.isArray = isArray;
    function isDynamicArray(definition) {
        return isArray(definition) && (
        //NOTE: we do this by parsing the type identifier, rather than by just
        //checking the length field, because we might be using this on a faked-up
        //definition
        typeIdentifier(definition).match(/\$dyn_(storage|memory|calldata)(_ptr)?$/) != null);
    }
    Definition.isDynamicArray = isDynamicArray;
    //length of a statically sized array -- please only use for arrays
    //already verified to be static!
    function staticLength(definition) {
        //NOTE: we do this by parsing the type identifier, rather than by just
        //checking the length field, because we might be using this on a faked-up
        //definition
        return parseInt(typeIdentifier(definition).match(/\$(\d+)_(storage|memory|calldata)(_ptr)?$/)[1]);
    }
    Definition.staticLength = staticLength;
    function isStruct(definition) {
        return typeIdentifier(definition).match(/^t_struct/) != null;
    }
    Definition.isStruct = isStruct;
    function isMapping(definition) {
        return typeIdentifier(definition).match(/^t_mapping/) != null;
    }
    Definition.isMapping = isMapping;
    function isEnum(definition) {
        return typeIdentifier(definition).match(/^t_enum/) != null;
    }
    Definition.isEnum = isEnum;
    function isReference(definition) {
        return typeIdentifier(definition).match(/_(memory|storage|calldata)(_ptr)?$/) != null;
    }
    Definition.isReference = isReference;
    //note: only use this on things already verified to be references
    function referenceType(definition) {
        return typeIdentifier(definition).match(/_([^_]+)(_ptr)?$/)[1];
    }
    Definition.referenceType = referenceType;
    //stack size, in words, of a given type
    function stackSize(definition) {
        if (typeClass(definition) === "function" &&
            visibility(definition) === "external") {
            return 2;
        }
        if (isReference(definition) && referenceType(definition) === "calldata") {
            if (typeClass(definition) === "string" ||
                typeClass(definition) === "bytes") {
                return 2;
            }
            if (isDynamicArray(definition)) {
                return 2;
            }
        }
        return 1;
    }
    Definition.stackSize = stackSize;
    function isSimpleConstant(definition) {
        const types = ["stringliteral", "rational"];
        return types.includes(typeClass(definition));
    }
    Definition.isSimpleConstant = isSimpleConstant;
    //definition: a storage reference definition
    //location: the location you want it to refer to instead
    function spliceLocation(definition, location) {
        debug("definition %O", definition);
        return Object.assign({}, definition, { typeDescriptions: Object.assign({}, definition.typeDescriptions, { typeIdentifier: definition.typeDescriptions.typeIdentifier
                    .replace(/_(storage|memory|calldata)(?=_ptr$|$)/, "_" + location) }) });
    }
    Definition.spliceLocation = spliceLocation;
    //adds "_ptr" on to the end of type identifiers that might need it; note that
    //this operats on identifiers, not defintions
    function restorePtr(identifier) {
        return identifier.replace(/(?<=_(storage|memory|calldata))$/, "_ptr");
    }
    Definition.restorePtr = restorePtr;
    //extract the actual numerical value from a node of type rational.
    //currently assumes result will be integer (currently returns BN)
    function rationalValue(definition) {
        let identifier = typeIdentifier(definition);
        let absoluteValue = identifier.match(/_(\d+)_by_1$/)[1];
        let isNegative = identifier.match(/_minus_/) != null;
        return isNegative ? new bn_js_1.default(absoluteValue).neg() : new bn_js_1.default(absoluteValue);
    }
    Definition.rationalValue = rationalValue;
    //keyEncoding is used to let soliditySha3 know how to interpret the
    //key for hashing... but if you just give it the honest type, it
    //won't pad, and for value types we need it to pad.
    //Thus, ints and value bytes become the *largest* size of that type
    //addresses are treated by Solidity as uint160, so we mark them uint
    //to get the correct padding
    //bool... I can't get soliditySha3 to pad a bool no matter what, so
    //we'll leave it undefined and handle it manually
    //note that while fixed and ufixed don't exist yet, they would
    //presumably use fixed256xM and ufixed256xM, where M is the precision
    function keyEncoding(keyDefinition) {
        switch (typeClass(keyDefinition)) {
            case "string":
                return "string";
            case "bytes":
                if (specifiedSize(keyDefinition) === null) {
                    return "bytes";
                }
                return "bytes32";
            case "uint":
            case "address":
                return "uint";
            case "int":
                return "int";
            case "bool":
                return undefined; //HACK
                break;
        }
    }
    Definition.keyEncoding = keyEncoding;
    function baseDefinition(definition) {
        if (definition.typeName && definition.typeName.baseType) {
            return definition.typeName.baseType;
        }
        if (definition.baseType) {
            return definition.baseType;
        }
        //otherwise, we'll have to fake it up ourselves
        let baseIdentifier = typeIdentifier(definition)
            .match(/^t_array\$_(.*)_\$/)[1];
        //greedy match to extract everything from first to last dollar sign
        // HACK - internal types for memory or storage also seem to be pointers
        if (baseIdentifier.match(/_(memory|storage|calldata)$/) != null) {
            baseIdentifier = `${baseIdentifier}_ptr`;
        }
        // another HACK - we get away with it because we're only using that one property
        let result = lodash_clonedeep_1.default(definition);
        result.typeDescriptions.typeIdentifier = baseIdentifier;
        return result;
        //WARNING -- these hacks do *not* correctly handle all cases!
        //they do, however, handle the cases we currently need.
    }
    Definition.baseDefinition = baseDefinition;
    //for use for mappings and arrays only!
    //for arrays, fakes up a uint definition
    function keyDefinition(definition, scopes) {
        let result;
        switch (typeClass(definition)) {
            case "mapping":
                let baseDeclarationId = definition.referencedDeclaration;
                debug("baseDeclarationId %d", baseDeclarationId);
                //if there's a referencedDeclaration, we'll use that
                if (baseDeclarationId !== undefined) {
                    let baseDeclaration = scopes[baseDeclarationId].definition;
                    return baseDeclaration.keyType || baseDeclaration.typeName.keyType;
                }
                //otherwise, we'll need to perform some hackery, similarly to in baseDefinition
                //otherwise, we'll have to fake it up ourselves
                let keyIdentifier = typeIdentifier(definition)
                    .match(/^t_mapping\$_(.*?)_\$/)[1];
                //use *non*-greedy match; note that if the key type could include
                //dollar signs, this could cause a problem, but user-defined types
                //are not allowed as key types, so this can't come up
                // HACK - internal types for memory or storage also seem to be pointers
                if (keyIdentifier.match(/_(memory|storage|calldata)$/) != null) {
                    keyIdentifier = `${keyIdentifier}_ptr`;
                }
                // another HACK - we get away with it because we're only using that one property
                result = lodash_clonedeep_1.default(definition);
                result.typeDescriptions.typeIdentifier = keyIdentifier;
                return result;
            case "array":
                //HACK -- again we should get away with it because for a uint256 we don't
                //really need to inspect the other properties
                result = lodash_clonedeep_1.default(definition);
                result.typeDescriptions.typeIdentifier = "t_uint256";
                return result;
            default:
                debug("unrecognized index access!");
        }
    }
    Definition.keyDefinition = keyDefinition;
    //spoofed definitions we'll need
    //we'll give them id -1 to indicate that they're spoofed
    //id, name, nodeType, typeDescriptions.typeIdentifier
    function spoofUintDefinition(name) {
        return {
            id: -1,
            name,
            nodeType: "VariableDeclaration",
            typeDescriptions: {
                typeIdentifier: "t_uint256"
            }
        };
    }
    Definition.spoofUintDefinition = spoofUintDefinition;
    function spoofAddressPayableDefinition(name) {
        return {
            id: -1,
            name,
            nodeType: "VariableDeclaration",
            typeDescriptions: {
                typeIdentifier: "t_address_payable"
            }
        };
    }
    Definition.spoofAddressPayableDefinition = spoofAddressPayableDefinition;
    Definition.MSG_SIG_DEFINITION = {
        id: -1,
        name: "sig",
        nodeType: "VariableDeclaration",
        typeDescriptions: {
            typeIdentifier: "t_bytes" + evm_1.EVM.SELECTOR_SIZE
        }
    };
    Definition.MSG_DATA_DEFINITION = {
        id: -1,
        name: "data",
        nodeType: "VariableDeclaration",
        typeDescriptions: {
            typeIdentifier: "t_bytes_calldata_ptr"
        }
    };
    Definition.MSG_DEFINITION = {
        id: -1,
        name: "msg",
        nodeType: "VariableDeclaration",
        typeDescriptions: {
            typeIdentifier: "t_magic_message"
        }
    };
    Definition.TX_DEFINITION = {
        id: -1,
        name: "tx",
        nodeType: "VariableDeclaration",
        typeDescriptions: {
            typeIdentifier: "t_magic_transaction"
        }
    };
    Definition.BLOCK_DEFINITION = {
        id: -1,
        name: "block",
        nodeType: "VariableDeclaration",
        typeDescriptions: {
            typeIdentifier: "t_magic_block"
        }
    };
    function spoofThisDefinition(contractName, contractId) {
        let formattedName = contractName.replace(/\$/g, "$$".repeat(3));
        //note that string.replace treats $'s specially in the replacement string;
        //we want 3 $'s for each $ in the input, so we need to put *6* $'s in the
        //replacement string
        return {
            id: -1,
            name: "this",
            nodeType: "VariableDeclaration",
            typeDescriptions: {
                typeIdentifier: "t_contract$_" + formattedName + "_$" + contractId
            }
        };
    }
    Definition.spoofThisDefinition = spoofThisDefinition;
})(Definition = exports.Definition || (exports.Definition = {}));
//# sourceMappingURL=definition.js.map